# Хеш в Go

1. [Хеш-функции](#хеш-функция)
2. [Хеш-таблицы](#хеш-таблица)
3. [Колизии](#колизия)

## Хеш - это?

Хэш — это способ преобразования данных (например, строки) в короткий фиксированный набор символов, называемый хэш-кодом, с помощью специальной функции. Это удобно для быстрого поиска, сравнения или проверки данных.

---

## Что такое хэш в программировании?

Хэш в программировании — это результат работы хэш-функции, которая берет входные данные (например, строку, число) и преобразует их в уникальный (почти всегда) идентификатор фиксированной длины. Основные свойства хэша:

1. **Быстрота вычислений**: хэш-код рассчитывается очень быстро.
2. **Фиксированная длина**: результат всегда имеет одинаковую длину, независимо от размера входных данных.
3. **Однонаправленность**: по хэшу сложно восстановить исходные данные.
4. **Идентичность для одинаковых данных**: одинаковые входные данные всегда дают одинаковый хэш.

**Хэши активно используются в:**

1. Хранении паролей.
2. Поисковых алгоритмах.
3. Проверке целостности данных (например, загрузки файлов).

---

## Пример на Go

Допустим, вы хотите посчитать хэш от строки и сравнить её с другой строкой. Для этого в Go можно использовать встроенную библиотеку `crypto/sha256`.

### Код с примером

```go
package main

import (
 "crypto/sha256"
 "encoding/hex"
 "fmt"
)

func main() {
 // Исходные строки
 data1 := "Привет, мир!"
 data2 := "Привет, Go!"

 // Рассчитаем хэши
 hash1 := sha256.Sum256([]byte(data1)) // Хэш первой строки
 hash2 := sha256.Sum256([]byte(data2)) // Хэш второй строки

 // Выводим хэши в читаемом виде
 fmt.Printf("Хэш 1: %s\n", hex.EncodeToString(hash1[:]))
 fmt.Printf("Хэш 2: %s\n", hex.EncodeToString(hash2[:]))

 // Сравним строки по их хэшу
 if hash1 == hash2 {
  fmt.Println("Строки одинаковы.")
 } else {
  fmt.Println("Строки разные.")
 }
}
```

Если запустить программу, вы увидите что-то вроде:

```bash
Хэш 1: 7d3e9c1c5026718e4b9655b7866cc60b1b9e5b6cb4527e8a8bd5c80d1e9d6e22
Хэш 2: 4636a34e85804773e923b9e1625cdab7f7769c3b3377e667eaa3d95d2b75f0e1
Строки разные.
```

Здесь хэши разные, потому что строки разные. Таким образом, хэши помогают быстро сравнивать данные.

**Объяснение кода:**

1. **`crypto/sha256`** — это библиотека, которая предоставляет алгоритм хэширования SHA-256. Она подходит для безопасного хэширования.
2. **`sha256.Sum256([]byte(data))`** — преобразует строку в массив байтов, а затем рассчитывает её хэш.
3. **`hex.EncodeToString(hash[:])`** — преобразует массив байтов в строку, чтобы было удобно читать результат.
4. Сравнение хэшей показывает, одинаковы ли данные.

---

## Что такое хеш-функция и хеш-таблица в Go?

**Кратко:**

- **Хеш-функция** преобразует ключ в индекс.
- **Хеш-таблица (map)** быстро ищет значение по ключу, используя хеш-функцию.
- В Go встроенные **карты/мапы (maps)** — это оптимизированная реализация хеш-таблиц, простая и удобная для использования.

---

### Хеш-функция

**Хеш-функция** — это алгоритм, который принимает на вход данные (например, строку, число) и возвращает **уникальное число фиксированной длины**, называемое **хешем**.  
Она используется для быстрого поиска и хранения данных. Например:

- Вход: `"hello"` → Хеш: `12345`
- Вход: `"world"` → Хеш: `67890`

**Свойства хеш-функции:**

1. **Быстрота:** Работает очень быстро.
2. **Детерминированность:** Один и тот же вход всегда даёт один и тот же хеш.
3. **Разброс:** Хорошая хеш-функция равномерно распределяет данные, чтобы избежать коллизий.

**Важно!**  
Иногда при использовании хеш-функций возникают [**колизии**](#колизия)

---

### Хеш-таблица

**Хеш-таблица** — это структура данных, которая:

1. Хранит пары "ключ-значение".
2. Использует хеш-функцию для быстрого поиска, добавления и удаления элементов.

Хеш-таблица работает так:

1. Хеш-функция вычисляет хеш для ключа.
2. Этот хеш используется как индекс для хранения значения в таблице.
3. Для поиска значения таблица снова вычисляет хеш ключа и находит значение по индексу.

**Пример:**

- Ключ: `"name"`, Значение: `"Alice"`.
- Хеш для ключа `"name"` → `5`.
- Хранится в ячейке 5 в таблице.

---

### **Как хеш-таблицы устроены в Go?**

В Go встроенной реализацией хеш-таблицы являются **карты/мапы (maps)**.  
Мапы — это структура данных, которая позволяет быстро находить значение по ключу, используя хеш-функцию.

**Синтаксис мапы:**

```go
m := make(map[string]int) // Ключи типа string, значения типа int
```

#### **Пример - Использование карты (хеш-таблицы):**

```go
package main

import "fmt"

func main() {
    // Создаём хеш-таблицу (map)
    m := make(map[string]int)

    // Добавляем пары "ключ-значение"
    m["Alice"] = 25
    m["Bob"] = 30

    // Доступ по ключу
    fmt.Println("Alice's age:", m["Alice"]) // 25

    // Проверяем наличие ключа
    if age, exists := m["Charlie"]; exists {
        fmt.Println("Charlie's age:", age)
    } else {
        fmt.Println("Charlie not found")
    }

    // Удаление элемента
    delete(m, "Bob")

    // Проверяем таблицу после удаления
    fmt.Println(m) // map[Alice:25]
}
```

**Как это работает:**

- При добавлении пары `"Alice" → 25`, хеш-функция вычисляет хеш для `"Alice"` и сохраняет значение в соответствующем месте.
- При доступе по ключу `"Alice"` карта снова вычисляет хеш и возвращает значение `25`.

#### **Пример - Написание простой хеш-функции:**

Для демонстрации создадим свою хеш-функцию и используем её в "ручной" хеш-таблице:

```go
package main

import (
    "fmt"
)

// Простая хеш-функция
func hash(key string, size int) int {
    hash := 0
    for _, char := range key {
        hash += int(char) // Складываем коды символов
    }
    return hash % size // Возвращаем индекс в пределах таблицы
}

func main() {
    // Создаём хеш-таблицу
    size := 10 // Размер таблицы
    table := make([][]string, size)

    // Добавляем элементы
    keys := []string{"Alice", "Bob", "Charlie"}
    for _, key := range keys {
        index := hash(key, size) // Вычисляем хеш
        table[index] = append(table[index], key)
    }

    // Выводим содержимое хеш-таблицы
    fmt.Println("Хеш-таблица:", table)

    // Поиск элемента
    keyToFind := "Alice"
    index := hash(keyToFind, size)
    fmt.Println("Alice хранится в индексе:", index)
}
```

**Объяснение:**

1. **Хеш-функция `hash`:**
   - Преобразует строку в индекс, суммируя ASCII-коды символов и применяя остаток от деления на размер таблицы.
2. **Хеш-таблица:**
   - Создаётся как массив массивов (`[][]string`), чтобы обрабатывать коллизии (если два ключа имеют одинаковый хеш).
3. **Поиск:**
   - Чтобы найти ключ, вычисляется его индекс с помощью хеш-функции.

#### **Пример 3: Коллизии**

Если два ключа имеют одинаковый хеш, это называется **коллизией**.  
Встроенные карты Go автоматически обрабатывают коллизии, но при ручной реализации можно использовать массивы или списки.

```go
// Если hash("Alice") == hash("Charlie"), то оба ключа хранятся в одном индексе.
```

---

## **Колизия**

**Коллизия** в хеш-таблицах — это ситуация, когда **два разных ключа имеют одинаковый хеш**.  
Поскольку хеш-функция преобразует множество ключей в фиксированное количество хеш-значений, коллизии неизбежны, особенно если ключей становится больше, чем возможных хешей.

### **Коллизии бывают из-за:**

1. **Ограниченного диапазона хешей:**
    - Хеш-функция может выдавать только ограниченное количество значений, например, если у нас хеш-таблица на 10 ячеек, то ключей может быть больше, чем 10.

2. **Плохой хеш-функции:**
    - Если хеш-функция распределяет ключи неравномерно, это увеличивает вероятность коллизий.

---

### **Пример коллизии:**

Представьте, что у нас есть хеш-функция, которая берёт первый символ строки и возвращает его ASCII-код:

```go
func simpleHash(key string) int {
    return int(key[0])
}
```

Теперь хеши для ключей:

- `"Apple"` → `65` (ASCII для `'A'`)
- `"Ant"` → `65` (ASCII для `'A'`)

Оба ключа `"Apple"` и `"Ant"` имеют одинаковый хеш `65`, что вызывает **коллизию**.

---

### **Как обрабатываются коллизии?**

Хеш-таблицы используют методы для разрешения коллизий. Вот два популярных подхода:

#### **1. Метод цепочек (chaining):**

**В Go мапы используют метод цепочек.**

- Каждый индекс таблицы содержит не одно значение, а **список** (или другой контейнер).
- Если возникает коллизия, значения с одинаковым хешем добавляются в этот список.

**Пример:**

```go
Индекс 0: [Apple, Ant] // цепочка
Индекс 1: [Banana]
Индекс 2: [Cherry]
```

**Как это выглядит в памяти?**

По индексу 0 содержится 2 ссылки на `apple` и `ant`:

```bash
Хеш-таблица:
Индекс 0: -> ["Apple"] -> ["Ant"]
Индекс 1: -> ["Banana"]
Индекс 2: -> ["Cherry"]
```

**Что происходит?**

1. Хеш-функция вычисляет индекс для ключа:
   - `"Apple"` → индекс `0`.
   - `"Ant"` → индекс `0`.

2. Когда у двух ключей один и тот же индекс (`0`), они не "перезаписывают" друг друга, а добавляются в список, находящийся по этому индексу.

3. В итоге по индексу `0` находится список:  

   ```go
   Индекс 0: [Apple, Ant]
   ```

4. Список содержит ссылки на строки "Apple" и "Ant".
   - В Go строка (string) — это структура, которая сама является ссылочным типом.  
   - Список фактически хранит ссылки на эти строки в памяти, а не их полное содержимое.

---

#### **2. Открытая адресация (open addressing):**

- Вместо хранения списка при коллизии ищется **следующая свободная ячейка**.
- Например:
  - `"Apple"` хешируется в индекс `0`.
  - `"Ant"` тоже хешируется в `0`, но кладётся в `1`, так как `0` уже занята.

---

### **Пример в Go с коллизией:**

```go
package main

import (
    "fmt"
)

// Простая хеш-функция
func simpleHash(key string, size int) int {
    return int(key[0]) % size // Берём первый символ и остаток от деления
}

func main() {
    size := 5
    table := make([][]string, size) // Хеш-таблица с цепочками

    keys := []string{"Apple", "Ant", "Banana", "Cherry", "Avocado"}

    for _, key := range keys {
        index := simpleHash(key, size) // Вычисляем хеш
        table[index] = append(table[index], key) // Добавляем в цепочку
    }

    fmt.Println("Хеш-таблица с коллизиями:")
    for i, bucket := range table {
        fmt.Printf("Индекс %d: %v\n", i, bucket)
    }
}
```

**Вывод:**

```bash
Хеш-таблица с коллизиями:
Индекс 0: [Apple, Ant, Avocado]
Индекс 1: [Banana]
Индекс 2: [Cherry]
Индекс 3: []
Индекс 4: []
```

- Здесь `"Apple"`, `"Ant"` и `"Avocado"` попали в одну ячейку (`Индекс 0`), потому что их хеши совпадают.

---

### **Вывод по коллизиям:**

- **Коллизия неизбежна:** Если ключей больше, чем возможных хешей, всегда будут совпадения.
- **Решение коллизий:** Используют методы, такие как **цепочки** или **открытая адресация**, чтобы избежать конфликтов.
- **В Go карты автоматически обрабатывают коллизии** с помощью метода цепочек, поэтому вам не нужно беспокоиться об их реализации.
