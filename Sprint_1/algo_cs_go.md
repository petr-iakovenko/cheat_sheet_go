# Алгоритмы

## Бинарный поиск

 Бинарный поиск — это алгоритм поиска элемента в отсортированном массиве. Его сложность по времени — **O(log n)**, поскольку массив делится пополам на каждой итерации.

---

### **Шаги бинарного поиска**

1. Возьмем **отсортированный массив**.
2. Найдем **средний элемент**.
3. Если средний элемент равен искомому, возвращаем его индекс.
4. Если искомое значение меньше среднего, повторяем поиск в **левой половине массива**.
5. Если искомое значение больше среднего, повторяем поиск в **правой половине массива**.
6. Если диапазон поиска сократился до нуля, элемент **не найден**.

---

### **Реализация на Go**

```go
package main

import (
  "fmt"
)

// Бинарный поиск
func binarySearch(arr []int, target int) int {
  left, right := 0, len(arr)-1

  for left <= right {
    mid := left + (right-left)/2 // Находим средний индекс

  if arr[mid] == target {
    return mid // Если элемент найден, возвращаем его индекс
  } else if arr[mid] < target {
    left = mid + 1 // Ищем в правой половине
  } else {
    right = mid - 1 // Ищем в левой половине
  }
  }

  return -1 // Элемент не найден
}

func main() {
  // Пример отсортированного массива
  arr := []int{1, 3, 5, 7, 9, 11, 13, 15}
  target := 7

  // Запускаем бинарный поиск
  result := binarySearch(arr, target)

  // Вывод результата
  if result != -1 {
    fmt.Printf("Элемент %d найден на индексе %d\n", target, result)
  } else {
    fmt.Printf("Элемент %d не найден\n", target)
  }
}
```

---

### **Объяснение кода простым языком**

1. **`left` и `right`**: Эти переменные указывают на начало и конец диапазона, в котором ищем элемент.
2. **`mid`**: Находим средний элемент диапазона, чтобы разделить массив пополам.
3. **Сравнение**:
   - Если элемент в середине равен искомому, возвращаем его индекс.
   - Если искомое число меньше среднего, сужаем диапазон к **левой половине**.
   - Если больше среднего, сужаем к **правой половине**.
4. **Цикл**: Повторяем процесс, пока диапазон не станет пустым (то есть `left > right`).
5. **Если элемент не найден**: Возвращаем `-1`.

---

### **Сложность алгоритма**

- **Временная сложность**: **O(log n)**, так как массив делится пополам на каждой итерации.
- **Пространственная сложность**:
  - В итеративной реализации (как в примере) — **O(1)**, так как используется фиксированное количество переменных.
  - В рекурсивной реализации — **O(log n)**, из-за использования стека вызовов.

---

### **Пример работы**

Для массива `{1, 3, 5, 7, 9, 11, 13, 15}` и искомого элемента `7`:

1. **Итерация 1**:
   - `left = 0`, `right = 7`, `mid = 3` (элемент 7).
   - Элемент найден.

Алгоритм завершает работу за 1 итерацию, так как элемент находится в центре массива.

---

**Итог**: Бинарный поиск — простой и быстрый алгоритм для поиска в отсортированных массивах, который делит диапазон пополам на каждой итерации.

---

## Поиск в ширину (BFS) и глубину (DFS)

**BFS** (поиск в ширину) исследует вершины графа, продвигаясь на один уровень за раз, и используется для нахождения кратчайшего пути в графах без весов. **DFS** (поиск в глубину) углубляется в граф, посещая вершины по одному пути до конца, затем откатывается и пробует другие пути.

---

### **Поиск в ширину (BFS)**

**Идея**: Исследует вершины слоями: сначала все ближайшие вершины (уровень 1), затем вершины уровня 2, и так далее.

1. **Алгоритм**:
   - Начать с начальной вершины и добавить её в очередь.
   - Пока очередь не пуста:
     - Извлечь вершину из очереди.
     - Для каждого соседнего узла:
       - Если он не посещен, отметить его как посещенный и добавить в очередь.

2. **Сложность**:
   - **Время**: \(O(V + E)\), где \(V\) — количество вершин, \(E\) — количество рёбер.
   - **Память**: \(O(V)\), так как нужно хранить посещённые вершины и очередь.

3. **Применение**:
   - Нахождение кратчайшего пути в графе без весов.
   - Поиск в лабиринтах.
   - Проверка связности графа.

4. **Реализация на Go**:

```go
package main

import "fmt"

// BFS алгоритм
func bfs(graph map[int][]int, start int) {
  visited := make(map[int]bool)
  queue := []int{start}

  for len(queue) > 0 {
    // Извлекаем первый элемент
    current := queue[0]
    queue = queue[1:]

    // Если узел уже посещён, пропускаем
    if visited[current] {
      continue
    }

  // Отмечаем узел как посещённый
  visited[current] = true
  fmt.Println("Посетили:", current)

  // Добавляем соседей в очередь
  for _, neighbor := range graph[current] {
    if !visited[neighbor] {
      queue = append(queue, neighbor)
    }
  }
  }
}

func main() {
  graph := map[int][]int{
    1: {2, 3},
    2: {4, 5},
    3: {6, 7},
    4: {},
    5: {},
    6: {},
    7: {},
  }
  bfs(graph, 1)
}
```

---

### **Поиск в глубину (DFS)**

**Идея**: Исследует один путь до конца, затем откатывается и пробует следующий. Может быть реализован рекурсивно или с использованием стека.

1. **Алгоритм**:
   - Начать с начальной вершины.
   - Отметить её как посещённую.
   - Рекурсивно посетить всех соседей, которые ещё не посещены.

2. **Сложность**:
   - **Время**: \(O(V + E)\), где \(V\) — количество вершин, \(E\) — количество рёбер.
   - **Память**:
     - **Рекурсивно**: \(O(H)\), где \(H\) — высота рекурсии.
     - **Итеративно**: \(O(V)\) для стека.

3. **Применение**:
   - Обход всех узлов графа.
   - Нахождение компонент связности.
   - Проверка циклов в графах.

4. **Реализация на Go (рекурсивно)**:

```go
package main

import "fmt"

// DFS рекурсивный
func dfs(graph map[int][]int, node int, visited map[int]bool) {
  if visited[node] {
    return
 }

  // Отмечаем узел как посещённый
  visited[node] = true
  fmt.Println("Посетили:", node)

  // Рекурсивно посещаем соседей
  for _, neighbor := range graph[node] {
    if !visited[neighbor] {
      dfs(graph, neighbor, visited)
  }
  }
}

func main() {
  graph := map[int][]int{
    1: {2, 3},
    2: {4, 5},
    3: {6, 7},
    4: {},
    5: {},
    6: {},
    7: {},
  }
  visited := make(map[int]bool)
  dfs(graph, 1, visited)
}
```

---

### **Сравнение BFS и DFS**

| Характеристика       | BFS                              | DFS                              |
|----------------------|----------------------------------|----------------------------------|
| **Стратегия**        | Сначала ширина (слои)           | Сначала глубина (путь до конца) |
| **Структура данных** | Очередь                         | Рекурсия/стек                   |
| **Кратчайший путь**  | Находит                         | Не гарантирует                  |
| **Применение**       | Поиск кратчайшего пути, сети     | Проверка связности, циклы       |
| **Сложность**        | \(O(V + E)\)                    | \(O(V + E)\)                    |

---

### **Итог**

- **BFS** лучше для задач, где важен кратчайший путь.
- **DFS** подходит для глубокого исследования графа, например, для поиска в деревьях, проверки связности или поиска циклов.

---

## Вид сортировок

- **Пузырьковая сортировка**: Простая, но медленная (\(O(n^2)\)).  
- **Сортировка слиянием**: Эффективна для больших массивов (\(O(n \log n)\)).  
- **Быстрая сортировка**: Быстрая на практике, но в худшем случае \(O(n^2)\).  
- **Сортировка кучей**: Хорошо подходит для больших массивов, гарантированно \(O(n \log n)\).  

---

### 1. **Пузырьковая сортировка**

**Идея**: Последовательно сравниваем пары элементов и обмениваем их, если они стоят в неправильном порядке.  

**Алгоритм**:  

1. Проходим по массиву.  
2. Сравниваем соседние элементы, переставляем их при необходимости.  
3. Повторяем процесс, пока массив не будет отсортирован.  

**Сложность**:  

- **Время**: \(O(n^2)\).  
- **Память**: \(O(1)\).  

**Реализация на Go**:  

```go
package main

import "fmt"

// Пузырьковая сортировка
func bubbleSort(arr []int) {
  n := len(arr)
  for i := 0; i < n; i++ {
    for j := 0; j < n-i-1; j++ {
      if arr[j] > arr[j+1] {
        // Меняем элементы местами
        arr[j], arr[j+1] = arr[j+1], arr[j]
      }
    }
  }
}

func main() {
  arr := []int{64, 34, 25, 12, 22, 11, 90}
  bubbleSort(arr)
  fmt.Println("Отсортированный массив:", arr)
}
```

---

### 2. **Сортировка слиянием**

**Идея**: Разделяем массив на две части, сортируем каждую рекурсивно и объединяем.  

**Алгоритм**:  

1. Если массив состоит из 1 элемента, он уже отсортирован.  
2. Разделяем массив пополам.  
3. Сортируем левую и правую половины рекурсивно.  
4. Объединяем две отсортированные половины в один массив.  

**Сложность**:  

- **Время**: \(O(n \log n)\).  
- **Память**: \(O(n)\).  

**Реализация на Go**:  

```go
package main

import "fmt"

// Слияние двух массивов
func merge(left, right []int) []int {
  result := []int{}
  i, j := 0, 0

  for i < len(left) && j < len(right) {
    if left[i] < right[j] {
      result = append(result, left[i])
      i++
    } else {
      result = append(result, right[j])
      j++
    }
  }

  // Добавляем оставшиеся элементы
  result = append(result, left[i:]...)
  result = append(result, right[j:]...)

  return result
}

// Сортировка слиянием
func mergeSort(arr []int) []int {
  if len(arr) <= 1 {
    return arr
  }

  mid := len(arr) / 2
  left := mergeSort(arr[:mid])
  right := mergeSort(arr[mid:])

  return merge(left, right)
}

func main() {
  arr := []int{38, 27, 43, 3, 9, 82, 10}
  sortedArr := mergeSort(arr)
  fmt.Println("Отсортированный массив:", sortedArr)
}
```

---

### 3. **Быстрая сортировка (QuickSort)**

**Идея**: Выбираем элемент (опорный), делим массив на две части: меньше и больше опорного, сортируем их рекурсивно.  

**Алгоритм**:  

1. Выбрать опорный элемент (pivot).  
2. Разделить массив на два подмассива: меньше и больше pivot.  
3. Рекурсивно отсортировать подмассивы.  
4. Соединить результаты.  

**Сложность**:  

- **Средняя**: \(O(n \log n)\).  
- **Худшая**: \(O(n^2)\) (если массив почти отсортирован и pivot выбран неудачно).  
- **Память**: \(O(\log n)\).  

**Реализация на Go**:  

```go
package main

import "fmt"

// Быстрая сортировка
func quickSort(arr []int) []int {
  if len(arr) < 2 {
    return arr
  }

  // Выбираем опорный элемент
  pivot := arr[0]
  left := []int{}
  right := []int{}

  // Разделяем массив
  for _, v := range arr[1:] {
    if v <= pivot {
      left = append(left, v)
  } else {
      right = append(right, v)
  }
  }

  // Рекурсивно сортируем и объединяем
  return append(append(quickSort(left), pivot), quickSort(right)...)
}

func main() {
  arr := []int{10, 7, 8, 9, 1, 5}
  sortedArr := quickSort(arr)
  fmt.Println("Отсортированный массив:", sortedArr)
}
```

---

### 4. **Сортировка кучей (HeapSort)**

**Идея**: Построить бинарную кучу и последовательно извлекать из неё максимальный элемент.  

**Алгоритм**:  

1. Построить кучу из массива.  
2. Повторно извлекать максимальный элемент из корня, перестраивая кучу.  

**Сложность**:  

- **Время**: \(O(n \log n)\).  
- **Память**: \(O(1)\).  

**Реализация на Go**:  

```go
package main

import "fmt"

// Построение кучи
func heapify(arr []int, n, i int) {
  largest := i
  left := 2*i + 1
  right := 2*i + 2

  if left < n && arr[left] > arr[largest] {
    largest = left
  }

  if right < n && arr[right] > arr[largest] {
    largest = right
  }

  if largest != i {
    arr[i], arr[largest] = arr[largest], arr[i]
    heapify(arr, n, largest)
  }
}

// Сортировка кучей
func heapSort(arr []int) {
  n := len(arr)

 // Построение кучи
  for i := n/2 - 1; i >= 0; i-- {
    heapify(arr, n, i)
  }

  // Извлечение элементов
  for i := n - 1; i >= 0; i-- {
    arr[0], arr[i] = arr[i], arr[0]
    heapify(arr, i, 0)
  }
}

func main() {
  arr := []int{12, 11, 13, 5, 6, 7}
  heapSort(arr)
  fmt.Println("Отсортированный массив:", arr)
}
```

---

### Итог

| Алгоритм          | Временная сложность (средняя) | Худшая сложность  | Память  |
|--------------------|-------------------------------|-------------------|---------|
| **Пузырьковая**   | \(O(n^2)\)                   | \(O(n^2)\)       | \(O(1)\)|
| **Слиянием**      | \(O(n \log n)\)              | \(O(n \log n)\)  | \(O(n)\)|
| **Быстрая**       | \(O(n \log n)\)              | \(O(n^2)\)       | \(O(\log n)\) |
| **Кучей**         | \(O(n \log n)\)              | \(O(n \log n)\)  | \(O(1)\) |

## Различия между сортировками

| **Сортировка**      | **Идея**                                              | **Сложность (средняя)** | **Сложность (худшая)** | **Память**          | **Стабильность**           | **Особенности**                                           |
|----------------------|-------------------------------------------------------|-------------------------|------------------------|---------------------|----------------------------|----------------------------------------------------------|
| **Пузырьковая**     | Попарно сравнивает соседние элементы и обменивает их   | \(O(n^2)\)             | \(O(n^2)\)            | \(O(1)\)           | Да (если реализована правильно) | Простая реализация, но низкая производительность.       |
| **Слиянием**        | Разделяет массив на части, сортирует и объединяет их   | \(O(n \log n)\)        | \(O(n \log n)\)       | \(O(n)\)           | Да                         | Хорошо подходит для больших данных, требует доп. памяти. |
| **Быстрая**         | Делит массив по опорному элементу, сортирует части     | \(O(n \log n)\)        | \(O(n^2)\)            | \(O(\log n)\)      | Нет                        | Быстрая на практике, но неустойчива к худшим случаям.    |
| **Кучей**           | Построение бинарной кучи и извлечение максимума        | \(O(n \log n)\)        | \(O(n \log n)\)       | \(O(1)\)           | Нет                        | Гарантированная сложность, но не является стабильной.    |

---

### Ключевые различия

1. **Сложность**:
   - Пузырьковая сортировка самая медленная (\(O(n^2)\)).
   - Слияние, быстрая и кучей имеют \(O(n \log n)\) в среднем.

2. **Память**:
   - Куча и пузырьковая сортировки используют \(O(1)\) дополнительной памяти.
   - Слияние требует \(O(n)\) дополнительной памяти.

3. **Стабильность**:
   - Пузырьковая и слиянием сортировки стабильны (сохраняют порядок равных элементов).
   - Быстрая и кучей нестабильны.

4. **Применение**:
   - **Пузырьковая**: Учебные примеры, редко используется на практике.
   - **Слиянием**: Большие объемы данных, особенно если стабильность важна.
   - **Быстрая**: Универсальна, но может быть плохой на почти отсортированных данных.
   - **Кучей**: Когда нужна сортировка "на месте" с гарантированным временем \(O(n \log n)\).
