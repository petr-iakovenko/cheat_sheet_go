# üõ†Ô∏è –°–ø—Ä–∞–≤–æ—á–Ω–∏–∫ —Ä–µ—à–µ–Ω–∏–π –∞–ª–≥–æ—Ä–∏—Ç–º–∏—á–µ—Å–∫–∏—Ö –∑–∞–¥–∞—á Go

*–ü–æ–¥—Å–∫–∞–∑–∫–∏ –∏ –º–∞—Ç–µ—Ä–∏–∞–ª—ã –¥–ª—è —Å–∞–º–æ—Å—Ç–æ—è—Ç–µ–ª—å–Ω–æ–≥–æ —Ä–µ—à–µ–Ω–∏—è –∑–∞–¥–∞—á –∏–∑ –æ—Å–Ω–æ–≤–Ω–æ–≥–æ —Å–ø—Ä–∞–≤–æ—á–Ω–∏–∫–∞*

## üèÜ –†–µ–π—Ç–∏–Ω–≥ —á–∞—Å—Ç–æ—Ç—ã –≤–æ–ø—Ä–æ—Å–æ–≤ –Ω–∞ Go —Å–æ–±–µ—Å–µ–¥–æ–≤–∞–Ω–∏—è—Ö –ø–æ –∞–ª–≥–æ—Ä–∏—Ç–º–∞–º  

–û—á–µ–Ω—å —á–∞—Å—Ç–æ - ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê  

### **–ö–∞—Ç–µ–≥–æ—Ä–∏—è: –û—á–µ–Ω—å –ß–∞—Å—Ç–æ (–ø–æ—á—Ç–∏ –≤—Å–µ–≥–¥–∞)** ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê

- [**–ó–∞–¥–∞—á–∞ 21  - Producer-Consumer Pattern (–ü–∞—Ç—Ç–µ—Ä–Ω –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å-–ü–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—å)**](#–∑–∞–¥–∞—á–∞-21---producer-consumer-pattern-–ø–∞—Ç—Ç–µ—Ä–Ω-–ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å-–ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—å)
  - *–ü—Ä–∏—á–∏–Ω–∞:* –§—É–Ω–¥–∞–º–µ–Ω—Ç–∞–ª—å–Ω–∞—è –∑–∞–¥–∞—á–∞ –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏ –ø–æ–Ω–∏–º–∞–Ω–∏—è –≥–æ—Ä—É—Ç–∏–Ω –∏ –∫–∞–Ω–∞–ª–æ–≤. –ê–±—Å–æ–ª—é—Ç–Ω—ã–π must-have –¥–ª—è Go —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∞.
- [**–ó–∞–¥–∞—á–∞ 22 - Worker Pool (–ü—É–ª –≤–æ—Ä–∫–µ—Ä–æ–≤)**](#–∑–∞–¥–∞—á–∞-22---worker-pool-–ø—É–ª-–≤–æ—Ä–∫–µ—Ä–æ–≤)
  - *–ü—Ä–∏—á–∏–Ω–∞:* –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏ –ø—Ä–∏–º–µ–Ω–∏–º–∞—è –∑–∞–¥–∞—á–∞, –ø–æ–∫–∞–∑—ã–≤–∞—é—â–∞—è —É–º–µ–Ω–∏–µ —É–ø—Ä–∞–≤–ª—è—Ç—å –ø–∞—Ä–∞–ª–ª–µ–ª–∏–∑–º–æ–º –∏ —Ä–µ—Å—É—Ä—Å–∞–º–∏.
- [**–ó–∞–¥–∞—á–∞ 24 - Data Race Detection (–û–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ –≥–æ–Ω–∫–∏ –¥–∞–Ω–Ω—ã—Ö)**](#–∑–∞–¥–∞—á–∞-24---data-race-detection-–æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ-–≥–æ–Ω–∫–∏-–¥–∞–Ω–Ω—ã—Ö)
  - *–ü—Ä–∏—á–∏–Ω–∞:* –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏ –≤–∞–∂–Ω–æ –¥–ª—è –Ω–∞–ø–∏—Å–∞–Ω–∏—è –±–µ–∑–æ–ø–∞—Å–Ω–æ–≥–æ –∏ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–≥–æ –∫–æ–Ω–∫—É—Ä–µ–Ω—Ç–Ω–æ–≥–æ –∫–æ–¥–∞. –°–æ–±–µ—Å–µ–¥—É—é—â–∏–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –±—É–¥—É—Ç —Å–ø—Ä–∞—à–∏–≤–∞—Ç—å –æ `sync.Mutex`, `RWMutex` –∏ `sync/atomic`.
- [**–ó–∞–¥–∞—á–∞ 2 - Reverse Linked List (–û–±—Ä–∞—Ç–∏—Ç—å —Å–≤—è–∑–∞–Ω–Ω—ã–π —Å–ø–∏—Å–æ–∫)**](#–∑–∞–¥–∞—á–∞-2---reverse-linked-list-–æ–±—Ä–∞—Ç–∏—Ç—å-—Å–≤—è–∑–∞–Ω–Ω—ã–π-—Å–ø–∏—Å–æ–∫)
  - *–ü—Ä–∏—á–∏–Ω–∞:* –ö–ª–∞—Å—Å–∏–∫–∞ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–æ–Ω–∏–º–∞–Ω–∏—è —É–∫–∞–∑–∞—Ç–µ–ª–µ–π –∏ –∏—Ç–µ—Ä–∞—Ü–∏–π, –±–∞–∑–æ–≤–∞—è –∑–∞–¥–∞—á–∞.
- [**–ó–∞–¥–∞—á–∞ 1 - Two Sum (–°—É–º–º–∞ –¥–≤—É—Ö)**](#–∑–∞–¥–∞—á–∞-1---two-sum-—Å—É–º–º–∞-–¥–≤—É—Ö)
  - *–ü—Ä–∏—á–∏–Ω–∞:* –ü—Ä–æ—Å—Ç–æ–π –≤—Ö–æ–¥, –ø—Ä–æ–≤–µ—Ä–∫–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —Ö–µ—à-—Ç–∞–±–ª–∏—Ü (–º–∞–ø –≤ Go).
- [**–ó–∞–¥–∞—á–∞ 3 - Valid Palindrome (–ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–∞–ª–∏–Ω–¥—Ä–æ–º–∞)**](#–∑–∞–¥–∞—á–∞-3---valid-palindrome-–ø—Ä–æ–≤–µ—Ä–∫–∞-–ø–∞–ª–∏–Ω–¥—Ä–æ–º–∞)
  - *–ü—Ä–∏—á–∏–Ω–∞:* –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä–∞–±–æ—Ç—ã —Å–æ —Å—Ç—Ä–æ–∫–∞–º–∏ –∏ —É–∫–∞–∑–∞—Ç–µ–ª—è–º–∏.

### **–ö–∞—Ç–µ–≥–æ—Ä–∏—è: –ß–∞—Å—Ç–æ (–æ–∂–∏–¥–∞–π—Ç–µ –∏—Ö –ø–æ—è–≤–ª–µ–Ω–∏–µ)** ‚≠ê‚≠ê‚≠ê‚≠ê

- [**–ó–∞–¥–∞—á–∞ 4 - Longest Substring Without Repeating (–°–∞–º–∞—è –¥–ª–∏–Ω–Ω–∞—è –ø–æ–¥—Å—Ç—Ä–æ–∫–∞ –±–µ–∑ –ø–æ–≤—Ç–æ—Ä–µ–Ω–∏–π)**](#–∑–∞–¥–∞—á–∞-4---longest-substring-without-repeating-—Å–∞–º–∞—è-–¥–ª–∏–Ω–Ω–∞—è-–ø–æ–¥—Å—Ç—Ä–æ–∫–∞-–±–µ–∑-–ø–æ–≤—Ç–æ—Ä–µ–Ω–∏–π)
  - *–ü—Ä–∏—á–∏–Ω–∞:* "–°–∫–æ–ª—å–∑—è—â–µ–µ –æ–∫–Ω–æ" - –ø–æ–ø—É–ª—è—Ä–Ω—ã–π –ø–∞—Ç—Ç–µ—Ä–Ω, —Ç—Ä–µ–±—É—é—â–∏–π —É–º–µ–Ω–∏—è —Ä–∞–±–æ—Ç–∞—Ç—å —Å –º–∞–ø–∞–º–∏ –∏ –∏–Ω–¥–µ–∫—Å–∞–º–∏.
- [**–ó–∞–¥–∞—á–∞ 9 - Valid Parentheses (–ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–∫–æ–±–æ–∫)**](#–∑–∞–¥–∞—á–∞-9---valid-parentheses-–ø—Ä–æ–≤–µ—Ä–∫–∞-—Å–∫–æ–±–æ–∫)
  - *–ü—Ä–∏—á–∏–Ω–∞:* –ö–ª–∞—Å—Å–∏—á–µ—Å–∫–∞—è –∑–∞–¥–∞—á–∞ –Ω–∞ —Å—Ç–µ–∫.
- [**–ó–∞–¥–∞—á–∞ 5 - Merge Two Sorted Arrays (–û–±—ä–µ–¥–∏–Ω–∏—Ç—å –¥–≤–∞ –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –º–∞—Å—Å–∏–≤–∞)**](#–∑–∞–¥–∞—á–∞-5---merge-two-sorted-arrays-–æ–±—ä–µ–¥–∏–Ω–∏—Ç—å-–¥–≤–∞-–æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö-–º–∞—Å—Å–∏–≤–∞)
  - *–ü—Ä–∏—á–∏–Ω–∞:* –†–∞–±–æ—Ç–∞ —Å –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏ –∏ —É–∫–∞–∑–∞—Ç–µ–ª—è–º–∏/–∏–Ω–¥–µ–∫—Å–∞–º–∏.
- [**–ó–∞–¥–∞—á–∞ 7 - Binary Search (–ë–∏–Ω–∞—Ä–Ω—ã–π –ø–æ–∏—Å–∫)**](#–∑–∞–¥–∞—á–∞-7---binary-search-–±–∏–Ω–∞—Ä–Ω—ã–π-–ø–æ–∏—Å–∫)
  - *–ü—Ä–∏—á–∏–Ω–∞:* –§—É–Ω–¥–∞–º–µ–Ω—Ç–∞–ª—å–Ω—ã–π –∞–ª–≥–æ—Ä–∏—Ç–º, –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –∑–Ω–∞–Ω–∏–µ –±–∞–∑–æ–≤—ã—Ö —Ç–µ—Ö–Ω–∏–∫ –ø–æ–∏—Å–∫–∞.
- [**–ó–∞–¥–∞—á–∞ 12 - Linked List Cycle (–¶–∏–∫–ª –≤ —Å–≤—è–∑–∞–Ω–Ω–æ–º —Å–ø–∏—Å–∫–µ)**](#–∑–∞–¥–∞—á–∞-12---linked-list-cycle-—Ü–∏–∫–ª-–≤-—Å–≤—è–∑–∞–Ω–Ω–æ–º-—Å–ø–∏—Å–∫–µ)
  - *–ü—Ä–∏—á–∏–Ω–∞:* –ö–ª–∞—Å—Å–∏—á–µ—Å–∫–∞—è –∑–∞–¥–∞—á–∞ –Ω–∞ –¥–≤–∞ —É–∫–∞–∑–∞—Ç–µ–ª—è (—á–µ—Ä–µ–ø–∞—Ö–∞ –∏ –∑–∞—è—Ü).
- [**–ó–∞–¥–∞—á–∞ 13 - Reverse String/Array (–û–±—Ä–∞—Ç–∏—Ç—å —Å—Ç—Ä–æ–∫—É/–º–∞—Å—Å–∏–≤)**](#–∑–∞–¥–∞—á–∞-13---reverse-stringarray-–æ–±—Ä–∞—Ç–∏—Ç—å-—Å—Ç—Ä–æ–∫—É–º–∞—Å—Å–∏–≤)
  - *–ü—Ä–∏—á–∏–Ω–∞:* –ë–∞–∑–æ–≤–∞—è –º–∞–Ω–∏–ø—É–ª—è—Ü–∏—è –¥–∞–Ω–Ω—ã–º–∏.
- [**–ó–∞–¥–∞—á–∞ 15 - BFS/DFS Implementation (–†–µ–∞–ª–∏–∑–∞—Ü–∏—è BFS/DFS)**](#–∑–∞–¥–∞—á–∞-15---bfsdfs-implementation-—Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è-bfsdfs)
  - *–ü—Ä–∏—á–∏–Ω–∞:* –§—É–Ω–¥–∞–º–µ–Ω—Ç–∞–ª—å–Ω—ã–µ –∞–ª–≥–æ—Ä–∏—Ç–º—ã –æ–±—Ö–æ–¥–∞ –≥—Ä–∞—Ñ–æ–≤/–¥–µ—Ä–µ–≤—å–µ–≤. –í–∞–∂–Ω—ã –¥–ª—è –ø–æ–Ω–∏–º–∞–Ω–∏—è —Å–º–µ–∂–Ω—ã—Ö –∑–∞–¥–∞—á.
- [**–ó–∞–¥–∞—á–∞ 16 - Stack Implementation (–†–µ–∞–ª–∏–∑–∞—Ü–∏—è —Å—Ç–µ–∫–∞)**](#–∑–∞–¥–∞—á–∞-16---stack-implementation-—Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è-—Å—Ç–µ–∫–∞)
  - *–ü—Ä–∏—á–∏–Ω–∞:* –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–Ω–∏–º–∞–Ω–∏—è –±–∞–∑–æ–≤—ã—Ö —Å—Ç—Ä—É–∫—Ç—É—Ä –¥–∞–Ω–Ω—ã—Ö –∏ –∏—Ö —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –Ω–∞ —Å—Ä–µ–∑–∞—Ö Go.
- [**–ó–∞–¥–∞—á–∞ 19 - Queue with Channels (–û—á–µ—Ä–µ–¥—å —Å –∫–∞–Ω–∞–ª–∞–º–∏)**](#–∑–∞–¥–∞—á–∞-19---queue-with-channels-–æ—á–µ—Ä–µ–¥—å-—Å-–∫–∞–Ω–∞–ª–∞–º–∏)
  - *–ü—Ä–∏—á–∏–Ω–∞:* –ü–æ–Ω–∏–º–∞–Ω–∏–µ, –∫–∞–∫ –∫–∞–Ω–∞–ª—ã –º–æ–≥—É—Ç –∏–º–∏—Ç–∏—Ä–æ–≤–∞—Ç—å –æ—á–µ—Ä–µ–¥–∏, –∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –±—É—Ñ–µ—Ä–∏–∑–æ–≤–∞–Ω–Ω—ã—Ö –∫–∞–Ω–∞–ª–æ–≤.
- [**–ó–∞–¥–∞—á–∞ 20 - Min Stack (–ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —Å—Ç–µ–∫)**](#–∑–∞–¥–∞—á–∞-20---min-stack-–º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π-—Å—Ç–µ–∫)
  - *–ü—Ä–∏—á–∏–Ω–∞:* –ö–ª–∞—Å—Å–∏—á–µ—Å–∫–∞—è –º–æ–¥–∏—Ñ–∏–∫–∞—Ü–∏—è —Å—Ç–µ–∫–∞, —Ç—Ä–µ–±—É–µ—Ç –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–π –ª–æ–≥–∏–∫–∏.

### **–ö–∞—Ç–µ–≥–æ—Ä–∏—è: –ò–Ω–æ–≥–¥–∞ (–º–æ–≥—É—Ç –≤—Å—Ç—Ä–µ—Ç–∏—Ç—å—Å—è, –æ—Å–æ–±–µ–Ω–Ω–æ –Ω–∞ –±–æ–ª–µ–µ –ø—Ä–æ–¥–≤–∏–Ω—É—Ç—ã—Ö –ø–æ–∑–∏—Ü–∏—è—Ö)** ‚≠ê‚≠ê‚≠ê

- **–ó–∞–¥–∞—á–∞ 23 - Fan-In/Fan-Out Pattern (–ü–∞—Ç—Ç–µ—Ä–Ω –í–µ–µ—Ä-–í–Ω—É—Ç—Ä—å/–í–µ–µ—Ä-–ù–∞—Ä—É–∂—É)**
  - *–ü—Ä–∏—á–∏–Ω–∞:* –†–∞—Å—à–∏—Ä–µ–Ω–∏–µ –∑–Ω–∞–Ω–∏–π –æ –ø–∞—Ç—Ç–µ—Ä–Ω–∞—Ö –∫–æ–Ω–∫—É—Ä–µ–Ω—Ç–Ω–æ—Å—Ç–∏ –≤ Go.
- **–ó–∞–¥–∞—á–∞ 25 - Semaphore Implementation (–†–µ–∞–ª–∏–∑–∞—Ü–∏—è —Å–µ–º–∞—Ñ–æ—Ä–∞)**
  - *–ü—Ä–∏—á–∏–Ω–∞:* –ü–æ–Ω–∏–º–∞–Ω–∏–µ –Ω–∏–∑–∫–æ—É—Ä–æ–≤–Ω–µ–≤—ã—Ö –º–µ—Ö–∞–Ω–∏–∑–º–æ–≤ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ —á–µ—Ä–µ–∑ –∫–∞–Ω–∞–ª—ã.
- **–ó–∞–¥–∞—á–∞ 8 - Kth Largest Element (K-–π –Ω–∞–∏–±–æ–ª—å—à–∏–π —ç–ª–µ–º–µ–Ω—Ç)**
  - *–ü—Ä–∏—á–∏–Ω–∞:* –ß–∞—Å—Ç–æ —Ä–µ—à–∞–µ—Ç—Å—è —á–µ—Ä–µ–∑ QuickSelect –∏–ª–∏ Min-Heap ‚Äì –ø—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–µ –º–µ—Ç–æ–¥—ã.
- **–ó–∞–¥–∞—á–∞ 11 - QuickSort Implementation (–†–µ–∞–ª–∏–∑–∞—Ü–∏—è –±—ã—Å—Ç—Ä–æ–π —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏)**
  - *–ü—Ä–∏—á–∏–Ω–∞:* –ö–ª–∞—Å—Å–∏–∫–∞, –Ω–æ –Ω–∞ Go —á–∞—â–µ –ø—Ä–æ—Å—è—Ç —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –ø—Ä–æ—Å—Ç—ã–µ –≤–µ—â–∏ –∏–ª–∏ –ø–æ–∫–∞–∑–∞—Ç—å –ø–æ–Ω–∏–º–∞–Ω–∏–µ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã—Ö –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤, –∞ –Ω–µ "—Å –Ω—É–ª—è".
- **–ó–∞–¥–∞—á–∞ 14 - Find Median (–ù–∞–π—Ç–∏ –º–µ–¥–∏–∞–Ω—É)**
  - *–ü—Ä–∏—á–∏–Ω–∞:* –°–≤—è–∑–∞–Ω–æ —Å K-—ã–º —ç–ª–µ–º–µ–Ω—Ç–æ–º.
- **–ó–∞–¥–∞—á–∞ 17 - Fibonacci Numbers (–ß–∏—Å–ª–∞ –§–∏–±–æ–Ω–∞—á—á–∏)**
  - *–ü—Ä–∏—á–∏–Ω–∞:* –ß–∞—Å—Ç–æ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–æ–Ω–∏–º–∞–Ω–∏—è —Ä–µ–∫—É—Ä—Å–∏–∏ –∏ –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–≥–æ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è/–º–µ–º–æ–∏–∑–∞—Ü–∏–∏.
- **–ó–∞–¥–∞—á–∞ 18 - Anagram Groups (–ì—Ä—É–ø–ø—ã –∞–Ω–∞–≥—Ä–∞–º–º)**
  - *–ü—Ä–∏—á–∏–Ω–∞:* –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –º–∞–ø –∏ —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏ —Å—Ç—Ä–æ–∫.
- **–ó–∞–¥–∞—á–∞ 26 - Count Set Bits (–ü–æ–¥—Å—á–µ—Ç —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—ã—Ö –±–∏—Ç–æ–≤)**
  - *–ü—Ä–∏—á–∏–Ω–∞:* –ë–∏—Ç–æ–≤—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ –≤—Å—Ç—Ä–µ—á–∞—é—Ç—Å—è —Ä–µ–∂–µ, –Ω–æ –≤–∞–∂–Ω—ã –¥–ª—è –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö –æ–±–ª–∞—Å—Ç–µ–π.
- **–ó–∞–¥–∞—á–∞ 27 - Single Number (–ï–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω–æ–µ —á–∏—Å–ª–æ)**
  - *–ü—Ä–∏—á–∏–Ω–∞:* –•–æ—Ä–æ—à–∞—è –∑–∞–¥–∞—á–∞ –Ω–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ XOR.
- **–ó–∞–¥–∞—á–∞ 30 - LRU Cache (LRU –∫–µ—à)**
  - *–ü—Ä–∏—á–∏–Ω–∞:* –ö–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–∞–Ω–Ω—ã—Ö (HashMap + Doubly Linked List), —Å–ª–æ–∂–Ω–µ–µ, –Ω–æ –æ—á–µ–Ω—å –ø–æ–∫–∞–∑–∞—Ç–µ–ª—å–Ω–∞—è.

### **–ö–∞—Ç–µ–≥–æ—Ä–∏—è: –†–µ–¥–∫–æ (—Å–∫–æ—Ä–µ–µ –Ω–∞ —Å–ø–µ—Ü–∏—Ñ–∏—á–µ—Å–∫–∏—Ö –∏–ª–∏ –æ—á–µ–Ω—å —Å–ª–æ–∂–Ω—ã—Ö —Å–æ–±–µ—Å–µ–¥–æ–≤–∞–Ω–∏—è—Ö)** ‚≠ê‚≠ê

- **–ó–∞–¥–∞—á–∞ 10 - Greatest Common Divisor (–ù–∞–∏–±–æ–ª—å—à–∏–π –æ–±—â–∏–π –¥–µ–ª–∏—Ç–µ–ª—å)**
  - *–ü—Ä–∏—á–∏–Ω–∞:* –ú–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –∑–∞–¥–∞—á–∞, —Ä–µ–¥–∫–æ –≤—Å—Ç—Ä–µ—á–∞–µ—Ç—Å—è, –µ—Å–ª–∏ –ø–æ–∑–∏—Ü–∏—è –Ω–µ —Å–≤—è–∑–∞–Ω–∞ —Å –∫—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏–µ–π/—á–∏—Å–ª–æ–≤–æ–π —Ç–µ–æ—Ä–∏–µ–π.
- **–ó–∞–¥–∞—á–∞ 28 - Power of Two (–°—Ç–µ–ø–µ–Ω—å –¥–≤–æ–π–∫–∏)**
  - *–ü—Ä–∏—á–∏–Ω–∞:* –ß–∏—Å—Ç–æ –±–∏—Ç–æ–≤–∞—è –∑–∞–¥–∞—á–∞.
- **–ó–∞–¥–∞—á–∞ 29 - Bit Mask Subsets (–ü–æ–¥–º–Ω–æ–∂–µ—Å—Ç–≤–∞ —Å –±–∏—Ç–æ–≤—ã–º–∏ –º–∞—Å–∫–∞–º–∏)**
  - *–ü—Ä–∏—á–∏–Ω–∞:* –ü—Ä–æ–¥–≤–∏–Ω—É—Ç–æ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –±–∏—Ç–æ–≤—ã—Ö –º–∞—Å–æ–∫, —á–∞—â–µ –¥–ª—è –æ–ª–∏–º–ø–∏–∞–¥–Ω–æ–≥–æ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è.
- **–ó–∞–¥–∞—á–∞ 31 - Doubly Linked List (–î–≤—É—Å–≤—è–∑–Ω—ã–π —Å–ø–∏—Å–æ–∫)**
  - *–ü—Ä–∏—á–∏–Ω–∞:* –°–∞–º–æ—Å—Ç–æ—è—Ç–µ–ª—å–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è —á–∏—Å—Ç–æ–≥–æ –¥–≤—É—Å–≤—è–∑–Ω–æ–≥–æ —Å–ø–∏—Å–∫–∞ –±–µ–∑ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ LRU –∏–ª–∏ —á–µ–≥–æ-—Ç–æ –ø–æ–¥–æ–±–Ω–æ–≥–æ - —Ä–µ–¥–∫–æ—Å—Ç—å.
- **–ó–∞–¥–∞—á–∞ 32 - Trie (Prefix Tree) (–ü—Ä–µ—Ñ–∏–∫—Å–Ω–æ–µ –¥–µ—Ä–µ–≤–æ)**
  - *–ü—Ä–∏—á–∏–Ω–∞:* –ù–∏—à–µ–≤–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–∞–Ω–Ω—ã—Ö, –µ—Å–ª–∏ —Ç–æ–ª—å–∫–æ —ç—Ç–æ –Ω–µ –≤–∞–∫–∞–Ω—Å–∏—è, —Å–≤—è–∑–∞–Ω–Ω–∞—è —Å –ø–æ–∏—Å–∫–æ–º/–∞–≤—Ç–æ–¥–æ–ø–æ–ª–Ω–µ–Ω–∏–µ–º.
- **–ó–∞–¥–∞—á–∞ 33 - Hash Table from Scratch (–•–µ—à-—Ç–∞–±–ª–∏—Ü–∞ —Å –Ω—É–ª—è)**
  - *–ü—Ä–∏—á–∏–Ω–∞:* –ö—Ä–∞–π–Ω–µ —Ä–µ–¥–∫–æ –ø—Ä–æ—Å—è—Ç —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å —Å –Ω—É–ª—è, —á–∞—â–µ —Å–ø—Ä–∞—à–∏–≤–∞—é—Ç –æ –ø—Ä–∏–Ω—Ü–∏–ø–∞—Ö —Ä–∞–±–æ—Ç—ã –∏ –∫–æ–ª–ª–∏–∑–∏—è—Ö.
- **–ó–∞–¥–∞—á–∞ 34 - Knapsack Problem (–ó–∞–¥–∞—á–∞ –æ —Ä—é–∫–∑–∞–∫–µ)**
  - *–ü—Ä–∏—á–∏–Ω–∞:* –ö–ª–∞—Å—Å–∏–∫–∞ DP, –Ω–æ —Ä–µ–¥–∫–æ –≤—Å—Ç—Ä–µ—á–∞–µ—Ç—Å—è –Ω–∞ –ø—Ä–∞–∫—Ç–∏–∫–µ, –µ—Å–ª–∏ —Ç–æ–ª—å–∫–æ —ç—Ç–æ –Ω–µ —Å–ø–µ—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –Ω–∞ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏.
- **–ó–∞–¥–∞—á–∞ 35 - Longest Common Subsequence (–ù–∞–∏–±–æ–ª—å—à–∞—è –æ–±—â–∞—è –ø–æ–¥–ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å)**
  - *–ü—Ä–∏—á–∏–Ω–∞:* –ï—â–µ –æ–¥–Ω–∞ –∫–ª–∞—Å—Å–∏–∫–∞ DP, –Ω–æ –¥–æ–≤–æ–ª—å–Ω–æ —Å–ª–æ–∂–Ω–∞—è –¥–ª—è –æ–±—ã—á–Ω–æ–≥–æ —Å–æ–±–µ—Å–µ–¥–æ–≤–∞–Ω–∏—è.
- [**–ó–∞–¥–∞—á–∞ 36 - Coin Change (–†–∞–∑–º–µ–Ω –º–æ–Ω–µ—Ç)**](#–∑–∞–¥–∞—á–∞-36---coin-change-—Ä–∞–∑–º–µ–Ω-–º–æ–Ω–µ—Ç)
  - *–ü—Ä–∏—á–∏–Ω–∞:* –ó–∞–¥–∞—á–∞ –Ω–∞ DP, –≤—Å—Ç—Ä–µ—á–∞–µ—Ç—Å—è —Ä–µ–∂–µ.
- **–ó–∞–¥–∞—á–∞ 37 - House Robber (–ì—Ä–∞–±–∏—Ç–µ–ª—å –¥–æ–º–æ–≤)**
  - *–ü—Ä–∏—á–∏–Ω–∞:* –ë–æ–ª–µ–µ –ø—Ä–æ—Å—Ç–æ–π –≤–∞—Ä–∏–∞–Ω—Ç DP, –∏–Ω–æ–≥–¥–∞ –≤—Å—Ç—Ä–µ—á–∞–µ—Ç—Å—è.
- **–ó–∞–¥–∞—á–∞ 38 - Balanced Binary Tree (–°–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –±–∏–Ω–∞—Ä–Ω–æ–µ –¥–µ—Ä–µ–≤–æ)**
  - *–ü—Ä–∏—á–∏–Ω–∞:* –ü—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–µ –¥–µ—Ä–µ–≤—å—è, –º–æ–≥—É—Ç –±—ã—Ç—å –Ω–∞ –ø–æ–∑–∏—Ü–∏—è—Ö, —Å–≤—è–∑–∞–Ω–Ω—ã—Ö —Å –±–∞–∑–∞–º–∏ –¥–∞–Ω–Ω—ã—Ö –∏–ª–∏ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–º–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞–º–∏.
- **–ó–∞–¥–∞—á–∞ 39 - Graph Cycle Detection (–û–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ —Ü–∏–∫–ª–æ–≤ –≤ –≥—Ä–∞—Ñ–µ)**
  - *–ü—Ä–∏—á–∏–Ω–∞:* –ì—Ä–∞—Ñ—ã –º–æ–≥—É—Ç –±—ã—Ç—å, –Ω–æ —Ü–∏–∫–ª—ã - —É–∂–µ –±–æ–ª–µ–µ —Å–ø–µ—Ü–∏—Ñ–∏—á–Ω–æ.
- **–ó–∞–¥–∞—á–∞ 40 - Shortest Path (Dijkstra) (–ö—Ä–∞—Ç—á–∞–π—à–∏–π –ø—É—Ç—å - –î–µ–π–∫—Å—Ç—Ä–∞)**
  - *–ü—Ä–∏—á–∏–Ω–∞:* –û—á–µ–Ω—å —Å–ª–æ–∂–Ω–∞—è –∑–∞–¥–∞—á–∞ –¥–ª—è –æ–±—ã—á–Ω–æ–≥–æ —Å–æ–±–µ—Å–µ–¥–æ–≤–∞–Ω–∏—è, —Å–∫–æ—Ä–µ–µ –¥–ª—è —Å–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –ø–æ–∑–∏—Ü–∏–π, —Å–≤—è–∑–∞–Ω–Ω—ã—Ö —Å –≥—Ä–∞—Ñ–æ–≤—ã–º–∏ –∞–ª–≥–æ—Ä–∏—Ç–º–∞–º–∏.

## üéØ –ü–æ–¥—Å–∫–∞–∑–∫–∏ –¥–ª—è –æ—Å–Ω–æ–≤–Ω—ã—Ö –∑–∞–¥–∞—á

### **–ó–∞–¥–∞—á–∞ 1 - Two Sum (–°—É–º–º–∞ –¥–≤—É—Ö)**

–í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –≤—Å—Ç—Ä–µ—Å—Ç–∏—Ç—å: ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê (–æ—á–µ–Ω—å —á–∞—Å—Ç–æ)

**üîß –ü–æ–¥—Ö–æ–¥:** HashMap –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –∑–Ω–∞—á–µ–Ω–∏–π –∏ –∏–Ω–¥–µ–∫—Å–æ–≤  
**‚ö° –°–ª–æ–∂–Ω–æ—Å—Ç—å:** O(n) –≤—Ä–µ–º—è, O(n) –ø–∞–º—è—Ç—å  
**üí° –ü–æ–¥—Å–∫–∞–∑–∫–∞:** –ü—Ä–æ—Ö–æ–¥–∏–º –º–∞—Å—Å–∏–≤ –æ–¥–∏–Ω —Ä–∞–∑, –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞ –∏—â–µ–º `target - current` –≤ map  
**üîë –ö–ª—é—á–µ–≤—ã–µ –º–æ–º–µ–Ω—Ç—ã:** –ü—Ä–æ–≤–µ—Ä—è–µ–º map –ø–µ—Ä–µ–¥ –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ–º —Ç–µ–∫—É—â–µ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞

[–†–µ—à–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏ 1](#—Ä–µ—à–µ–Ω–∏–µ-–∑–∞–¥–∞—á–∏-1)

### **–ó–∞–¥–∞—á–∞ 2 - Reverse Linked List (–û–±—Ä–∞—Ç–∏—Ç—å —Å–≤—è–∑–∞–Ω–Ω—ã–π —Å–ø–∏—Å–æ–∫)**

–í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –≤—Å—Ç—Ä–µ—Å—Ç–∏—Ç—å: ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê (–æ—á–µ–Ω—å —á–∞—Å—Ç–æ)

**üîß –ü–æ–¥—Ö–æ–¥:** –ò—Ç–µ—Ä–∞—Ç–∏–≤–Ω–æ –º–µ–Ω—è–µ–º —É–∫–∞–∑–∞—Ç–µ–ª–∏ –∏–ª–∏ —Ä–µ–∫—É—Ä—Å–∏—è  
**‚ö° –°–ª–æ–∂–Ω–æ—Å—Ç—å:** O(n) –≤—Ä–µ–º—è, O(1) –ø–∞–º—è—Ç—å (–∏—Ç–µ—Ä–∞—Ç–∏–≤–Ω–æ)  
**üí° –ü–æ–¥—Å–∫–∞–∑–∫–∞:** –¢—Ä–∏ —É–∫–∞–∑–∞—Ç–µ–ª—è: prev, current, next  
**üîë –ö–ª—é—á–µ–≤—ã–µ –º–æ–º–µ–Ω—Ç—ã:** –°–æ—Ö—Ä–∞–Ω—è–µ–º next –ø–µ—Ä–µ–¥ –∏–∑–º–µ–Ω–µ–Ω–∏–µ–º current.Next

[–†–µ—à–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏ 2](#—Ä–µ—à–µ–Ω–∏–µ-–∑–∞–¥–∞—á–∏-2)

### **–ó–∞–¥–∞—á–∞ 3 - Valid Palindrome (–ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–∞–ª–∏–Ω–¥—Ä–æ–º–∞)**

–í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –≤—Å—Ç—Ä–µ—Å—Ç–∏—Ç—å: ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê (–æ—á–µ–Ω—å —á–∞—Å—Ç–æ)

**üîß –ü–æ–¥—Ö–æ–¥:** Two pointers —Å –∫–æ–Ω—Ü–æ–≤ —Å—Ç—Ä–æ–∫–∏  
**‚ö° –°–ª–æ–∂–Ω–æ—Å—Ç—å:** O(n) –≤—Ä–µ–º—è, O(1) –ø–∞–º—è—Ç—å  
**üí° –ü–æ–¥—Å–∫–∞–∑–∫–∞:** –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è —Å–∏–º–≤–æ–ª–æ–≤ + —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ —Å –¥–≤—É—Ö –∫–æ–Ω—Ü–æ–≤  
**üîë –ö–ª—é—á–µ–≤—ã–µ –º–æ–º–µ–Ω—Ç—ã:** –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –Ω–µ-–±—É–∫–≤–µ–Ω–Ω–æ-—Ü–∏—Ñ—Ä–æ–≤—ã–µ —Å–∏–º–≤–æ–ª—ã

[–†–µ—à–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏ 3](#—Ä–µ—à–µ–Ω–∏–µ-–∑–∞–¥–∞—á–∏-3)

### **–ó–∞–¥–∞—á–∞ 4 - Longest Substring Without Repeating (–°–∞–º–∞—è –¥–ª–∏–Ω–Ω–∞—è –ø–æ–¥—Å—Ç—Ä–æ–∫–∞ –±–µ–∑ –ø–æ–≤—Ç–æ—Ä–µ–Ω–∏–π)**

–í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –≤—Å—Ç—Ä–µ—Å—Ç–∏—Ç—å: ‚≠ê‚≠ê‚≠ê‚≠ê (—á–∞—Å—Ç–æ)

**üîß –ü–æ–¥—Ö–æ–¥:** Sliding window + HashMap  
**‚ö° –°–ª–æ–∂–Ω–æ—Å—Ç—å:** O(n) –≤—Ä–µ–º—è, O(k) –ø–∞–º—è—Ç—å (k - —Ä–∞–∑–º–µ—Ä –∞–ª—Ñ–∞–≤–∏—Ç–∞)  
**üí° –ü–æ–¥—Å–∫–∞–∑–∫–∞:** –†–∞—Å—à–∏—Ä—è–µ–º –æ–∫–Ω–æ –≤–ø—Ä–∞–≤–æ, —Å–∂–∏–º–∞–µ–º –≤–ª–µ–≤–æ –ø—Ä–∏ –¥—É–±–ª–∏–∫–∞—Ç–∞—Ö  
**üîë –ö–ª—é—á–µ–≤—ã–µ –º–æ–º–µ–Ω—Ç—ã:** –û–±–Ω–æ–≤–ª—è–µ–º –ª–µ–≤—É—é –≥—Ä–∞–Ω–∏—Ü—É —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –¥—É–±–ª–∏–∫–∞—Ç –≤ —Ç–µ–∫—É—â–µ–º –æ–∫–Ω–µ

[–†–µ—à–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏ 4](#—Ä–µ—à–µ–Ω–∏–µ-–∑–∞–¥–∞—á–∏-4)

### **–ó–∞–¥–∞—á–∞ 5 - Merge Two Sorted Arrays (–û–±—ä–µ–¥–∏–Ω–∏—Ç—å –¥–≤–∞ –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –º–∞—Å—Å–∏–≤–∞)**

–í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –≤—Å—Ç—Ä–µ—Å—Ç–∏—Ç—å: ‚≠ê‚≠ê‚≠ê‚≠ê (—á–∞—Å—Ç–æ)

**üîß –ü–æ–¥—Ö–æ–¥:** Two pointers –Ω–∞ –æ–±–∞ –º–∞—Å—Å–∏–≤–∞  
**‚ö° –°–ª–æ–∂–Ω–æ—Å—Ç—å:** O(n+m) –≤—Ä–µ–º—è, O(1) –ø–∞–º—è—Ç—å  
**üí° –ü–æ–¥—Å–∫–∞–∑–∫–∞:** –ó–∞–ø–æ–ª–Ω—è–µ–º —Å –∫–æ–Ω—Ü–∞, —á—Ç–æ–±—ã –Ω–µ –ø–µ—Ä–µ–∑–∞–ø–∏—Å–∞—Ç—å –¥–∞–Ω–Ω—ã–µ  
**üîë –ö–ª—é—á–µ–≤—ã–µ –º–æ–º–µ–Ω—Ç—ã:** –¢—Ä–∏ —É–∫–∞–∑–∞—Ç–µ–ª—è: i, j, k (–ø–æ–∑–∏—Ü–∏–∏ –≤ nums1, nums2, —Ä–µ–∑—É–ª—å—Ç–∞—Ç)

[–†–µ—à–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏ 5](#—Ä–µ—à–µ–Ω–∏–µ-–∑–∞–¥–∞—á–∏-5)

### **–ó–∞–¥–∞—á–∞ 6 - Intersection of Two Arrays (–ü–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ –¥–≤—É—Ö –º–∞—Å—Å–∏–≤–æ–≤)**

**üîß –ü–æ–¥—Ö–æ–¥:** HashMap –∏–ª–∏ Set –¥–ª—è –ø–æ–¥—Å—á–µ—Ç–∞  
**‚ö° –°–ª–æ–∂–Ω–æ—Å—Ç—å:** O(n+m) –≤—Ä–µ–º—è, O(min(n,m)) –ø–∞–º—è—Ç—å  
**üí° –ü–æ–¥—Å–∫–∞–∑–∫–∞:** –ú–µ–Ω—å—à–∏–π –º–∞—Å—Å–∏–≤ –≤ map, –ø—Ä–æ—Ö–æ–¥–∏–º –ø–æ –±–æ–ª—å—à–µ–º—É  
**üîë –ö–ª—é—á–µ–≤—ã–µ –º–æ–º–µ–Ω—Ç—ã:** –£—á–∏—Ç—ã–≤–∞—Ç—å –¥—É–±–ª–∏–∫–∞—Ç—ã –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —É—Å–ª–æ–≤–∏—è

[–†–µ—à–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏ 6](#—Ä–µ—à–µ–Ω–∏–µ-–∑–∞–¥–∞—á–∏-6)

### **–ó–∞–¥–∞—á–∞ 7 - Binary Search (–ë–∏–Ω–∞—Ä–Ω—ã–π –ø–æ–∏—Å–∫)**

–í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –≤—Å—Ç—Ä–µ—Å—Ç–∏—Ç—å: ‚≠ê‚≠ê‚≠ê‚≠ê (—á–∞—Å—Ç–æ)

**üîß –ü–æ–¥—Ö–æ–¥:** –î–µ–ª–µ–Ω–∏–µ –ø–æ–ø–æ–ª–∞–º —Å —É—Å–ª–æ–≤–∏–µ–º  
**‚ö° –°–ª–æ–∂–Ω–æ—Å—Ç—å:** O(log n) –≤—Ä–µ–º—è, O(1) –ø–∞–º—è—Ç—å  
**üí° –ü–æ–¥—Å–∫–∞–∑–∫–∞:** `left + (right - left) / 2` –∏–∑–±–µ–≥–∞–µ—Ç –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏—è  
**üîë –ö–ª—é—á–µ–≤—ã–µ –º–æ–º–µ–Ω—Ç—ã:** –ö–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –≥—Ä–∞–Ω–∏—Ü left <= right

[–†–µ—à–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏ 7](#—Ä–µ—à–µ–Ω–∏–µ-–∑–∞–¥–∞—á–∏-7)

### **–ó–∞–¥–∞—á–∞ 8 - Kth Largest Element (K-–π –Ω–∞–∏–±–æ–ª—å—à–∏–π —ç–ª–µ–º–µ–Ω—Ç)**

–í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –≤—Å—Ç—Ä–µ—Å—Ç–∏—Ç—å: ‚≠ê‚≠ê‚≠ê (–∏–Ω–æ–≥–¥–∞)

**üîß –ü–æ–¥—Ö–æ–¥:** QuickSelect –∏–ª–∏ Min-Heap —Ä–∞–∑–º–µ—Ä–∞ k  
**‚ö° –°–ª–æ–∂–Ω–æ—Å—Ç—å:** O(n) —Å—Ä–µ–¥–Ω–µ–µ, O(n¬≤) —Ö—É–¥—à–∏–π / O(n log k) heap  
**üí° –ü–æ–¥—Å–∫–∞–∑–∫–∞:** Partitioning –∫–∞–∫ –≤ QuickSort, –Ω–æ —Ç–æ–ª—å–∫–æ –æ–¥–Ω–∞ —Å—Ç–æ—Ä–æ–Ω–∞  
**üîë –ö–ª—é—á–µ–≤—ã–µ –º–æ–º–µ–Ω—Ç—ã:** –†–∞–Ω–¥–æ–º–∏–∑–∞—Ü–∏—è pivot –¥–ª—è –ª—É—á—à–µ–π –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏

[–†–µ—à–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏ 8](#—Ä–µ—à–µ–Ω–∏–µ-–∑–∞–¥–∞—á–∏-8)

### **–ó–∞–¥–∞—á–∞ 9 - Valid Parentheses (–ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–∫–æ–±–æ–∫)**

–í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –≤—Å—Ç—Ä–µ—Å—Ç–∏—Ç—å: ‚≠ê‚≠ê‚≠ê‚≠ê (—á–∞—Å—Ç–æ)

**üîß –ü–æ–¥—Ö–æ–¥:** Stack –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –æ—Ç–∫—Ä—ã–≤–∞—é—â–∏—Ö —Å–∫–æ–±–æ–∫  
**‚ö° –°–ª–æ–∂–Ω–æ—Å—Ç—å:** O(n) –≤—Ä–µ–º—è, O(n) –ø–∞–º—è—Ç—å  
**üí° –ü–æ–¥—Å–∫–∞–∑–∫–∞:** Push –æ—Ç–∫—Ä—ã–≤–∞—é—â–∏–µ, pop –ø—Ä–∏ –∑–∞–∫—Ä—ã–≤–∞—é—â–∏—Ö  
**üîë –ö–ª—é—á–µ–≤—ã–µ –º–æ–º–µ–Ω—Ç—ã:** –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏—è —Ç–∏–ø–æ–≤ —Å–∫–æ–±–æ–∫ –ø—Ä–∏ pop

[–†–µ—à–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏ 9](#—Ä–µ—à–µ–Ω–∏–µ-–∑–∞–¥–∞—á–∏-9)

### **–ó–∞–¥–∞—á–∞ 10 - Greatest Common Divisor (–ù–∞–∏–±–æ–ª—å—à–∏–π –æ–±—â–∏–π –¥–µ–ª–∏—Ç–µ–ª—å)**

–í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –≤—Å—Ç—Ä–µ—Å—Ç–∏—Ç—å: ‚≠ê‚≠ê (—Ä–µ–¥–∫–æ)

**üîß –ü–æ–¥—Ö–æ–¥:** –ê–ª–≥–æ—Ä–∏—Ç–º –ï–≤–∫–ª–∏–¥–∞  
**‚ö° –°–ª–æ–∂–Ω–æ—Å—Ç—å:** O(log min(a,b)) –≤—Ä–µ–º—è, O(1) –ø–∞–º—è—Ç—å  
**üí° –ü–æ–¥—Å–∫–∞–∑–∫–∞:** `gcd(a,b) = gcd(b, a%b)` –ø–æ–∫–∞ b ‚â† 0  
**üîë –ö–ª—é—á–µ–≤—ã–µ –º–æ–º–µ–Ω—Ç—ã:** –ë–∞–∑–æ–≤—ã–π —Å–ª—É—á–∞–π: gcd(a, 0) = a

[–†–µ—à–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏ 10](#—Ä–µ—à–µ–Ω–∏–µ-–∑–∞–¥–∞—á–∏-10)

### **–ó–∞–¥–∞—á–∞ 11 - QuickSort Implementation (–†–µ–∞–ª–∏–∑–∞—Ü–∏—è –±—ã—Å—Ç—Ä–æ–π —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏)**

–í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –≤—Å—Ç—Ä–µ—Å—Ç–∏—Ç—å: ‚≠ê‚≠ê‚≠ê (–∏–Ω–æ–≥–¥–∞)

**üîß –ü–æ–¥—Ö–æ–¥:** –†–∞–∑–¥–µ–ª—è–π –∏ –≤–ª–∞—Å—Ç–≤—É–π —Å pivot  
**‚ö° –°–ª–æ–∂–Ω–æ—Å—Ç—å:** O(n log n) —Å—Ä–µ–¥–Ω–µ–µ, O(n¬≤) —Ö—É–¥—à–∏–π  
**üí° –ü–æ–¥—Å–∫–∞–∑–∫–∞:** Partition + —Ä–µ–∫—É—Ä—Å–∏–≤–Ω–æ —Å–æ—Ä—Ç–∏—Ä—É–µ–º —á–∞—Å—Ç–∏  
**üîë –ö–ª—é—á–µ–≤—ã–µ –º–æ–º–µ–Ω—Ç—ã:** Lomuto –∏–ª–∏ Hoare partitioning —Å—Ö–µ–º—ã

[–†–µ—à–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏ 11](#—Ä–µ—à–µ–Ω–∏–µ-–∑–∞–¥–∞—á–∏-11)

### **–ó–∞–¥–∞—á–∞ 12 - Linked List Cycle (–¶–∏–∫–ª –≤ —Å–≤—è–∑–∞–Ω–Ω–æ–º —Å–ø–∏—Å–∫–µ)**

–í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –≤—Å—Ç—Ä–µ—Å—Ç–∏—Ç—å: ‚≠ê‚≠ê‚≠ê‚≠ê (—á–∞—Å—Ç–æ)

**üîß –ü–æ–¥—Ö–æ–¥:** Floyd's Cycle Detection (—á–µ—Ä–µ–ø–∞—Ö–∞ –∏ –∑–∞—è—Ü)  
**‚ö° –°–ª–æ–∂–Ω–æ—Å—Ç—å:** O(n) –≤—Ä–µ–º—è, O(1) –ø–∞–º—è—Ç—å  
**üí° –ü–æ–¥—Å–∫–∞–∑–∫–∞:** –î–≤–∞ —É–∫–∞–∑–∞—Ç–µ–ª—è —Ä–∞–∑–Ω–æ–π —Å–∫–æ—Ä–æ—Å—Ç–∏ –≤—Å—Ç—Ä–µ—Ç—è—Ç—Å—è –≤ —Ü–∏–∫–ª–µ  
**üîë –ö–ª—é—á–µ–≤—ã–µ –º–æ–º–µ–Ω—Ç—ã:** slow=slow.Next, fast=fast.Next.Next

[–†–µ—à–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏ 12](#—Ä–µ—à–µ–Ω–∏–µ-–∑–∞–¥–∞—á–∏-12)

### **–ó–∞–¥–∞—á–∞ 13 - Reverse String/Array (–û–±—Ä–∞—Ç–∏—Ç—å —Å—Ç—Ä–æ–∫—É/–º–∞—Å—Å–∏–≤)**

–í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –≤—Å—Ç—Ä–µ—Å—Ç–∏—Ç—å: ‚≠ê‚≠ê‚≠ê‚≠ê (—á–∞—Å—Ç–æ)

**üîß –ü–æ–¥—Ö–æ–¥:** Two pointers —Å –∫–æ–Ω—Ü–æ–≤  
**‚ö° –°–ª–æ–∂–Ω–æ—Å—Ç—å:** O(n) –≤—Ä–µ–º—è, O(1) –ø–∞–º—è—Ç—å  
**üí° –ü–æ–¥—Å–∫–∞–∑–∫–∞:** –ú–µ–Ω—è–µ–º –º–µ—Å—Ç–∞–º–∏ —ç–ª–µ–º–µ–Ω—Ç—ã —Å –Ω–∞—á–∞–ª–∞ –∏ –∫–æ–Ω—Ü–∞  
**üîë –ö–ª—é—á–µ–≤—ã–µ –º–æ–º–µ–Ω—Ç—ã:** –£—Å–ª–æ–≤–∏–µ –æ—Å—Ç–∞–Ω–æ–≤–∫–∏: left < right

[–†–µ—à–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏ 13](#—Ä–µ—à–µ–Ω–∏–µ-–∑–∞–¥–∞—á–∏-13)

### **–ó–∞–¥–∞—á–∞ 14 - Find Median (–ù–∞–π—Ç–∏ –º–µ–¥–∏–∞–Ω—É)**

–í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –≤—Å—Ç—Ä–µ—Å—Ç–∏—Ç—å: ‚≠ê‚≠ê‚≠ê (–∏–Ω–æ–≥–¥–∞)

**üîß –ü–æ–¥—Ö–æ–¥:** –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –∏–ª–∏ QuickSelect  
**‚ö° –°–ª–æ–∂–Ω–æ—Å—Ç—å:** O(n log n) / O(n) —Å—Ä–µ–¥–Ω–µ–µ  
**üí° –ü–æ–¥—Å–∫–∞–∑–∫–∞:** –ú–µ–¥–∏–∞–Ω–∞ = —ç–ª–µ–º–µ–Ω—Ç(—ã) –≤ —Å–µ—Ä–µ–¥–∏–Ω–µ –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –º–∞—Å—Å–∏–≤–∞  
**üîë –ö–ª—é—á–µ–≤—ã–µ –º–æ–º–µ–Ω—Ç—ã:** –ß–µ—Ç–Ω–∞—è/–Ω–µ—á–µ—Ç–Ω–∞—è –¥–ª–∏–Ω–∞ –º–∞—Å—Å–∏–≤–∞

[–†–µ—à–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏ 14]

### **–ó–∞–¥–∞—á–∞ 15 - BFS/DFS Implementation (–†–µ–∞–ª–∏–∑–∞—Ü–∏—è BFS/DFS)**

–í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –≤—Å—Ç—Ä–µ—Å—Ç–∏—Ç—å: ‚≠ê‚≠ê‚≠ê‚≠ê (—á–∞—Å—Ç–æ)

**üîß –ü–æ–¥—Ö–æ–¥:** Queue –¥–ª—è BFS, Stack/—Ä–µ–∫—É—Ä—Å–∏—è –¥–ª—è DFS  
**‚ö° –°–ª–æ–∂–Ω–æ—Å—Ç—å:** O(V + E) –≤—Ä–µ–º—è, O(V) –ø–∞–º—è—Ç—å  
**üí° –ü–æ–¥—Å–∫–∞–∑–∫–∞:** BFS - –æ—á–µ—Ä–µ–¥—å + visited set, DFS - —Å—Ç–µ–∫ + visited set  
**üîë –ö–ª—é—á–µ–≤—ã–µ –º–æ–º–µ–Ω—Ç—ã:** –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏–µ –ø–æ–≤—Ç–æ—Ä–Ω–æ–≥–æ –ø–æ—Å–µ—â–µ–Ω–∏—è —É–∑–ª–æ–≤

[–†–µ—à–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏ 15](#—Ä–µ—à–µ–Ω–∏–µ-–∑–∞–¥–∞—á–∏-15)

### **–ó–∞–¥–∞—á–∞ 16 - Stack Implementation (–†–µ–∞–ª–∏–∑–∞—Ü–∏—è —Å—Ç–µ–∫–∞)**

–í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –≤—Å—Ç—Ä–µ—Å—Ç–∏—Ç—å: ‚≠ê‚≠ê‚≠ê‚≠ê (—á–∞—Å—Ç–æ)

**üîß –ü–æ–¥—Ö–æ–¥:** Slice –∫–∞–∫ –±–∞–∑–æ–≤–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞  
**‚ö° –°–ª–æ–∂–Ω–æ—Å—Ç—å:** O(1) –≤—Å–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ (–∞–º–æ—Ä—Ç–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ)  
**üí° –ü–æ–¥—Å–∫–∞–∑–∫–∞:** `append()` –¥–ª—è push, slice[:len-1] –¥–ª—è pop  
**üîë –ö–ª—é—á–µ–≤—ã–µ –º–æ–º–µ–Ω—Ç—ã:** –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø—É—Å—Ç–æ—Ç—É –ø–µ—Ä–µ–¥ pop

[–†–µ—à–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏ 16](#—Ä–µ—à–µ–Ω–∏–µ-–∑–∞–¥–∞—á–∏-16)

### **–ó–∞–¥–∞—á–∞ 17 - Fibonacci Numbers (–ß–∏—Å–ª–∞ –§–∏–±–æ–Ω–∞—á—á–∏)**

–í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –≤—Å—Ç—Ä–µ—Å—Ç–∏—Ç—å: ‚≠ê‚≠ê‚≠ê (–∏–Ω–æ–≥–¥–∞)

**üîß –ü–æ–¥—Ö–æ–¥:** DP —Å–Ω–∏–∑—É –≤–≤–µ—Ä—Ö –∏–ª–∏ –º–µ–º–æ–∏–∑–∞—Ü–∏—è  
**‚ö° –°–ª–æ–∂–Ω–æ—Å—Ç—å:** O(n) –≤—Ä–µ–º—è, O(1) –ø–∞–º—è—Ç—å (–∏—Ç–µ—Ä–∞—Ç–∏–≤–Ω–æ)  
**üí° –ü–æ–¥—Å–∫–∞–∑–∫–∞:** –•—Ä–∞–Ω–∏–º —Ç–æ–ª—å–∫–æ –¥–≤–∞ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö —á–∏—Å–ª–∞  
**üîë –ö–ª—é—á–µ–≤—ã–µ –º–æ–º–µ–Ω—Ç—ã:** a, b = b, a+b –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è

[–†–µ—à–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏ 17]

### **–ó–∞–¥–∞—á–∞ 18 - Anagram Groups (–ì—Ä—É–ø–ø—ã –∞–Ω–∞–≥—Ä–∞–º–º)**

–í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –≤—Å—Ç—Ä–µ—Å—Ç–∏—Ç—å: ‚≠ê‚≠ê‚≠ê (–∏–Ω–æ–≥–¥–∞)

**üîß –ü–æ–¥—Ö–æ–¥:** –ì—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞ –ø–æ –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–π —Å—Ç—Ä–æ–∫–µ  
**‚ö° –°–ª–æ–∂–Ω–æ—Å—Ç—å:** O(n * m log m) –≥–¥–µ m - –¥–ª–∏–Ω–∞ —Å—Ç—Ä–æ–∫–∏  
**üí° –ü–æ–¥—Å–∫–∞–∑–∫–∞:** Map[sorted_string][]string  
**üîë –ö–ª—é—á–µ–≤—ã–µ –º–æ–º–µ–Ω—Ç—ã:** –°–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —Å—Ç—Ä–æ–∫–∞ –∫–∞–∫ –∫–ª—é—á –≥—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∏

[–†–µ—à–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏ 18]

### **–ó–∞–¥–∞—á–∞ 19 - Queue with Channels (–û—á–µ—Ä–µ–¥—å —Å –∫–∞–Ω–∞–ª–∞–º–∏)**

–í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –≤—Å—Ç—Ä–µ—Å—Ç–∏—Ç—å: ‚≠ê‚≠ê‚≠ê‚≠ê (—á–∞—Å—Ç–æ)

**üîß –ü–æ–¥—Ö–æ–¥:** –ë—É—Ñ–µ—Ä–∏–∑–æ–≤–∞–Ω–Ω—ã–π –∫–∞–Ω–∞–ª  
**‚ö° –°–ª–æ–∂–Ω–æ—Å—Ç—å:** O(1) enqueue/dequeue  
**üí° –ü–æ–¥—Å–∫–∞–∑–∫–∞:** `make(chan T, capacity)` + select –¥–ª—è non-blocking  
**üîë –ö–ª—é—á–µ–≤—ã–µ –º–æ–º–µ–Ω—Ç—ã:** –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ select –¥–ª—è timeout –∏ default case

[–†–µ—à–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏ 19](#—Ä–µ—à–µ–Ω–∏–µ-–∑–∞–¥–∞—á–∏-18)

### **–ó–∞–¥–∞—á–∞ 20 - Min Stack (–ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —Å—Ç–µ–∫)**

–í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –≤—Å—Ç—Ä–µ—Å—Ç–∏—Ç—å: ‚≠ê‚≠ê‚≠ê‚≠ê (—á–∞—Å—Ç–æ)

**üîß –ü–æ–¥—Ö–æ–¥:** –î–≤–∞ —Å—Ç–µ–∫–∞ –∏–ª–∏ —Å—Ç–µ–∫ –ø–∞—Ä (value, min)  
**‚ö° –°–ª–æ–∂–Ω–æ—Å—Ç—å:** O(1) –≤—Å–µ –æ–ø–µ—Ä–∞—Ü–∏–∏  
**üí° –ü–æ–¥—Å–∫–∞–∑–∫–∞:** –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π —Å—Ç–µ–∫ –¥–ª—è –º–∏–Ω–∏–º—É–º–æ–≤ –Ω–∞ –∫–∞–∂–¥–æ–º —É—Ä–æ–≤–Ω–µ  
**üîë –ö–ª—é—á–µ–≤—ã–µ –º–æ–º–µ–Ω—Ç—ã:** –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –æ–ø–µ—Ä–∞—Ü–∏–π –Ω–∞ –æ–±–æ–∏—Ö —Å—Ç–µ–∫–∞—Ö

[–†–µ—à–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏ 20](#—Ä–µ—à–µ–Ω–∏–µ-–∑–∞–¥–∞—á–∏-20)

## üöÄ Concurrency –∏ –ø–∞—Ä–∞–ª–ª–µ–ª–∏–∑–º

### **–ó–∞–¥–∞—á–∞ 21 - Producer-Consumer Pattern (–ü–∞—Ç—Ç–µ—Ä–Ω –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å-–ü–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—å)**

–í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –≤—Å—Ç—Ä–µ—Å—Ç–∏—Ç—å: ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê (–æ—á–µ–Ω—å —á–∞—Å—Ç–æ)

**üîß –ü–æ–¥—Ö–æ–¥:** –ì–æ—Ä—É—Ç–∏–Ω—ã + –±—É—Ñ–µ—Ä–∏–∑–æ–≤–∞–Ω–Ω—ã–µ –∫–∞–Ω–∞–ª—ã  
**‚ö° –°–ª–æ–∂–Ω–æ—Å—Ç—å:** O(1) –æ–ø–µ—Ä–∞—Ü–∏–∏, O(n) –æ–±—Ä–∞–±–æ—Ç–∫–∞  
**üí° –ü–æ–¥—Å–∫–∞–∑–∫–∞:** Producer –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –≤ –∫–∞–Ω–∞–ª, Consumer —á–∏—Ç–∞–µ—Ç –∏–∑ –∫–∞–Ω–∞–ª–∞  
**üîë –ö–ª—é—á–µ–≤—ã–µ –º–æ–º–µ–Ω—Ç—ã:** –ö–æ–Ω—Ç—Ä–æ–ª—å —Ä–∞–∑–º–µ—Ä–∞ –±—É—Ñ–µ—Ä–∞, graceful shutdown

### **–ó–∞–¥–∞—á–∞ 22 - Worker Pool (–ü—É–ª –≤–æ—Ä–∫–µ—Ä–æ–≤)**

–í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –≤—Å—Ç—Ä–µ—Å—Ç–∏—Ç—å: ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê (–æ—á–µ–Ω—å —á–∞—Å—Ç–æ)

**üîß –ü–æ–¥—Ö–æ–¥:** N –≥–æ—Ä—É—Ç–∏–Ω-–≤–æ—Ä–∫–µ—Ä–æ–≤ + –∫–∞–Ω–∞–ª –∑–∞–¥–∞—á  
**‚ö° –°–ª–æ–∂–Ω–æ—Å—Ç—å:** O(1) dispatch, O(n/workers) processing  
**üí° –ü–æ–¥—Å–∫–∞–∑–∫–∞:** `sync.WaitGroup` –¥–ª—è –æ–∂–∏–¥–∞–Ω–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –≤—Å–µ—Ö –∑–∞–¥–∞—á  
**üîë –ö–ª—é—á–µ–≤—ã–µ –º–æ–º–µ–Ω—Ç—ã:** –ë–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∫–∞ –Ω–∞–≥—Ä—É–∑–∫–∏, –∑–∞–∫—Ä—ã—Ç–∏–µ –∫–∞–Ω–∞–ª–æ–≤

[–†–µ—à–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏ 22]

### **–ó–∞–¥–∞—á–∞ 23 - Fan-In/Fan-Out Pattern (–ü–∞—Ç—Ç–µ—Ä–Ω –í–µ–µ—Ä-–í–Ω—É—Ç—Ä—å/–í–µ–µ—Ä-–ù–∞—Ä—É–∂—É)**

–í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –≤—Å—Ç—Ä–µ—Å—Ç–∏—Ç—å: ‚≠ê‚≠ê‚≠ê (–∏–Ω–æ–≥–¥–∞)

**üîß –ü–æ–¥—Ö–æ–¥:** Select statement + multiple channels  
**‚ö° –°–ª–æ–∂–Ω–æ—Å—Ç—å:** O(n) –¥–ª—è fan-out, O(m) –¥–ª—è fan-in  
**üí° –ü–æ–¥—Å–∫–∞–∑–∫–∞:** Fan-out - –æ–¥–∏–Ω –∫–∞–Ω–∞–ª ‚Üí –º–Ω–æ–≥–æ, Fan-in - –º–Ω–æ–≥–æ –∫–∞–Ω–∞–ª–æ–≤ ‚Üí –æ–¥–∏–Ω  
**üîë –ö–ª—é—á–µ–≤—ã–µ –º–æ–º–µ–Ω—Ç—ã:** `select` —Å multiple cases, channel –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω–æ—Å—Ç—å

### **–ó–∞–¥–∞—á–∞ 24 - Data Race Detection (–û–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ –≥–æ–Ω–∫–∏ –¥–∞–Ω–Ω—ã—Ö)**

–í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –≤—Å—Ç—Ä–µ—Å—Ç–∏—Ç—å: ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê (–æ—á–µ–Ω—å —á–∞—Å—Ç–æ)

**üîß –ü–æ–¥—Ö–æ–¥:** Mutex, RWMutex –∏–ª–∏ –∞—Ç–æ–º–∞—Ä–Ω—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏  
**‚ö° –°–ª–æ–∂–Ω–æ—Å—Ç—å:** O(1) —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è  
**üí° –ü–æ–¥—Å–∫–∞–∑–∫–∞:** `sync/atomic` –¥–ª—è –ø—Ä–æ—Å—Ç—ã—Ö –æ–ø–µ—Ä–∞—Ü–∏–π, `sync.Mutex` –¥–ª—è —Å–ª–æ–∂–Ω—ã—Ö  
**üîë –ö–ª—é—á–µ–≤—ã–µ –º–æ–º–µ–Ω—Ç—ã:** –ú–∏–Ω–∏–º–∏–∑–∞—Ü–∏—è –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö —Å–µ–∫—Ü–∏–π, –∏–∑–±–µ–∂–∞–Ω–∏–µ –¥–µ–¥–ª–æ–∫–æ–≤

[–†–µ—à–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏ 24]

### **–ó–∞–¥–∞—á–∞ 25 - Semaphore Implementation (–†–µ–∞–ª–∏–∑–∞—Ü–∏—è —Å–µ–º–∞—Ñ–æ—Ä–∞)**

–í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –≤—Å—Ç—Ä–µ—Å—Ç–∏—Ç—å: ‚≠ê‚≠ê‚≠ê (–∏–Ω–æ–≥–¥–∞)

**üîß –ü–æ–¥—Ö–æ–¥:** –ë—É—Ñ–µ—Ä–∏–∑–æ–≤–∞–Ω–Ω—ã–π –∫–∞–Ω–∞–ª –∫–∞–∫ —Å—á–µ—Ç—á–∏–∫ —Ä–µ—Å—É—Ä—Å–æ–≤  
**‚ö° –°–ª–æ–∂–Ω–æ—Å—Ç—å:** O(1) acquire/release  
**üí° –ü–æ–¥—Å–∫–∞–∑–∫–∞:** `make(chan struct{}, n)` - —Å–µ–º–∞—Ñ–æ—Ä –Ω–∞ n —Ä–µ—Å—É—Ä—Å–æ–≤  
**üîë –ö–ª—é—á–µ–≤—ã–µ –º–æ–º–µ–Ω—Ç—ã:** Non-blocking operations —á–µ—Ä–µ–∑ select + default

## üî¢ –ë–∏—Ç–æ–≤—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏

### **–ó–∞–¥–∞—á–∞ 26 - Count Set Bits (–ü–æ–¥—Å—á–µ—Ç —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—ã—Ö –±–∏—Ç–æ–≤)**

–í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –≤—Å—Ç—Ä–µ—Å—Ç–∏—Ç—å: ‚≠ê‚≠ê‚≠ê (–∏–Ω–æ–≥–¥–∞)

**üîß –ü–æ–¥—Ö–æ–¥:** Brian Kernighan –∞–ª–≥–æ—Ä–∏—Ç–º –∏–ª–∏ lookup table  
**‚ö° –°–ª–æ–∂–Ω–æ—Å—Ç—å:** O(k) –≥–¥–µ k - –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—ã—Ö –±–∏—Ç–æ–≤  
**üí° –ü–æ–¥—Å–∫–∞–∑–∫–∞:** `n & (n-1)` —É–±–∏—Ä–∞–µ—Ç —Å–∞–º—ã–π –ø—Ä–∞–≤—ã–π —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—ã–π –±–∏—Ç  
**üîë –ö–ª—é—á–µ–≤—ã–µ –º–æ–º–µ–Ω—Ç—ã:** `bits.OnesCount()` –∏–∑ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–∏

### **–ó–∞–¥–∞—á–∞ 27 - Single Number (–ï–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω–æ–µ —á–∏—Å–ª–æ)**

–í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –≤—Å—Ç—Ä–µ—Å—Ç–∏—Ç—å: ‚≠ê‚≠ê‚≠ê (–∏–Ω–æ–≥–¥–∞)

**üîß –ü–æ–¥—Ö–æ–¥:** XOR –≤—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã –º–∞—Å—Å–∏–≤–∞  
**‚ö° –°–ª–æ–∂–Ω–æ—Å—Ç—å:** O(n) –≤—Ä–µ–º—è, O(1) –ø–∞–º—è—Ç—å  
**üí° –ü–æ–¥—Å–∫–∞–∑–∫–∞:** XOR —Å–≤–æ–π—Å—Ç–≤–∞: `a^a=0`, `a^0=a`, –∫–æ–º–º—É—Ç–∞—Ç–∏–≤–Ω–æ—Å—Ç—å  
**üîë –ö–ª—é—á–µ–≤—ã–µ –º–æ–º–µ–Ω—Ç—ã:** –û–±–æ–±—â–µ–Ω–∏–µ –¥–ª—è —á–∏—Å–µ–ª –≤—Å—Ç—Ä–µ—á–∞—é—â–∏—Ö—Å—è k —Ä–∞–∑

### **–ó–∞–¥–∞—á–∞ 28 - Power of Two (–°—Ç–µ–ø–µ–Ω—å –¥–≤–æ–π–∫–∏)**

–í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –≤—Å—Ç—Ä–µ—Å—Ç–∏—Ç—å: ‚≠ê‚≠ê (—Ä–µ–¥–∫–æ)

**üîß –ü–æ–¥—Ö–æ–¥:** –ë–∏—Ç–æ–≤–∞—è –æ–ø–µ—Ä–∞—Ü–∏—è `n & (n-1) == 0`  
**‚ö° –°–ª–æ–∂–Ω–æ—Å—Ç—å:** O(1) –≤—Ä–µ–º—è –∏ –ø–∞–º—è—Ç—å  
**üí° –ü–æ–¥—Å–∫–∞–∑–∫–∞:** –°—Ç–µ–ø–µ–Ω—å –¥–≤–æ–π–∫–∏ –∏–º–µ–µ—Ç —Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—ã–π –±–∏—Ç  
**üîë –ö–ª—é—á–µ–≤—ã–µ –º–æ–º–µ–Ω—Ç—ã:** –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å —á–∏—Å–ª–∞

### **–ó–∞–¥–∞—á–∞ 29 - Bit Mask Subsets (–ü–æ–¥–º–Ω–æ–∂–µ—Å—Ç–≤–∞ —Å –±–∏—Ç–æ–≤—ã–º–∏ –º–∞—Å–∫–∞–º–∏)**

–í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –≤—Å—Ç—Ä–µ—Å—Ç–∏—Ç—å: ‚≠ê‚≠ê (—Ä–µ–¥–∫–æ)

**üîß –ü–æ–¥—Ö–æ–¥:** –ò—Ç–µ—Ä–∞—Ü–∏—è –æ—Ç 0 –¥–æ 2^n - 1  
**‚ö° –°–ª–æ–∂–Ω–æ—Å—Ç—å:** O(n * 2^n) –≤—Ä–µ–º—è, O(2^n) –ø–∞–º—è—Ç—å  
**üí° –ü–æ–¥—Å–∫–∞–∑–∫–∞:** i-–π –±–∏—Ç –º–∞—Å–∫–∏ –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç –≤–∫–ª—é—á–µ–Ω–∏–µ i-–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞  
**üîë –ö–ª—é—á–µ–≤—ã–µ –º–æ–º–µ–Ω—Ç—ã:** –ü—Ä–æ–≤–µ—Ä–∫–∞ –±–∏—Ç–∞: `mask & (1 << i) != 0`

## üíæ –ü—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∞–Ω–Ω—ã—Ö

### **–ó–∞–¥–∞—á–∞ 30 - LRU Cache (LRU –∫–µ—à)**

–í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –≤—Å—Ç—Ä–µ—Å—Ç–∏—Ç—å: ‚≠ê‚≠ê‚≠ê (–∏–Ω–æ–≥–¥–∞)

**üîß –ü–æ–¥—Ö–æ–¥:** HashMap + Doubly Linked List  
**‚ö° –°–ª–æ–∂–Ω–æ—Å—Ç—å:** O(1) get/put –æ–ø–µ—Ä–∞—Ü–∏–∏  
**üí° –ü–æ–¥—Å–∫–∞–∑–∫–∞:** Map –¥–ª—è O(1) –¥–æ—Å—Ç—É–ø–∞, DLL –¥–ª—è O(1) –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è –≤ –Ω–∞—á–∞–ª–æ  
**üîë –ö–ª—é—á–µ–≤—ã–µ –º–æ–º–µ–Ω—Ç—ã:** –§–∏–∫—Ç–∏–≤–Ω—ã–µ head/tail —É–∑–ª—ã –¥–ª—è —É–ø—Ä–æ—â–µ–Ω–∏—è

### **–ó–∞–¥–∞—á–∞ 31 - Doubly Linked List (–î–≤—É—Å–≤—è–∑–Ω—ã–π —Å–ø–∏—Å–æ–∫)**

–í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –≤—Å—Ç—Ä–µ—Å—Ç–∏—Ç—å: ‚≠ê‚≠ê (—Ä–µ–¥–∫–æ)

**üîß –ü–æ–¥—Ö–æ–¥:** –£–∑–ª—ã —Å prev –∏ next —É–∫–∞–∑–∞—Ç–µ–ª—è–º–∏  
**‚ö° –°–ª–æ–∂–Ω–æ—Å—Ç—å:** O(1) –≤—Å—Ç–∞–≤–∫–∞/—É–¥–∞–ª–µ–Ω–∏–µ, O(n) –ø–æ–∏—Å–∫  
**üí° –ü–æ–¥—Å–∫–∞–∑–∫–∞:** –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ 4 —É–∫–∞–∑–∞—Ç–µ–ª–µ–π –ø—Ä–∏ –≤—Å—Ç–∞–≤–∫–µ/—É–¥–∞–ª–µ–Ω–∏–∏  
**üîë –ö–ª—é—á–µ–≤—ã–µ –º–æ–º–µ–Ω—Ç—ã:** –û–±—Ä–∞–±–æ—Ç–∫–∞ –≥—Ä–∞–Ω–∏—á–Ω—ã—Ö —Å–ª—É—á–∞–µ–≤ (head/tail)

### **–ó–∞–¥–∞—á–∞ 32 - Trie (Prefix Tree) (–ü—Ä–µ—Ñ–∏–∫—Å–Ω–æ–µ –¥–µ—Ä–µ–≤–æ)**

–í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –≤—Å—Ç—Ä–µ—Å—Ç–∏—Ç—å: ‚≠ê‚≠ê (—Ä–µ–¥–∫–æ)

**üîß –ü–æ–¥—Ö–æ–¥:** –î–µ—Ä–µ–≤–æ —Å –¥–µ—Ç—å–º–∏ –∫–∞–∫ map[rune]*TrieNode  
**‚ö° –°–ª–æ–∂–Ω–æ—Å—Ç—å:** O(m) –≤—Å—Ç–∞–≤–∫–∞/–ø–æ–∏—Å–∫, –≥–¥–µ m - –¥–ª–∏–Ω–∞ —Å–ª–æ–≤–∞  
**üí° –ü–æ–¥—Å–∫–∞–∑–∫–∞:** –§–ª–∞–≥ isEnd –≤ —É–∑–ª–µ –¥–ª—è –æ–±–æ–∑–Ω–∞—á–µ–Ω–∏—è –∫–æ–Ω—Ü–∞ —Å–ª–æ–≤–∞  
**üîë –ö–ª—é—á–µ–≤—ã–µ –º–æ–º–µ–Ω—Ç—ã:** –ê–≤—Ç–æ–¥–æ–ø–æ–ª–Ω–µ–Ω–∏–µ —á–µ—Ä–µ–∑ DFS –æ—Ç –ø—Ä–µ—Ñ–∏–∫—Å–∞

### **–ó–∞–¥–∞—á–∞ 33 - Hash Table from Scratch (–•–µ—à-—Ç–∞–±–ª–∏—Ü–∞ —Å –Ω—É–ª—è)**

–í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –≤—Å—Ç—Ä–µ—Å—Ç–∏—Ç—å: ‚≠ê‚≠ê (—Ä–µ–¥–∫–æ)

**üîß –ü–æ–¥—Ö–æ–¥:** –ú–∞—Å—Å–∏–≤ + —Ö–µ—à-—Ñ—É–Ω–∫—Ü–∏—è + –æ–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–ª–ª–∏–∑–∏–π  
**‚ö° –°–ª–æ–∂–Ω–æ—Å—Ç—å:** O(1) —Å—Ä–µ–¥–Ω–∏–π —Å–ª—É—á–∞–π, O(n) —Ö—É–¥—à–∏–π  
**üí° –ü–æ–¥—Å–∫–∞–∑–∫–∞:** Chaining –∏–ª–∏ Open Addressing –¥–ª—è –∫–æ–ª–ª–∏–∑–∏–π  
**üîë –ö–ª—é—á–µ–≤—ã–µ –º–æ–º–µ–Ω—Ç—ã:** Load factor, rehashing –ø—Ä–∏ —Ä–æ—Å—Ç–µ

## üß† –î–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–µ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–µ

### **–ó–∞–¥–∞—á–∞ 34 - Knapsack Problem (–ó–∞–¥–∞—á–∞ –æ —Ä—é–∫–∑–∞–∫–µ)**

–í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –≤—Å—Ç—Ä–µ—Å—Ç–∏—Ç—å: ‚≠ê‚≠ê (—Ä–µ–¥–∫–æ)

**üîß –ü–æ–¥—Ö–æ–¥:** 2D DP —Ç–∞–±–ª–∏—Ü–∞ –∏–ª–∏ 1D –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è  
**‚ö° –°–ª–æ–∂–Ω–æ—Å—Ç—å:** O(n*W) –≤—Ä–µ–º—è, O(W) –ø–∞–º—è—Ç—å (–æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ)  
**üí° –ü–æ–¥—Å–∫–∞–∑–∫–∞:** `dp[i][w] = max(dp[i-1][w], dp[i-1][w-weight[i]] + value[i])`  
**üîë –ö–ª—é—á–µ–≤—ã–µ –º–æ–º–µ–Ω—Ç—ã:** –û–±—Ä–∞—Ç–Ω—ã–π –ø—Ä–æ—Ö–æ–¥ –¥–ª—è 1D –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏

### **–ó–∞–¥–∞—á–∞ 35 - Longest Common Subsequence (–ù–∞–∏–±–æ–ª—å—à–∞—è –æ–±—â–∞—è –ø–æ–¥–ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å)**

–í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –≤—Å—Ç—Ä–µ—Å—Ç–∏—Ç—å: ‚≠ê‚≠ê (—Ä–µ–¥–∫–æ)

**üîß –ü–æ–¥—Ö–æ–¥:** 2D DP —Ç–∞–±–ª–∏—Ü–∞ –¥–ª—è —Å—Ä–∞–≤–Ω–µ–Ω–∏—è —Å–∏–º–≤–æ–ª–æ–≤  
**‚ö° –°–ª–æ–∂–Ω–æ—Å—Ç—å:** O(m*n) –≤—Ä–µ–º—è –∏ –ø–∞–º—è—Ç—å  
**üí° –ü–æ–¥—Å–∫–∞–∑–∫–∞:** –ï—Å–ª–∏ —Å–∏–º–≤–æ–ª—ã —Ä–∞–≤–Ω—ã: `dp[i][j] = dp[i-1][j-1] + 1`  
**üîë –ö–ª—é—á–µ–≤—ã–µ –º–æ–º–µ–Ω—Ç—ã:** –†–µ–∫–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏—è LCS —á–µ—Ä–µ–∑ traceback

### **–ó–∞–¥–∞—á–∞ 36 - Coin Change (–†–∞–∑–º–µ–Ω –º–æ–Ω–µ—Ç)**

–í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –≤—Å—Ç—Ä–µ—Å—Ç–∏—Ç—å: ‚≠ê‚≠ê (—Ä–µ–¥–∫–æ)

**üîß –ü–æ–¥—Ö–æ–¥:** 1D DP –º–∞—Å—Å–∏–≤, –ø–µ—Ä–µ–±–æ—Ä –º–æ–Ω–µ—Ç –¥–ª—è –∫–∞–∂–¥–æ–π —Å—É–º–º—ã  
**‚ö° –°–ª–æ–∂–Ω–æ—Å—Ç—å:** O(amount * coins) –≤—Ä–µ–º—è, O(amount) –ø–∞–º—è—Ç—å  
**üí° –ü–æ–¥—Å–∫–∞–∑–∫–∞:** `dp[amount] = min(dp[amount], dp[amount-coin] + 1)`  
**üîë –ö–ª—é—á–µ–≤—ã–µ –º–æ–º–µ–Ω—Ç—ã:** –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å –±–æ–ª—å—à–∏–º–∏ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏

### **–ó–∞–¥–∞—á–∞ 37 - House Robber (–ì—Ä–∞–±–∏—Ç–µ–ª—å –¥–æ–º–æ–≤)**

–í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –≤—Å—Ç—Ä–µ—Å—Ç–∏—Ç—å: ‚≠ê‚≠ê (—Ä–µ–¥–∫–æ)

**üîß –ü–æ–¥—Ö–æ–¥:** DP —Å –¥–≤—É–º—è —Å–æ—Å—Ç–æ—è–Ω–∏—è–º–∏ (–≥—Ä–∞–±–∏–º/–Ω–µ –≥—Ä–∞–±–∏–º)  
**‚ö° –°–ª–æ–∂–Ω–æ—Å—Ç—å:** O(n) –≤—Ä–µ–º—è, O(1) –ø–∞–º—è—Ç—å  
**üí° –ü–æ–¥—Å–∫–∞–∑–∫–∞:** `dp[i] = max(dp[i-1], dp[i-2] + nums[i])`  
**üîë –ö–ª—é—á–µ–≤—ã–µ –º–æ–º–µ–Ω—Ç—ã:** –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –ø–∞–º—è—Ç–∏ –¥–æ –¥–≤—É—Ö –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö

## üå≥ –ü—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–µ –¥–µ—Ä–µ–≤—å—è –∏ –≥—Ä–∞—Ñ—ã

### **–ó–∞–¥–∞—á–∞ 38 - Balanced Binary Tree (–°–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –±–∏–Ω–∞—Ä–Ω–æ–µ –¥–µ—Ä–µ–≤–æ)**

–í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –≤—Å—Ç—Ä–µ—Å—Ç–∏—Ç—å: ‚≠ê‚≠ê (—Ä–µ–¥–∫–æ)

**üîß –ü–æ–¥—Ö–æ–¥:** –†–µ–∫—É—Ä—Å–∏–≤–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –≤—ã—Å–æ—Ç—ã –ø–æ–¥–¥–µ—Ä–µ–≤—å–µ–≤  
**‚ö° –°–ª–æ–∂–Ω–æ—Å—Ç—å:** O(n) –≤—Ä–µ–º—è, O(h) –ø–∞–º—è—Ç—å (–≤—ã—Å–æ—Ç–∞ –¥–µ—Ä–µ–≤–∞)  
**üí° –ü–æ–¥—Å–∫–∞–∑–∫–∞:** –†–∞–∑–Ω–∏—Ü–∞ –≤—ã—Å–æ—Ç –ª–µ–≤–æ–≥–æ –∏ –ø—Ä–∞–≤–æ–≥–æ –ø–æ–¥–¥–µ—Ä–µ–≤–∞ ‚â§ 1  
**üîë –ö–ª—é—á–µ–≤—ã–µ –º–æ–º–µ–Ω—Ç—ã:** Bottom-up –ø–æ–¥—Ö–æ–¥ –¥–ª—è O(n) —Å–ª–æ–∂–Ω–æ—Å—Ç–∏

### **–ó–∞–¥–∞—á–∞ 39 - Graph Cycle Detection (–û–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ —Ü–∏–∫–ª–æ–≤ –≤ –≥—Ä–∞—Ñ–µ)**

–í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –≤—Å—Ç—Ä–µ—Å—Ç–∏—Ç—å: ‚≠ê‚≠ê (—Ä–µ–¥–∫–æ)

**üîß –ü–æ–¥—Ö–æ–¥:** DFS —Å —Ç—Ä–µ–º—è —Å–æ—Å—Ç–æ—è–Ω–∏—è–º–∏ (–±–µ–ª—ã–π/—Å–µ—Ä—ã–π/—á–µ—Ä–Ω—ã–π)  
**‚ö° –°–ª–æ–∂–Ω–æ—Å—Ç—å:** O(V + E) –≤—Ä–µ–º—è, O(V) –ø–∞–º—è—Ç—å  
**üí° –ü–æ–¥—Å–∫–∞–∑–∫–∞:** –¶–∏–∫–ª –µ—Å—Ç—å, –µ—Å–ª–∏ DFS –Ω–∞—Ö–æ–¥–∏—Ç —Å–µ—Ä—ã–π —É–∑–µ–ª  
**üîë –ö–ª—é—á–µ–≤—ã–µ –º–æ–º–µ–Ω—Ç—ã:** –î–ª—è –Ω–µ–æ—Ä–∏–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ - –ø—Ä–æ–≤–µ—Ä–∫–∞ back edge

### **–ó–∞–¥–∞—á–∞ 40 - Shortest Path (Dijkstra) (–ö—Ä–∞—Ç—á–∞–π—à–∏–π –ø—É—Ç—å - –î–µ–π–∫—Å—Ç—Ä–∞)**

–í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –≤—Å—Ç—Ä–µ—Å—Ç–∏—Ç—å: ‚≠ê‚≠ê (—Ä–µ–¥–∫–æ)

**üîß –ü–æ–¥—Ö–æ–¥:** Priority Queue + relaxation –∞–ª–≥–æ—Ä–∏—Ç–º  
**‚ö° –°–ª–æ–∂–Ω–æ—Å—Ç—å:** O((V + E) log V) —Å binary heap  
**üí° –ü–æ–¥—Å–∫–∞–∑–∫–∞:** –í—ã–±–∏—Ä–∞–µ–º —É–∑–µ–ª —Å –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–π –¥–∏—Å—Ç–∞–Ω—Ü–∏–µ–π, –æ–±–Ω–æ–≤–ª—è–µ–º —Å–æ—Å–µ–¥–µ–π  
**üîë –ö–ª—é—á–µ–≤—ã–µ –º–æ–º–µ–Ω—Ç—ã:** –ù–µ —Ä–∞–±–æ—Ç–∞–µ—Ç —Å –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–º–∏ –≤–µ—Å–∞–º–∏

## üöÄ –†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–µ –ø–∞—Ç—Ç–µ—Ä–Ω—ã —Ä–µ—à–µ–Ω–∏–π

### **üîÑ Two Pointers Pattern**

**–ü—Ä–∏–º–µ–Ω–∏–º–æ—Å—Ç—å –∫ –ó–∞–¥–∞—á–∞–º ‚Ññ:**  
 [3](#–∑–∞–¥–∞—á–∞-3---valid-palindrome-–ø—Ä–æ–≤–µ—Ä–∫–∞-–ø–∞–ª–∏–Ω–¥—Ä–æ–º–∞) - **Valid Palindrome (–ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–∞–ª–∏–Ω–¥—Ä–æ–º–∞)**,  
 [5](#–∑–∞–¥–∞—á–∞-5---merge-two-sorted-arrays-–æ–±—ä–µ–¥–∏–Ω–∏—Ç—å-–¥–≤–∞-–æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö-–º–∞—Å—Å–∏–≤–∞) - **Merge Two Sorted Arrays (–û–±—ä–µ–¥–∏–Ω–∏—Ç—å –¥–≤–∞ –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –º–∞—Å—Å–∏–≤–∞)**,  
 [13](#–∑–∞–¥–∞—á–∞-13---reverse-stringarray-–æ–±—Ä–∞—Ç–∏—Ç—å-—Å—Ç—Ä–æ–∫—É–º–∞—Å—Å–∏–≤) - **Reverse String/Array (–û–±—Ä–∞—Ç–∏—Ç—å —Å—Ç—Ä–æ–∫—É/–º–∞—Å—Å–∏–≤)**  

**–ü—Ä–∏–Ω—Ü–∏–ø:** –î–≤–∞ —É–∫–∞–∑–∞—Ç–µ–ª—è –¥–≤–∏–∂—É—Ç—Å—è –Ω–∞–≤—Å—Ç—Ä–µ—á—É –∏–ª–∏ –≤ –æ–¥–Ω–æ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–∏  

**Go-—Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è:**

```go
left, right := 0, len(arr)-1
for left < right {
    // –ª–æ–≥–∏–∫–∞ —Å—Ä–∞–≤–Ω–µ–Ω–∏—è
    // –¥–≤–∏–∂–µ–Ω–∏–µ —É–∫–∞–∑–∞—Ç–µ–ª–µ–π
}
```

### **üó∫Ô∏è HashMap/Set Pattern**

**–ü—Ä–∏–º–µ–Ω–∏–º–æ—Å—Ç—å –∫ –ó–∞–¥–∞—á–∞–º ‚Ññ:**  
[1](#–∑–∞–¥–∞—á–∞-1---two-sum-—Å—É–º–º–∞-–¥–≤—É—Ö) - Two Sum (–°—É–º–º–∞ –¥–≤—É—Ö),  
[6](#–∑–∞–¥–∞—á–∞-6---intersection-of-two-arrays-–ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ-–¥–≤—É—Ö-–º–∞—Å—Å–∏–≤–æ–≤) - Intersection of Two Arrays (–ü–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ –¥–≤—É—Ö –º–∞—Å—Å–∏–≤–æ–≤),  
[18](#–∑–∞–¥–∞—á–∞-18---anagram-groups-–≥—Ä—É–ø–ø—ã-–∞–Ω–∞–≥—Ä–∞–º–º) - Anagram Groups (–ì—Ä—É–ø–ø—ã –∞–Ω–∞–≥—Ä–∞–º–º),  
[30](#–∑–∞–¥–∞—á–∞-30---lru-cache-lru-–∫–µ—à) - LRU Cache (LRU –∫–µ—à),  
[33](#–∑–∞–¥–∞—á–∞-33---hash-table-from-scratch-—Ö–µ—à-—Ç–∞–±–ª–∏—Ü–∞-—Å-–Ω—É–ª—è) - Hash Table from Scratch (–•–µ—à-—Ç–∞–±–ª–∏—Ü–∞ —Å –Ω—É–ª—è)

**–ü—Ä–∏–Ω—Ü–∏–ø:** –•—Ä–∞–Ω–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –ø–æ–∏—Å–∫–∞ O(1)  

**Go-—Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è:**

```go
seen := make(map[Type]bool)
// –∏–ª–∏ –¥–ª—è –ø–æ–¥—Å—á–µ—Ç–∞
count := make(map[Type]int)
```

### **ü™ü Sliding Window Pattern**

**–ü—Ä–∏–º–µ–Ω–∏–º–æ—Å—Ç—å –∫ –ó–∞–¥–∞—á–∞–º ‚Ññ:**  
[4](#–∑–∞–¥–∞—á–∞-4---longest-substring-without-repeating-—Å–∞–º–∞—è-–¥–ª–∏–Ω–Ω–∞—è-–ø–æ–¥—Å—Ç—Ä–æ–∫–∞-–±–µ–∑-–ø–æ–≤—Ç–æ—Ä–µ–Ω–∏–π) - Longest Substring Without Repeating (–°–∞–º–∞—è –¥–ª–∏–Ω–Ω–∞—è –ø–æ–¥—Å—Ç—Ä–æ–∫–∞ –±–µ–∑ –ø–æ–≤—Ç–æ—Ä–µ–Ω–∏–π)

**–ü—Ä–∏–Ω—Ü–∏–ø:** –û–∫–Ω–æ –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–≥–æ —Ä–∞–∑–º–µ—Ä–∞ –ø–æ –º–∞—Å—Å–∏–≤—É/—Å—Ç—Ä–æ–∫–µ  

**Go-—Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è:**

```go
left := 0
for right := 0; right < len(s); right++ {
    // —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ –æ–∫–Ω–∞
    for condition {
        // —Å–∂–∞—Ç–∏–µ –æ–∫–Ω–∞
        left++
    }
}
```

### **üìö Stack/Queue Pattern**

**–ü—Ä–∏–º–µ–Ω–∏–º–æ—Å—Ç—å –∫ –ó–∞–¥–∞—á–∞–º ‚Ññ:**  
[9](#–∑–∞–¥–∞—á–∞-9---valid-parentheses-–ø—Ä–æ–≤–µ—Ä–∫–∞-—Å–∫–æ–±–æ–∫) - Valid Parentheses (–ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–∫–æ–±–æ–∫),  
[15](#–∑–∞–¥–∞—á–∞-15---bfsdfs-implementation-—Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è-bfsdfs) - –ó–∞–¥–∞—á–∞ 15 - BFS/DFS Implementation (–†–µ–∞–ª–∏–∑–∞—Ü–∏—è BFS/DFS),  
[16](#–∑–∞–¥–∞—á–∞-16---stack-implementation-—Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è-—Å—Ç–µ–∫–∞) - Stack Implementation (–†–µ–∞–ª–∏–∑–∞—Ü–∏—è —Å—Ç–µ–∫–∞),  
[19](#–∑–∞–¥–∞—á–∞-19---queue-with-channels-–æ—á–µ—Ä–µ–¥—å-—Å-–∫–∞–Ω–∞–ª–∞–º–∏) - –ó–∞–¥–∞—á–∞ 19 - Queue with Channels (–û—á–µ—Ä–µ–¥—å —Å –∫–∞–Ω–∞–ª–∞–º–∏),  
[20](#–∑–∞–¥–∞—á–∞-20---min-stack-–º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π-—Å—Ç–µ–∫) - Min Stack (–ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —Å—Ç–µ–∫)

**–ü—Ä–∏–Ω—Ü–∏–ø:** LIFO/FIFO —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –¥–∞–Ω–Ω—ã—Ö  

**Go-—Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è:**

```go
// Stack
stack := []int{}
stack = append(stack, val) // push
val = stack[len(stack)-1]; stack = stack[:len(stack)-1] // pop

// Queue
queue := []int{}
queue = append(queue, val) // enqueue
val = queue[0]; queue = queue[1:] // dequeue
```

### **üéØ Divide & Conquer Pattern**

**–ü—Ä–∏–º–µ–Ω–∏–º–æ—Å—Ç—å –∫ –ó–∞–¥–∞—á–∞–º ‚Ññ:**  
[7](#–∑–∞–¥–∞—á–∞-7---binary-search-–±–∏–Ω–∞—Ä–Ω—ã–π-–ø–æ–∏—Å–∫) - Binary Search (–ë–∏–Ω–∞—Ä–Ω—ã–π –ø–æ–∏—Å–∫),  
[8](#–∑–∞–¥–∞—á–∞-8---kth-largest-element-k-–π-–Ω–∞–∏–±–æ–ª—å—à–∏–π-—ç–ª–µ–º–µ–Ω—Ç) - –ó–∞–¥–∞—á–∞ 8 - Kth Largest Element (K-–π –Ω–∞–∏–±–æ–ª—å—à–∏–π —ç–ª–µ–º–µ–Ω—Ç),  
[11](#–∑–∞–¥–∞—á–∞-11---quickSort-implementation-—Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è-–±—ã—Å—Ç—Ä–æ–π-—Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏) - QuickSort Implementation (–†–µ–∞–ª–∏–∑–∞—Ü–∏—è –±—ã—Å—Ç—Ä–æ–π —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏)

**–ü—Ä–∏–Ω—Ü–∏–ø:** –î–µ–ª–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏ –Ω–∞ –ø–æ–¥–∑–∞–¥–∞—á–∏  

**Go-—Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è:**

```go
func solve(arr []int, left, right int) {
    if left >= right { return }
    
    mid := left + (right-left)/2
    solve(arr, left, mid)
    solve(arr, mid+1, right)
    // –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
}
```

### **üîó Fast/Slow Pointers Pattern**

**–ü—Ä–∏–º–µ–Ω–∏–º–æ—Å—Ç—å:** –ó–∞–¥–∞—á–∞ 12  
**–ü—Ä–∏–Ω—Ü–∏–ø:** –£–∫–∞–∑–∞—Ç–µ–ª–∏ –¥–≤–∏–∂—É—Ç—Å—è —Å —Ä–∞–∑–Ω–æ–π —Å–∫–æ—Ä–æ—Å—Ç—å—é  
**Go-—Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è:**

```go
slow, fast := head, head
for fast != nil && fast.Next != nil {
    slow = slow.Next
    fast = fast.Next.Next
    if slow == fast { return true } // —Ü–∏–∫–ª –Ω–∞–π–¥–µ–Ω
}
```

### **üíæ Dynamic Programming Pattern**

**–ü—Ä–∏–º–µ–Ω–∏–º–æ—Å—Ç—å –∫ –ó–∞–¥–∞—á–∞–º ‚Ññ:**  
[17](#–∑–∞–¥–∞—á–∞-17---fibonacci-numbers-—á–∏—Å–ª–∞-—Ñ–∏–±–æ–Ω–∞—á—á–∏) - Fibonacci Numbers (–ß–∏—Å–ª–∞ –§–∏–±–æ–Ω–∞—á—á–∏),  
[34](#–∑–∞–¥–∞—á–∞-34---knapsack-problem-–∑–∞–¥–∞—á–∞-–æ-—Ä—é–∫–∑–∞–∫–µ) - –ó–∞–¥–∞—á–∞ 34 - Knapsack Problem (–ó–∞–¥–∞—á–∞ –æ —Ä—é–∫–∑–∞–∫–µ),  
[35](#–∑–∞–¥–∞—á–∞-35---longest-common-subsequence-–Ω–∞–∏–±–æ–ª—å—à–∞—è-–æ–±—â–∞—è-–ø–æ–¥–ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å) - Longest Common Subsequence (–ù–∞–∏–±–æ–ª—å—à–∞—è –æ–±—â–∞—è –ø–æ–¥–ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å),  
[36](#–∑–∞–¥–∞—á–∞-36---coin-change-—Ä–∞–∑–º–µ–Ω-–º–æ–Ω–µ—Ç) - Coin Change (–†–∞–∑–º–µ–Ω –º–æ–Ω–µ—Ç),  
[37](#–∑–∞–¥–∞—á–∞-37---house-robber-–≥—Ä–∞–±–∏—Ç–µ–ª—å-–¥–æ–º–æ–≤) - House Robber (–ì—Ä–∞–±–∏—Ç–µ–ª—å –¥–æ–º–æ–≤)

**–ü—Ä–∏–Ω—Ü–∏–ø:** –ó–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã—Ö —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤  

**Go-—Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è:**

```go
// Bottom-up –ø–æ–¥—Ö–æ–¥
dp := make([]int, n+1)
dp[0], dp[1] = 0, 1
for i := 2; i <= n; i++ {
    dp[i] = dp[i-1] + dp[i-2]
}
```

### **üöÄ Concurrency Patterns**

**–ü—Ä–∏–º–µ–Ω–∏–º–æ—Å—Ç—å –∫ –ó–∞–¥–∞—á–∞–º ‚Ññ:**  
[21](#–∑–∞–¥–∞—á–∞-21---producer-consumer-pattern-–ø–∞—Ç—Ç–µ—Ä–Ω-–ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å-–ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—å) - Producer-Consumer Pattern (–ü–∞—Ç—Ç–µ—Ä–Ω –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å-–ü–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—å),  
[22](#–∑–∞–¥–∞—á–∞-22---worker-pool-–ø—É–ª-–≤–æ—Ä–∫–µ—Ä–æ–≤) - Worker Pool (–ü—É–ª –≤–æ—Ä–∫–µ—Ä–æ–≤),  
[23](#–∑–∞–¥–∞—á–∞-23---fan-infan-out-pattern-–ø–∞—Ç—Ç–µ—Ä–Ω-–≤–µ–µ—Ä-–≤–Ω—É—Ç—Ä—å–≤–µ–µ—Ä-–Ω–∞—Ä—É–∂—É) - Fan-In/Fan-Out Pattern (–ü–∞—Ç—Ç–µ—Ä–Ω –í–µ–µ—Ä-–í–Ω—É—Ç—Ä—å/–í–µ–µ—Ä-–ù–∞—Ä—É–∂—É),  
[24](#–∑–∞–¥–∞—á–∞-24---data-race-detection-–æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ-–≥–æ–Ω–∫–∏-–¥–∞–Ω–Ω—ã—Ö) - –ó–∞–¥–∞—á–∞ 24 - Data Race Detection (–û–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ –≥–æ–Ω–∫–∏ –¥–∞–Ω–Ω—ã—Ö),  
[25](#–∑–∞–¥–∞—á–∞-25---semaphore-implementation-—Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è-—Å–µ–º–∞—Ñ–æ—Ä–∞) - Semaphore Implementation (–†–µ–∞–ª–∏–∑–∞—Ü–∏—è —Å–µ–º–∞—Ñ–æ—Ä–∞)

**–ü—Ä–∏–Ω—Ü–∏–ø:** –ö–æ–æ—Ä–¥–∏–Ω–∞—Ü–∏—è –≥–æ—Ä—É—Ç–∏–Ω —á–µ—Ä–µ–∑ –∫–∞–Ω–∞–ª—ã –∏ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—é  

**Go-—Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è:**

```go
// Worker Pool
jobs := make(chan Job, 100)
var wg sync.WaitGroup

for i := 0; i < numWorkers; i++ {
    wg.Add(1)
    go func() {
        defer wg.Done()
        for job := range jobs {
            processJob(job)
        }
    }()
}

// Fan-In
func fanIn(inputs ...<-chan int) <-chan int {
    out := make(chan int)
    var wg sync.WaitGroup
    
    for _, input := range inputs {
        wg.Add(1)
        go func(ch <-chan int) {
            defer wg.Done()
            for val := range ch {
                out <- val
            }
        }(input)
    }
    
    go func() {
        wg.Wait()
        close(out)
    }()
    
    return out
}
```

### **üî¢ Bit Manipulation Patterns**

**–ü—Ä–∏–º–µ–Ω–∏–º–æ—Å—Ç—å –∫ –ó–∞–¥–∞—á–∞–º ‚Ññ:**  
[26](#–∑–∞–¥–∞—á–∞-26---count-set-bits-–ø–æ–¥—Å—á–µ—Ç-—É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—ã—Ö-–±–∏—Ç–æ–≤) - Count Set Bits (–ü–æ–¥—Å—á–µ—Ç —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—ã—Ö –±–∏—Ç–æ–≤),  
[27](#–∑–∞–¥–∞—á–∞-27---single-number-–µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω–æ–µ-—á–∏—Å–ª–æ) - Single Number (–ï–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω–æ–µ —á–∏—Å–ª–æ),  
[28](#–∑–∞–¥–∞—á–∞-28---power-of-two-—Å—Ç–µ–ø–µ–Ω—å-–¥–≤–æ–π–∫–∏) - Power of Two (–°—Ç–µ–ø–µ–Ω—å –¥–≤–æ–π–∫–∏),  
[29](#–∑–∞–¥–∞—á–∞-29---bit-mask-subsets-–ø–æ–¥–º–Ω–æ–∂–µ—Å—Ç–≤–∞-—Å-–±–∏—Ç–æ–≤—ã–º–∏-–º–∞—Å–∫–∞–º–∏) -
Bit Mask Subsets (–ü–æ–¥–º–Ω–æ–∂–µ—Å—Ç–≤–∞ —Å –±–∏—Ç–æ–≤—ã–º–∏ –º–∞—Å–∫–∞–º–∏)
**–ü—Ä–∏–Ω—Ü–∏–ø:** –≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ –Ω–∞ —É—Ä–æ–≤–Ω–µ –±–∏—Ç–æ–≤  

**Go-—Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è:**

```go
// Brian Kernighan's Algorithm
func countSetBits(n int) int {
    count := 0
    for n != 0 {
        n &= n - 1  // —É–±–∏—Ä–∞–µ–º —Å–∞–º—ã–π –ø—Ä–∞–≤—ã–π —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—ã–π –±–∏—Ç
        count++
    }
    return count
}

// Check Power of Two
func isPowerOfTwo(n int) bool {
    return n > 0 && n&(n-1) == 0
}

// Generate Subsets
func subsets(nums []int) [][]int {
    n := len(nums)
    result := make([][]int, 0, 1<<n)
    
    for mask := 0; mask < 1<<n; mask++ {
        subset := []int{}
        for i := 0; i < n; i++ {
            if mask&(1<<i) != 0 {
                subset = append(subset, nums[i])
            }
        }
        result = append(result, subset)
    }
    return result
}
```

## üêπ –†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–µ Go-—Å–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã–µ –º–∞—Ç–µ—Ä–∏–∞–ª—ã

### **üìä –û—Å–Ω–æ–≤–Ω—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∞–Ω–Ω—ã—Ö**

#### **Slice ([]T) - –ó–∞–¥–∞—á–∏: –≤—Å–µ –º–∞—Å—Å–∏–≤–Ω—ã–µ**

```go
// –°–æ–∑–¥–∞–Ω–∏–µ
arr := make([]int, 0, 10)    // length=0, capacity=10
arr = []int{1, 2, 3}         // –ª–∏—Ç–µ—Ä–∞–ª

// –û–ø–µ—Ä–∞—Ü–∏–∏
arr = append(arr, 4)         // –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ O(1) –∞–º–æ—Ä—Ç–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ
copy(dst, src)               // –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ
arr = arr[:len(arr)-1]       // —É–¥–∞–ª–µ–Ω–∏–µ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ
arr = arr[1:]                // —É–¥–∞–ª–µ–Ω–∏–µ –ø–µ—Ä–≤–æ–≥–æ

// Capacity management
if cap(arr) < len(arr)*2 {
    newArr := make([]int, len(arr), len(arr)*2)
    copy(newArr, arr)
    arr = newArr
}
```

#### **Map (map[K]V) - –ó–∞–¥–∞—á–∏: 1, 6, 18, 30, 33**

```go
// –°–æ–∑–¥–∞–Ω–∏–µ
m := make(map[string]int)
m := map[string]int{"key": 1}

// –û–ø–µ—Ä–∞—Ü–∏–∏
m["key"] = value             // —É—Å—Ç–∞–Ω–æ–≤–∫–∞
val, exists := m["key"]      // –ø–æ–ª—É—á–µ–Ω–∏–µ —Å –ø—Ä–æ–≤–µ—Ä–∫–æ–π
delete(m, "key")             // —É–¥–∞–ª–µ–Ω–∏–µ
len(m)                       // —Ä–∞–∑–º–µ—Ä

// –ò—Ç–µ—Ä–∞—Ü–∏—è (–ø–æ—Ä—è–¥–æ–∫ –Ω–µ –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω!)
for k, v := range m {
    // –æ–±—Ä–∞–±–æ—Ç–∫–∞
}

// Concurrent-safe operations
var mu sync.RWMutex
mu.RLock()
val := m[key]  // —á–∏—Ç–∞–µ–º
mu.RUnlock()

mu.Lock()
m[key] = val   // –ø–∏—à–µ–º
mu.Unlock()
```

#### **Channel (chan T) - –ó–∞–¥–∞—á–∏: 19, 21, 22, 23, 25**

```go
// –°–æ–∑–¥–∞–Ω–∏–µ
ch := make(chan int)         // –Ω–µ–±—É—Ñ–µ—Ä–∏–∑–æ–≤–∞–Ω–Ω—ã–π (—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π)
ch := make(chan int, 5)      // –±—É—Ñ–µ—Ä–∏–∑–æ–≤–∞–Ω–Ω—ã–π (–∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π)

// –û–ø–µ—Ä–∞—Ü–∏–∏
ch <- value                  // –æ—Ç–ø—Ä–∞–≤–∫–∞ (–±–ª–æ–∫–∏—Ä—É—é—â–∞—è)
val := <-ch                  // –ø–æ–ª—É—á–µ–Ω–∏–µ (–±–ª–æ–∫–∏—Ä—É—é—â–∞—è)
close(ch)                    // –∑–∞–∫—Ä—ã—Ç–∏–µ

// –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞–∫—Ä—ã—Ç–∏—è
val, ok := <-ch
if !ok {
    // –∫–∞–Ω–∞–ª –∑–∞–∫—Ä—ã—Ç
}

// –ù–µ–±–ª–æ–∫–∏—Ä—É—é—â–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–∏
select {
case ch <- val:              // –æ—Ç–ø—Ä–∞–≤–∫–∞
    // —É—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ
case val := <-ch:            // –ø–æ–ª—É—á–µ–Ω–∏–µ
    // —É—Å–ø–µ—à–Ω–æ –ø–æ–ª—É—á–µ–Ω–æ
case <-time.After(1*time.Second): // timeout
    // —Ç–∞–π–º–∞—É—Ç
default:                     // –µ—Å–ª–∏ –≤—Å–µ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã
    // –Ω–µ–º–µ–¥–ª–µ–Ω–Ω—ã–π –≤–æ–∑–≤—Ä–∞—Ç
}

// –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–µ –∫–∞–Ω–∞–ª—ã
func send(ch chan<- int) { ch <- 42 }      // —Ç–æ–ª—å–∫–æ –æ—Ç–ø—Ä–∞–≤–∫–∞
func recv(ch <-chan int) int { return <-ch } // —Ç–æ–ª—å–∫–æ –ø–æ–ª—É—á–µ–Ω–∏–µ
```

### **üöÄ Concurrency Primitives - –ó–∞–¥–∞—á–∏: 21-25**

#### **Goroutines**

```go
// –ó–∞–ø—É—Å–∫ –≥–æ—Ä—É—Ç–∏–Ω—ã
go func() {
    // —Ä–∞–±–æ—Ç–∞ –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–π –≥–æ—Ä—É—Ç–∏–Ω–µ
}()

// –ê–Ω–æ–Ω–∏–º–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è —Å –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏
for i := 0; i < 10; i++ {
    go func(id int) {  // –≤–∞–∂–Ω–æ: –ø–µ—Ä–µ–¥–∞–µ–º i –∫–∞–∫ –ø–∞—Ä–∞–º–µ—Ç—Ä
        fmt.Println(id)
    }(i)
}
```

#### **sync Package**

```go
import "sync"

// Mutex –¥–ª—è exclusive access
var mu sync.Mutex
mu.Lock()
// –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è —Å–µ–∫—Ü–∏—è
mu.Unlock()

// RWMutex –¥–ª—è —á–∏—Ç–∞—Ç–µ–ª–µ–π/–ø–∏—Å–∞—Ç–µ–ª–µ–π
var rwmu sync.RWMutex
rwmu.RLock()   // –±–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –¥–ª—è —á—Ç–µ–Ω–∏—è
// —á–∏—Ç–∞–µ–º –¥–∞–Ω–Ω—ã–µ
rwmu.RUnlock()

rwmu.Lock()    // —ç–∫—Å–∫–ª—é–∑–∏–≤–Ω–∞—è –±–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –¥–ª—è –∑–∞–ø–∏—Å–∏
// –ø–∏—à–µ–º –¥–∞–Ω–Ω—ã–µ
rwmu.Unlock()

// WaitGroup –¥–ª—è –æ–∂–∏–¥–∞–Ω–∏—è –≥–æ—Ä—É—Ç–∏–Ω
var wg sync.WaitGroup
for i := 0; i < 10; i++ {
    wg.Add(1)
    go func(id int) {
        defer wg.Done()
        // —Ä–∞–±–æ—Ç–∞
    }(i)
}
wg.Wait()  // –∂–¥–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –≤—Å–µ—Ö –≥–æ—Ä—É—Ç–∏–Ω

// Once –¥–ª—è –æ–¥–Ω–æ—Ä–∞–∑–æ–≤–æ–≥–æ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è
var once sync.Once
once.Do(func() {
    // –≤—ã–ø–æ–ª–Ω–∏—Ç—Å—è —Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω —Ä–∞–∑
})
```

#### **sync/atomic Package**

```go
import "sync/atomic"

var counter int64

// –ê—Ç–æ–º–∞—Ä–Ω—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏
atomic.AddInt64(&counter, 1)        // –∏–Ω–∫—Ä–µ–º–µ–Ω—Ç
atomic.LoadInt64(&counter)          // —á—Ç–µ–Ω–∏–µ
atomic.StoreInt64(&counter, 100)    // –∑–∞–ø–∏—Å—å
atomic.SwapInt64(&counter, 200)     // –æ–±–º–µ–Ω
atomic.CompareAndSwapInt64(&counter, 200, 300) // CAS
```

### **‚ùå Error Handling - –û–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –Ω–∞ —Å–æ–±–µ—Å–µ–¥–æ–≤–∞–Ω–∏—è—Ö**

#### **–°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –ø–∞—Ç—Ç–µ—Ä–Ω**

```go
func divide(a, b float64) (float64, error) {
    if b == 0 {
        return 0, errors.New("division by zero")
    }
    return a / b, nil
}

// –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ
result, err := divide(10, 0)
if err != nil {
    log.Printf("Error: %v", err)
    return
}
fmt.Printf("Result: %f", result)
```

#### **Custom Error Types**

```go
type ValidationError struct {
    Field string
    Value interface{}
}

func (e ValidationError) Error() string {
    return fmt.Sprintf("invalid value %v for field %s", e.Value, e.Field)
}

// –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç–∏–ø–∞ –æ—à–∏–±–∫–∏
if ve, ok := err.(*ValidationError); ok {
    fmt.Printf("Validation failed for field: %s", ve.Field)
}
```

#### **Error Wrapping (Go 1.13+)**

```go
import "fmt"

func processFile(filename string) error {
    _, err := os.Open(filename)
    if err != nil {
        return fmt.Errorf("failed to process file %s: %w", filename, err)
    }
    return nil
}

// Unwrapping
if errors.Is(err, os.ErrNotExist) {
    // —Ñ–∞–π–ª –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
}
```

### **üß™ Testing - –ß–∞—Å—Ç–æ —Å–ø—Ä–∞—à–∏–≤–∞—é—Ç**

#### **Unit Tests**

```go
// file_test.go
func TestTwoSum(t *testing.T) {
    nums := []int{2, 7, 11, 15}
    target := 9
    expected := []int{0, 1}
    
    result := twoSum(nums, target)
    
    if !reflect.DeepEqual(result, expected) {
        t.Errorf("Expected %v, got %v", expected, result)
    }
}
```

#### **Table-driven Tests**

```go
func TestIsPalindrome(t *testing.T) {
    tests := []struct {
        name     string
        input    string
        expected bool
    }{
        {"empty string", "", true},
        {"single char", "a", true},
        {"palindrome", "racecar", true},
        {"not palindrome", "hello", false},
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            result := isPalindrome(tt.input)
            if result != tt.expected {
                t.Errorf("isPalindrome(%s) = %v, want %v", 
                    tt.input, result, tt.expected)
            }
        })
    }
}
```

#### **Benchmarks**

```go
func BenchmarkQuickSort(b *testing.B) {
    data := generateRandomSlice(1000)
    
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        // –ö–æ–ø–∏—Ä—É–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è –∫–∞–∂–¥–æ–π –∏—Ç–µ—Ä–∞—Ü–∏–∏
        testData := make([]int, len(data))
        copy(testData, data)
        
        quickSort(testData)
    }
}

// –ó–∞–ø—É—Å–∫: go test -bench=.
```

### **‚è±Ô∏è Big O Notation –∏ Performance**

#### **–í—Ä–µ–º–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å**

```go
// O(1) - –∫–æ–Ω—Å—Ç–∞–Ω—Ç–Ω–æ–µ –≤—Ä–µ–º—è
func getFirst(arr []int) int {
    return arr[0]
}

// O(log n) - –ª–æ–≥–∞—Ä–∏—Ñ–º–∏—á–µ—Å–∫–æ–µ –≤—Ä–µ–º—è
func binarySearch(arr []int, target int) int {
    left, right := 0, len(arr)-1
    for left <= right {
        mid := left + (right-left)/2
        if arr[mid] == target {
            return mid
        } else if arr[mid] < target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    return -1
}

// O(n) - –ª–∏–Ω–µ–π–Ω–æ–µ –≤—Ä–µ–º—è
func linearSearch(arr []int, target int) int {
    for i, val := range arr {
        if val == target {
            return i
        }
    }
    return -1
}

// O(n log n) - –ª–æ–≥–ª–∏–Ω–µ–π–Ω–æ–µ –≤—Ä–µ–º—è
func mergeSort(arr []int) []int {
    if len(arr) <= 1 {
        return arr
    }
    // ... —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è
}

// O(n¬≤) - –∫–≤–∞–¥—Ä–∞—Ç–∏—á–Ω–æ–µ –≤—Ä–µ–º—è
func bubbleSort(arr []int) {
    n := len(arr)
    for i := 0; i < n; i++ {
        for j := 0; j < n-i-1; j++ {
            if arr[j] > arr[j+1] {
                arr[j], arr[j+1] = arr[j+1], arr[j]
            }
        }
    }
}
```

#### **–ü—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å**

```go
// O(1) - –∫–æ–Ω—Å—Ç–∞–Ω—Ç–Ω–∞—è –ø–∞–º—è—Ç—å
func reverse(arr []int) {
    left, right := 0, len(arr)-1
    for left < right {
        arr[left], arr[right] = arr[right], arr[left]
        left++
        right--
    }
}

// O(n) - –ª–∏–Ω–µ–π–Ω–∞—è –ø–∞–º—è—Ç—å
func fibonacci(n int) []int {
    if n <= 0 {
        return []int{}
    }
    fib := make([]int, n)
    fib[0] = 0
    if n > 1 {
        fib[1] = 1
        for i := 2; i < n; i++ {
            fib[i] = fib[i-1] + fib[i-2]
        }
    }
    return fib
}
```

### **‚ú® Go Idioms –∏ Best Practices**

#### **–ò–º–µ–Ω–æ–≤–∞–Ω–∏–µ**

```go
// –•–æ—Ä–æ—à–æ
var userCount int
var isValid bool
func calculateTotal() int

// –ü–ª–æ—Ö–æ
var uc int
var valid bool
func calc() int
```

#### **Zero Values**

```go
var s []int        // nil slice
var m map[int]bool // nil map
var ch chan int    // nil channel

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
s = make([]int, 0)
m = make(map[int]bool)
ch = make(chan int)
```

#### **Early Return**

```go
func process(data []int) error {
    if len(data) == 0 {
        return errors.New("empty data")
    }
    
    if !isValid(data) {
        return errors.New("invalid data")
    }
    
    // –æ—Å–Ω–æ–≤–Ω–∞—è –ª–æ–≥–∏–∫–∞
    return nil
}
```

### **üìö –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Ç–µ–º—ã –¥–ª—è —É–≥–ª—É–±–ª–µ–Ω–Ω–æ–≥–æ –∏–∑—É—á–µ–Ω–∏—è**

1. **üîß –ü—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–µ Go –∫–æ–Ω—Ü–µ–ø—Ü–∏–∏:**
   - Interface composition –∏ embedding
   - Reflection –∏ type assertions
   - Context package –¥–ª—è cancellation
   - Memory model –∏ happens-before

2. **‚ö° Performance optimization:**
   - Escape analysis
   - Memory pooling (sync.Pool)
   - Profiling (pprof)
   - Garbage collector tuning

3. **üîÑ Advanced concurrency:**
   - Pipeline patterns
   - Cancellation –∏ context
   - Rate limiting
   - Circuit breaker pattern

4. **üì¶ –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è –±–∏–±–ª–∏–æ—Ç–µ–∫–∞:**
   - container/* packages (heap, list, ring)
   - encoding/* packages (json, xml, gob)
   - net/* packages –¥–ª—è network programming
   - database/sql –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –ë–î

–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —ç—Ç–æ—Ç —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π —Å–ø—Ä–∞–≤–æ—á–Ω–∏–∫ –¥–ª—è –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∏ –∫ —Å–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–º Go —Å–æ–±–µ—Å–µ–¥–æ–≤–∞–Ω–∏—è–º! üöÄ

---

## –†–µ—à–µ–Ω–∏–µ –∑–∞–¥–∞—á

### –†–µ—à–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏ 1

>[–Ω–∞–∑–∞–¥](#-–ø–æ–¥—Å–∫–∞–∑–∫–∏-–¥–ª—è-–æ—Å–Ω–æ–≤–Ω—ã—Ö-–∑–∞–¥–∞—á)

####  üéØ –†–µ—à–µ–Ω–∏–µ Two Sum

üìä –ê–Ω–∞–ª–∏–∑ –∑–∞–¥–∞—á–∏:
```
–î–∞–Ω–æ: nums = [2, 7, 11, 15], target = 9
–ù–∞–π—Ç–∏: –∏–Ω–¥–µ–∫—Å—ã –¥–≤—É—Ö —á–∏—Å–µ–ª, —Å—É–º–º–∞ –∫–æ—Ç–æ—Ä—ã—Ö —Ä–∞–≤–Ω–∞ target
–†–µ–∑—É–ª—å—Ç–∞—Ç: [0, 1] (nums[0] + nums[1] = 2 + 7 = 9)
```

üö´ –ù–∞–∏–≤–Ω—ã–π –ø–æ–¥—Ö–æ–¥ O(n¬≤):

```go
gofunc twoSumBruteForce(nums []int, target int) []int {
    for i := 0; i < len(nums); i++ {
        for j := i + 1; j < len(nums); j++ {
            if nums[i] + nums[j] == target {
                return []int{i, j}
            }
        }
    }
    return nil
}
```

*"–ò—Å–ø–æ–ª—å–∑—É—é HashMap –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –ø—Ä–æ–π–¥–µ–Ω–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤. –ó–∞ –æ–¥–∏–Ω –ø—Ä–æ—Ö–æ–¥ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —á–∏—Å–ª–∞ X –∏—â—É –¥–æ–ø–æ–ª–Ω–µ–Ω–∏–µ Y=target-X –≤ map. –ï—Å–ª–∏ –Ω–∞—à–µ–ª - –≤–æ–∑–≤—Ä–∞—â–∞—é –ø–∞—Ä—É, –µ—Å–ª–∏ –Ω–µ—Ç - —Å–æ—Ö—Ä–∞–Ω—è—é X. –°–ª–æ–∂–Ω–æ—Å—Ç—å O(n) –≤—Ä–µ–º—è, O(n) –ø–∞–º—è—Ç—å - –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ –¥–ª—è —ç—Ç–æ–π –∑–∞–¥–∞—á–∏."*

üéØ –û–±—ä—è—Å–Ω–µ–Ω–∏–µ —Ä–µ—à–µ–Ω–∏—è:

üß† –õ–æ–≥–∏–∫–∞ HashMap –ø–æ–¥—Ö–æ–¥–∞:

1. üîÑ –û–¥–∏–Ω –ø—Ä–æ—Ö–æ–¥ - –∏–¥–µ–º –ø–æ –º–∞—Å—Å–∏–≤—É —Å–ª–µ–≤–∞ –Ω–∞–ø—Ä–∞–≤–æ
2. üßÆ –í—ã—á–∏—Å–ª—è–µ–º –¥–æ–ø–æ–ª–Ω–µ–Ω–∏–µ - complement = target - current
3. üîç –ü—Ä–æ–≤–µ—Ä—è–µ–º HashMap - –∏—Å–∫–∞–ª–∏ –ª–∏ –º—ã —ç—Ç–æ –¥–æ–ø–æ–ª–Ω–µ–Ω–∏–µ —Ä–∞–Ω—å—à–µ?
4. ‚úÖ –ï—Å–ª–∏ –Ω–∞—à–ª–∏ - –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –ø–∞—Ä—É –∏–Ω–¥–µ–∫—Å–æ–≤
5. üíæ –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏ - —Å–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–µ–∫—É—â–∏–π —ç–ª–µ–º–µ–Ω—Ç –≤ map

üîë –ö–ª—é—á–µ–≤—ã–µ –º–æ–º–µ–Ω—Ç—ã:

- –ü—Ä–æ–≤–µ—Ä—è–µ–º –ü–ï–†–ï–î –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ–º - –∏–∑–±–µ–≥–∞–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –æ–¥–Ω–æ–≥–æ –∏–Ω–¥–µ–∫—Å–∞ –¥–≤–∞–∂–¥—ã
- HashMap –¥–∞–µ—Ç O(1) - –º–≥–Ω–æ–≤–µ–Ω–Ω—ã–π –ø–æ–∏—Å–∫ –¥–æ–ø–æ–ª–Ω–µ–Ω–∏—è
- –†–∞–±–æ—Ç–∞–µ—Ç —Å –¥—É–±–ª–∏–∫–∞—Ç–∞–º–∏ - –ø—Ä–∞–≤–∏–ª—å–Ω–æ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç [3,3], target=6

```go
package main

import (
    "fmt"
    "testing"
)

// ‚úÖ –û–ü–¢–ò–ú–ê–õ–¨–ù–û–ï –†–ï–®–ï–ù–ò–ï - HashMap –ø–æ–¥—Ö–æ–¥
func twoSum(nums []int, target int) []int {
    // üó∫Ô∏è Map –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è: –∑–Ω–∞—á–µ–Ω–∏–µ -> –∏–Ω–¥–µ–∫—Å
    seen := make(map[int]int)
    
    // üîÑ –û–¥–∏–Ω –ø—Ä–æ—Ö–æ–¥ –ø–æ –º–∞—Å—Å–∏–≤—É
    for i, num := range nums {
        // üéØ –ò—â–µ–º –¥–æ–ø–æ–ª–Ω–µ–Ω–∏–µ –¥–æ target
        complement := target - num
        
        // üîç –ü—Ä–æ–≤–µ—Ä—è–µ–º, –≤–∏–¥–µ–ª–∏ –ª–∏ –º—ã complement —Ä–∞–Ω—å—à–µ
        if index, exists := seen[complement]; exists {
            // ‚úÖ –ù–∞–π–¥–µ–Ω–∞ –ø–∞—Ä–∞! –í–æ–∑–≤—Ä–∞—â–∞–µ–º –∏–Ω–¥–µ–∫—Å—ã
            return []int{index, i}
        }
        
        // üíæ –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–µ–∫—É—â–∏–π —ç–ª–µ–º–µ–Ω—Ç –¥–ª—è –±—É–¥—É—â–∏—Ö –ø–æ–∏—Å–∫–æ–≤
        seen[num] = i
    }
    
    // ‚ùå –ü–∞—Ä–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ (–ø–æ —É—Å–ª–æ–≤–∏—é –≤—Å–µ–≥–¥–∞ –µ—Å—Ç—å —Ä–µ—à–µ–Ω–∏–µ)
    return nil
}
```

```bash
// üí° –û–ë–™–Ø–°–ù–ï–ù–ò–ï –ê–õ–ì–û–†–ò–¢–ú–ê
/*
üéØ –ö–õ–Æ–ß–ï–í–ê–Ø –ò–î–ï–Ø HashMap —Ä–µ—à–µ–Ω–∏—è:

1. üîÑ –ü—Ä–æ—Ö–æ–¥–∏–º –º–∞—Å—Å–∏–≤ –û–î–ò–ù —Ä–∞–∑ (O(n))
2. üßÆ –î–ª—è –∫–∞–∂–¥–æ–≥–æ —á–∏—Å–ª–∞ X –≤—ã—á–∏—Å–ª—è–µ–º –¥–æ–ø–æ–ª–Ω–µ–Ω–∏–µ: Y = target - X
3. üîç –ü—Ä–æ–≤–µ—Ä—è–µ–º, –≤—Å—Ç—Ä–µ—á–∞–ª–∏ –ª–∏ –º—ã Y —Ä–∞–Ω—å—à–µ –≤ HashMap
4. ‚úÖ –ï—Å–ª–∏ –≤—Å—Ç—Ä–µ—á–∞–ª–∏ - –Ω–∞—à–ª–∏ –ø–∞—Ä—É! –í–æ–∑–≤—Ä–∞—â–∞–µ–º –∏–Ω–¥–µ–∫—Å—ã
5. üíæ –ï—Å–ª–∏ –Ω–µ –≤—Å—Ç—Ä–µ—á–∞–ª–∏ - —Å–æ—Ö—Ä–∞–Ω—è–µ–º X –≤ HashMap

üîë –ü–û–ß–ï–ú–£ –≠–¢–û –†–ê–ë–û–¢–ê–ï–¢:
- –ï—Å–ª–∏ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ø–∞—Ä–∞ (i,j) –≥–¥–µ nums[i] + nums[j] = target
- –¢–æ –∫–æ–≥–¥–∞ –º—ã –¥–æ–π–¥–µ–º –¥–æ j, –º—ã —É–∂–µ —Å–æ—Ö—Ä–∞–Ω–∏–ª–∏ nums[i] –≤ map
- complement = target - nums[j] = target - nums[j] = nums[i]
- –ü–æ—ç—Ç–æ–º—É –º—ã –Ω–∞–π–¥–µ–º nums[i] –≤ map –∏ –≤–µ—Ä–Ω–µ–º –ø–∞—Ä—É (i,j)

‚ö†Ô∏è –í–ê–ñ–ù–´–ï –î–ï–¢–ê–õ–ò:
- –ü—Ä–æ–≤–µ—Ä—è–µ–º map –ü–ï–†–ï–î –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ–º (–∏–∑–±–µ–≥–∞–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –æ–¥–Ω–æ–≥–æ –∏–Ω–¥–µ–∫—Å–∞ –¥–≤–∞–∂–¥—ã)
- HashMap –¥–∞–µ—Ç O(1) —Å—Ä–µ–¥–Ω–µ–µ –≤—Ä–µ–º—è –¥–æ—Å—Ç—É–ø–∞
- –í —Ö—É–¥—à–µ–º —Å–ª—É—á–∞–µ (–≤—Å–µ –∫–æ–ª–ª–∏–∑–∏–∏) –º–æ–∂–µ—Ç –±—ã—Ç—å O(n), –Ω–æ —ç—Ç–æ –∫—Ä–∞–π–Ω–µ —Ä–µ–¥–∫–æ

üé™ –ì–†–ê–ù–ò–ß–ù–´–ï –°–õ–£–ß–ê–ò:
- –î—É–±–ª–∏–∫–∞—Ç—ã: [3,3], target=6 ‚Üí –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ –æ–±—Ä–∞–±–æ—Ç–∞–µ—Ç—Å—è
- –û—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–µ —á–∏—Å–ª–∞: —Ä–∞–±–æ—Ç–∞–µ—Ç –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π  
- –ë–æ–ª—å—à–∏–µ —á–∏—Å–ª–∞: –æ–≥—Ä–∞–Ω–∏—á–µ–Ω—ã —Ç–æ–ª—å–∫–æ –ø–∞–º—è—Ç—å—é
- –û–¥–∏–Ω —ç–ª–µ–º–µ–Ω—Ç: –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å —Ä–µ—à–µ–Ω–∏—è –ø–æ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—é
*/
```

### –†–µ—à–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏ 2

>[–Ω–∞–∑–∞–¥](#-–ø–æ–¥—Å–∫–∞–∑–∫–∏-–¥–ª—è-–æ—Å–Ω–æ–≤–Ω—ã—Ö-–∑–∞–¥–∞—á)

#### üéØ –†–µ—à–µ–Ω–∏–µ Reverse Linked List

üìä –ê–Ω–∞–ª–∏–∑ –∑–∞–¥–∞—á–∏:

```
–î–∞–Ω–æ: 1 -> 2 -> 3 -> 4 -> 5 -> NULL
–†–µ–∑—É–ª—å—Ç–∞—Ç: 5 -> 4 -> 3 -> 2 -> 1 -> NULL

–ú–µ–Ω—è–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –≤—Å–µ—Ö —Å—Ç—Ä–µ–ª–æ–∫!
```

üö´ –ù–∞–∏–≤–Ω—ã–π –ø–æ–¥—Ö–æ–¥ O(n¬≤):

```go
func reverseListArray(head *ListNode) *ListNode {
    // –°–æ–±–∏—Ä–∞–µ–º –≤—Å–µ –∑–Ω–∞—á–µ–Ω–∏—è –≤ –º–∞—Å—Å–∏–≤
    var values []int
    for curr := head; curr != nil; curr = curr.Next {
        values = append(values, curr.Val)
    }
    
    // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π —Å–ø–∏—Å–æ–∫ –≤ –æ–±—Ä–∞—Ç–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ
    // O(n) –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–π –ø–∞–º—è—Ç–∏!
}
```

*"–ò—Å–ø–æ–ª—å–∑—É—é –∏—Ç–µ—Ä–∞—Ç–∏–≤–Ω—ã–π –ø–æ–¥—Ö–æ–¥ —Å —Ç—Ä–µ–º—è —É–∫–∞–∑–∞—Ç–µ–ª—è–º–∏. –ö–ª—é—á–µ–≤–æ–π –º–æ–º–µ–Ω—Ç - —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å —Å–ª–µ–¥—É—é—â–∏–π —É–∑–µ–ª –ø–µ—Ä–µ–¥ –∏–∑–º–µ–Ω–µ–Ω–∏–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Å–≤—è–∑–∏, –∏–Ω–∞—á–µ –ø–æ—Ç–µ—Ä—è–µ–º –æ—Å—Ç–∞–ª—å–Ω—É—é —á–∞—Å—Ç—å —Å–ø–∏—Å–∫–∞. O(n) –≤—Ä–µ–º—è, O(1) –ø–∞–º—è—Ç—å - –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ. –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ —Ç–æ–∂–µ –≤–æ–∑–º–æ–∂–Ω–æ, –Ω–æ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç O(n) –ø–∞–º—è—Ç–∏ —Å—Ç–µ–∫–∞."*

üéØ –û–±—ä—è—Å–Ω–µ–Ω–∏–µ —Ä–µ—à–µ–Ω–∏—è:

üß† –õ–æ–≥–∏–∫–∞ –∏—Ç–µ—Ä–∞—Ç–∏–≤–Ω–æ–≥–æ –ø–æ–¥—Ö–æ–¥–∞:

1. üîß –¢—Ä–∏ —É–∫–∞–∑–∞—Ç–µ–ª—è: prev=nil, curr=head, next
2. üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Å–ª–µ–¥—É—é—â–∏–π: next = curr.Next (–ö–†–ò–¢–ò–ß–ù–û!)
3. üîÑ –û–±—Ä–∞—Ç–∏—Ç—å —Å—Ç—Ä–µ–ª–∫—É: curr.Next = prev
4. ‚û°Ô∏è –°–¥–≤–∏–Ω—É—Ç—å —É–∫–∞–∑–∞—Ç–µ–ª–∏: prev=curr, curr=next
5. üîÑ –ü–æ–≤—Ç–æ—Ä–∏—Ç—å –ø–æ–∫–∞ curr != nil

```go
package main

import (
    "fmt"
    "testing"
)

// üìã –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã ListNode
type ListNode struct {
    Val  int
    Next *ListNode
}

// ‚úÖ –û–ü–¢–ò–ú–ê–õ–¨–ù–û–ï –†–ï–®–ï–ù–ò–ï - –ò—Ç–µ—Ä–∞—Ç–∏–≤–Ω—ã–π –ø–æ–¥—Ö–æ–¥
func reverseList(head *ListNode) *ListNode {
    // üîß –¢—Ä–∏ —É–∫–∞–∑–∞—Ç–µ–ª—è –¥–ª—è –ø–µ—Ä–µ–≤–æ—Ä–æ—Ç–∞
    var prev *ListNode = nil  // –ü—Ä–µ–¥—ã–¥—É—â–∏–π —É–∑–µ–ª (–∏–∑–Ω–∞—á–∞–ª—å–Ω–æ nil)
    curr := head              // –¢–µ–∫—É—â–∏–π —É–∑–µ–ª
    
    // üîÑ –ü—Ä–æ—Ö–æ–¥–∏–º –ø–æ —Å–ø–∏—Å–∫—É –∏ –º–µ–Ω—è–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å—Ç—Ä–µ–ª–æ–∫
    for curr != nil {
        // üíæ –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–ª–µ–¥—É—é—â–∏–π —É–∑–µ–ª (–≤–∞–∂–Ω–æ!)
        next := curr.Next
        
        // üîÑ –ú–µ–Ω—è–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å—Ç—Ä–µ–ª–∫–∏
        curr.Next = prev
        
        // ‚û°Ô∏è –î–≤–∏–≥–∞–µ–º —É–∫–∞–∑–∞—Ç–µ–ª–∏ –≤–ø–µ—Ä–µ–¥
        prev = curr
        curr = next
    }
    
    // üéØ prev —Ç–µ–ø–µ—Ä—å —É–∫–∞–∑—ã–≤–∞–µ—Ç –Ω–∞ –Ω–æ–≤—É—é –≥–æ–ª–æ–≤—É
    return prev
}
```

```bash
// üìö –û–ë–£–ß–ê–Æ–©–ò–ï –ö–û–ú–ú–ï–ù–¢–ê–†–ò–ò
/*
üéØ –ê–õ–ì–û–†–ò–¢–ú –∏—Ç–µ—Ä–∞—Ç–∏–≤–Ω–æ–≥–æ –ø–µ—Ä–µ–≤–æ—Ä–æ—Ç–∞:

1. üîß –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º —Ç—Ä–∏ —É–∫–∞–∑–∞—Ç–µ–ª—è:
   - prev = nil (–ø—Ä–µ–¥—ã–¥—É—â–∏–π —É–∑–µ–ª)
   - curr = head (—Ç–µ–∫—É—â–∏–π —É–∑–µ–ª)
   - next (—Å–ª–µ–¥—É—é—â–∏–π —É–∑–µ–ª, –±—É–¥–µ–º –≤—ã—á–∏—Å–ª—è—Ç—å)

2. üîÑ –î–ª—è –∫–∞–∂–¥–æ–≥–æ —É–∑–ª–∞:
   a) üíæ –°–æ—Ö—Ä–∞–Ω—è–µ–º next = curr.Next (–í–ê–ñ–ù–û!)
   b) üîÑ –ú–µ–Ω—è–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ: curr.Next = prev
   c) ‚û°Ô∏è –î–≤–∏–≥–∞–µ–º —É–∫–∞–∑–∞—Ç–µ–ª–∏: prev = curr, curr = next

3. üéØ –í –∫–æ–Ω—Ü–µ prev —É–∫–∞–∑—ã–≤–∞–µ—Ç –Ω–∞ –Ω–æ–≤—É—é –≥–æ–ª–æ–≤—É

üîë –ö–õ–Æ–ß–ï–í–´–ï –ú–û–ú–ï–ù–¢–´:
- –û–ë–Ø–ó–ê–¢–ï–õ–¨–ù–û —Å–æ—Ö—Ä–∞–Ω—è–µ–º next –ø–µ—Ä–µ–¥ –∏–∑–º–µ–Ω–µ–Ω–∏–µ–º curr.Next
- prev –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å nil (–Ω–æ–≤—ã–π —Ö–≤–æ—Å—Ç)
- –¶–∏–∫–ª –ø—Ä–æ–¥–æ–ª–∂–∞–µ—Ç—Å—è –ø–æ–∫–∞ curr != nil
- –í–æ–∑–≤—Ä–∞—â–∞–µ–º prev (–Ω–æ–≤–∞—è –≥–æ–ª–æ–≤–∞)

‚ö†Ô∏è –ì–†–ê–ù–ò–ß–ù–´–ï –°–õ–£–ß–ê–ò:
- nil —Å–ø–∏—Å–æ–∫ ‚Üí nil
- –û–¥–∏–Ω —ç–ª–µ–º–µ–Ω—Ç ‚Üí —Ç–æ—Ç –∂–µ —ç–ª–µ–º–µ–Ω—Ç
- –î–≤–∞ —ç–ª–µ–º–µ–Ω—Ç–∞ ‚Üí –ø–æ–º–µ–Ω—è—Ç—å –º–µ—Å—Ç–∞–º–∏

üí° –°–†–ê–í–ù–ï–ù–ò–ï –ü–û–î–•–û–î–û–í:
- –ò—Ç–µ—Ä–∞—Ç–∏–≤–Ω—ã–π: O(1) –ø–∞–º—è—Ç—å, –ª–µ–≥–∫–æ –ø–æ–Ω—è—Ç—å
- –†–µ–∫—É—Ä—Å–∏–≤–Ω—ã–π: O(n) –ø–∞–º—è—Ç—å, —ç–ª–µ–≥–∞–Ω—Ç–Ω–æ
- –°—Ç–µ–∫: O(n) –ø–∞–º—è—Ç—å, –Ω–∞–≥–ª—è–¥–Ω–æ –Ω–æ –Ω–µ—ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ

üé≠ –í–ê–†–ò–ê–¶–ò–ò –ó–ê–î–ê–ß–ò:
- –ü–µ—Ä–µ–≤–æ—Ä–æ—Ç –ø–µ—Ä–≤—ã—Ö k —ç–ª–µ–º–µ–Ω—Ç–æ–≤
- –ü–µ—Ä–µ–≤–æ—Ä–æ—Ç –≤ –≥—Ä—É–ø–ø–∞—Ö –ø–æ k
- –ü–µ—Ä–µ–≤–æ—Ä–æ—Ç –º–µ–∂–¥—É –ø–æ–∑–∏—Ü–∏—è–º–∏ m –∏ n
- –ü–µ—Ä–µ–≤–æ—Ä–æ—Ç —á–µ—Ç–Ω—ã—Ö/–Ω–µ—á–µ—Ç–Ω—ã—Ö –ø–æ–∑–∏—Ü–∏–π
*/
```

### –†–µ—à–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏ 3

>[–Ω–∞–∑–∞–¥](#-–ø–æ–¥—Å–∫–∞–∑–∫–∏-–¥–ª—è-–æ—Å–Ω–æ–≤–Ω—ã—Ö-–∑–∞–¥–∞—á)

#### üéØ –†–µ—à–µ–Ω–∏–µ Valid Palindrome

üìä –ê–Ω–∞–ª–∏–∑ –∑–∞–¥–∞—á–∏:

```
–î–∞–Ω–æ: "A man, a plan, a canal: Panama"
–ù–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–∞—è: "amanaplanacanalpanama"
–†–µ–∑—É–ª—å—Ç–∞—Ç: true (—á–∏—Ç–∞–µ—Ç—Å—è –æ–¥–∏–Ω–∞–∫–æ–≤–æ –≤ –æ–±–µ —Å—Ç–æ—Ä–æ–Ω—ã)
```

üö´ –ù–∞–∏–≤–Ω—ã–π –ø–æ–¥—Ö–æ–¥ O(n¬≤):

```go
func isPalindromeNaive(s string) bool {
    // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—É—é —Å—Ç—Ä–æ–∫—É —Ç–æ–ª—å–∫–æ —Å alphanumeric —Å–∏–º–≤–æ–ª–∞–º–∏
    var cleaned strings.Builder
    for _, r := range s {
        if unicode.IsLetter(r) || unicode.IsDigit(r) {
            cleaned.WriteRune(unicode.ToLower(r))
        }
    }
    str := cleaned.String()
    
    // –°—Ä–∞–≤–Ω–∏–≤–∞–µ–º —Å –æ–±—Ä–∞—â–µ–Ω–Ω–æ–π —Å—Ç—Ä–æ–∫–æ–π
    for i := 0; i < len(str)/2; i++ {
        if str[i] != str[len(str)-1-i] {
            return false
        }
    }
    return true
}
```

*"–ò—Å–ø–æ–ª—å–∑—É—é two pointers —Å –∫–æ–Ω—Ü–æ–≤ —Å—Ç—Ä–æ–∫–∏. –ü—Ä–æ–ø—É—Å–∫–∞—é –Ω–µ-–±—É–∫–≤–µ–Ω–Ω–æ-—Ü–∏—Ñ—Ä–æ–≤—ã–µ —Å–∏–º–≤–æ–ª—ã, —Å—Ä–∞–≤–Ω–∏–≤–∞—é –æ—Å—Ç–∞–≤—à–∏–µ—Å—è –≤ –Ω–∏–∂–Ω–µ–º —Ä–µ–≥–∏—Å—Ç—Ä–µ. –£–∫–∞–∑–∞—Ç–µ–ª–∏ –¥–≤–∏–∂—É—Ç—Å—è –∫ —Ü–µ–Ω—Ç—Ä—É –ø–æ–∫–∞ –Ω–µ –≤—Å—Ç—Ä–µ—Ç—è—Ç—Å—è. O(n) –≤—Ä–µ–º—è, O(1) –ø–∞–º—è—Ç—å - –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ!"*

üéØ –û–±—ä—è—Å–Ω–µ–Ω–∏–µ —Ä–µ—à–µ–Ω–∏—è:

üß† –õ–æ–≥–∏–∫–∞ Two Pointers –ø–æ–¥—Ö–æ–¥–∞:

1. üë• –î–≤–∞ —É–∫–∞–∑–∞—Ç–µ–ª—è - left=0, right=len-1
2. ‚è≠Ô∏è –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –º—É—Å–æ—Ä —Å–ª–µ–≤–∞ - –Ω–µ-alphanumeric —Å–∏–º–≤–æ–ª—ã
3. ‚èÆÔ∏è –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –º—É—Å–æ—Ä —Å–ø—Ä–∞–≤–∞ - –Ω–µ-alphanumeric —Å–∏–º–≤–æ–ª—ã
4. üîç –°—Ä–∞–≤–Ω–∏–≤–∞–µ–º —Å–∏–º–≤–æ–ª—ã - –≤ –Ω–∏–∂–Ω–µ–º —Ä–µ–≥–∏—Å—Ç—Ä–µ
5. ‚û°Ô∏è –î–≤–∏–≥–∞–µ–º —É–∫–∞–∑–∞—Ç–µ–ª–∏ - –∫ —Ü–µ–Ω—Ç—Ä—É —Å—Ç—Ä–æ–∫–∏

```go
package main

import (
    "fmt"
    "strings"
    "testing"
    "unicode"
)

// ‚úÖ –û–ü–¢–ò–ú–ê–õ–¨–ù–û–ï –†–ï–®–ï–ù–ò–ï - Two Pointers
func isPalindrome(s string) bool {
    // üéØ –î–≤–∞ —É–∫–∞–∑–∞—Ç–µ–ª—è: –Ω–∞—á–∞–ª–æ –∏ –∫–æ–Ω–µ—Ü
    left, right := 0, len(s)-1
    
    for left < right {
        // ‚è≠Ô∏è –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –Ω–µ-alphanumeric —Å–∏–º–≤–æ–ª—ã —Å–ª–µ–≤–∞
        for left < right && !isAlphanumeric(s[left]) {
            left++
        }
        
        // ‚èÆÔ∏è –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –Ω–µ-alphanumeric —Å–∏–º–≤–æ–ª—ã —Å–ø—Ä–∞–≤–∞  
        for left < right && !isAlphanumeric(s[right]) {
            right--
        }
        
        // üîç –°—Ä–∞–≤–Ω–∏–≤–∞–µ–º —Å–∏–º–≤–æ–ª—ã (–ø—Ä–∏–≤–æ–¥–∏–º –∫ –Ω–∏–∂–Ω–µ–º—É —Ä–µ–≥–∏—Å—Ç—Ä—É)
        if toLowerCase(s[left]) != toLowerCase(s[right]) {
            return false
        }
        
        // ‚û°Ô∏è –î–≤–∏–≥–∞–µ–º —É–∫–∞–∑–∞—Ç–µ–ª–∏
        left++
        right--
    }
    
    return true
}

// üîß Helper —Ñ—É–Ω–∫—Ü–∏—è: –ø—Ä–æ–≤–µ—Ä–∫–∞ alphanumeric —Å–∏–º–≤–æ–ª–∞
func isAlphanumeric(b byte) bool {
    return (b >= 'a' && b <= 'z') || 
           (b >= 'A' && b <= 'Z') || 
           (b >= '0' && b <= '9')
}

// üîß Helper —Ñ—É–Ω–∫—Ü–∏—è: –ø—Ä–∏–≤–µ–¥–µ–Ω–∏–µ –∫ –Ω–∏–∂–Ω–µ–º—É —Ä–µ–≥–∏—Å—Ç—Ä—É
func toLowerCase(b byte) byte {
    if b >= 'A' && b <= 'Z' {
        return b + ('a' - 'A')
    }
    return b
}
```

```bash
// üìö –û–ë–£–ß–ê–Æ–©–ò–ï –ö–û–ú–ú–ï–ù–¢–ê–†–ò–ò
/*
üéØ –ê–õ–ì–û–†–ò–¢–ú Two Pointers –¥–ª—è –ø–∞–ª–∏–Ω–¥—Ä–æ–º–∞:

1. üë• –°—Ç–∞–≤–∏–º –¥–≤–∞ —É–∫–∞–∑–∞—Ç–µ–ª—è: left=0, right=len-1
2. üîÑ –ü–æ–∫–∞ left < right:
   a) ‚è≠Ô∏è –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –Ω–µ-alphanumeric —Å–∏–º–≤–æ–ª—ã —Å–ª–µ–≤–∞
   b) ‚èÆÔ∏è –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –Ω–µ-alphanumeric —Å–∏–º–≤–æ–ª—ã —Å–ø—Ä–∞–≤–∞  
   c) üîç –°—Ä–∞–≤–Ω–∏–≤–∞–µ–º —Å–∏–º–≤–æ–ª—ã –≤ –Ω–∏–∂–Ω–µ–º —Ä–µ–≥–∏—Å—Ç—Ä–µ
   d) ‚ùå –ï—Å–ª–∏ –Ω–µ —Ä–∞–≤–Ω—ã ‚Üí –ù–ï –ø–∞–ª–∏–Ω–¥—Ä–æ–º
   e) ‚û°Ô∏è –°–¥–≤–∏–≥–∞–µ–º —É–∫–∞–∑–∞—Ç–µ–ª–∏: left++, right--
3. ‚úÖ –ï—Å–ª–∏ –¥–æ—à–ª–∏ –¥–æ –∫–æ–Ω—Ü–∞ ‚Üí –ü–ê–õ–ò–ù–î–†–û–ú

üîë –ö–õ–Æ–ß–ï–í–´–ï –ú–û–ú–ï–ù–¢–´:
- –£—Å–ª–æ–≤–∏–µ left < right –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ—Ç –ø–µ—Ä–µ—Ö–æ–¥ —É–∫–∞–∑–∞—Ç–µ–ª–µ–π
- –ü—Ä–æ–ø—É—Å–∫ —Å–∏–º–≤–æ–ª–æ–≤ –¥–µ–ª–∞–µ–º –ü–ï–†–ï–î —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ–º
- toLowerCase –¥–ª—è case-insensitive —Å—Ä–∞–≤–Ω–µ–Ω–∏—è
- isAlphanumeric –¥–ª—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ –Ω–µ–Ω—É–∂–Ω—ã—Ö —Å–∏–º–≤–æ–ª–æ–≤

‚ö†Ô∏è –ì–†–ê–ù–ò–ß–ù–´–ï –°–õ–£–ß–ê–ò:
- –ü—É—Å—Ç–∞—è —Å—Ç—Ä–æ–∫–∞ ‚Üí true (–ø–æ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—é)
- –û–¥–∏–Ω —Å–∏–º–≤–æ–ª ‚Üí true (–≤—Å–µ–≥–¥–∞ –ø–∞–ª–∏–Ω–¥—Ä–æ–º)
- –¢–æ–ª—å–∫–æ –ø—É–Ω–∫—Ç—É–∞—Ü–∏—è ‚Üí true (–Ω–µ—Ç —Å–∏–º–≤–æ–ª–æ–≤ –¥–ª—è —Å—Ä–∞–≤–Ω–µ–Ω–∏—è)
- Unicode ‚Üí –Ω—É–∂–Ω–∞ —Å–ø–µ—Ü–∏–∞–ª—å–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞

üí° –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–ò:
- –ú–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –±–∏—Ç–æ–≤—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ –¥–ª—è toLowerCase
- Lookup table –¥–ª—è isAlphanumeric (256 —ç–ª–µ–º–µ–Ω—Ç–æ–≤)
- Simd –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ –¥–ª—è –º–∞—Å—Å–æ–≤—ã—Ö –æ–ø–µ—Ä–∞—Ü–∏–π

üé≠ –í–ê–†–ò–ê–¶–ò–ò –ó–ê–î–ê–ß–ò:
- –ü–∞–ª–∏–Ω–¥—Ä–æ–º —á–∏—Å–ª–∞ (–±–µ–∑ —Å—Ç—Ä–æ–∫)
- –ü–∞–ª–∏–Ω–¥—Ä–æ–º —Å –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ–º –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã—Ö —Å–∏–º–≤–æ–ª–æ–≤
- –ù–∞–∏–±–æ–ª—å—à–∏–π –ø–∞–ª–∏–Ω–¥—Ä–æ–º–Ω—ã–π substring
- –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–∞–ª–∏–Ω–¥—Ä–æ–º–∞ —Å–≤—è–∑–∞–Ω–Ω–æ–≥–æ —Å–ø–∏—Å–∫–∞
*/
```

### –†–µ—à–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏ 4

>[–Ω–∞–∑–∞–¥](#-–ø–æ–¥—Å–∫–∞–∑–∫–∏-–¥–ª—è-–æ—Å–Ω–æ–≤–Ω—ã—Ö-–∑–∞–¥–∞—á)

#### üéØ –†–µ—à–µ–Ω–∏–µ Longest Substring Without

üìä –ê–Ω–∞–ª–∏–∑ –∑–∞–¥–∞—á–∏:

```
–î–∞–Ω–æ: "abcabcbb"
–ü–æ–¥—Å—Ç—Ä–æ–∫–∏ –±–µ–∑ –ø–æ–≤—Ç–æ—Ä–µ–Ω–∏–π: "abc", "bca", "cab", "abc", "bc", "cb", "b"
–°–∞–º–∞—è –¥–ª–∏–Ω–Ω–∞—è: "abc" (–¥–ª–∏–Ω–∞ 3)
–†–µ–∑—É–ª—å—Ç–∞—Ç: 3
```

üö´ –ù–∞–∏–≤–Ω—ã–π –ø–æ–¥—Ö–æ–¥ O(n¬≤):

```go
func lengthOfLongestSubstringNaive(s string) int {
    n := len(s)
    maxLen := 0
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤—Å–µ –≤–æ–∑–º–æ–∂–Ω—ã–µ –ø–æ–¥—Å—Ç—Ä–æ–∫–∏
    for i := 0; i < n; i++ {
        for j := i; j < n; j++ {
            if hasUniqueChars(s, i, j) {
                maxLen = max(maxLen, j-i+1)
            }
        }
    }
    return maxLen
}
```

*"–ò—Å–ø–æ–ª—å–∑—É—é sliding window pattern —Å HashMap. –†–∞—Å—à–∏—Ä—è—é –æ–∫–Ω–æ –≤–ø—Ä–∞–≤–æ –¥–æ–±–∞–≤–ª—è—è —Å–∏–º–≤–æ–ª—ã, –ø—Ä–∏ –¥—É–±–ª–∏–∫–∞—Ç–µ —Å–∂–∏–º–∞—é —Å–ª–µ–≤–∞. –ö–ª—é—á–µ–≤–æ–π –º–æ–º–µ–Ω—Ç - –ø—Ä–æ–≤–µ—Ä—è—é, —á—Ç–æ –¥—É–±–ª–∏–∫–∞—Ç –∏–º–µ–Ω–Ω–æ –≤ —Ç–µ–∫—É—â–µ–º –æ–∫–Ω–µ (lastIndex >= left), –∏–Ω–∞—á–µ left –º–æ–∂–µ—Ç –æ—Ç–∫–∞—Ç–∏—Ç—å—Å—è –Ω–∞–∑–∞–¥. O(n) –≤—Ä–µ–º—è, O(k) –ø–∞–º—è—Ç—å –≥–¥–µ k - —Ä–∞–∑–º–µ—Ä –∞–ª—Ñ–∞–≤–∏—Ç–∞."*

üéØ –û–±—ä—è—Å–Ω–µ–Ω–∏–µ —Ä–µ—à–µ–Ω–∏—è:
üß† –õ–æ–≥–∏–∫–∞ Sliding Window –ø–æ–¥—Ö–æ–¥–∞:

1. ü™ü –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º –æ–∫–Ω–æ [left, right] –±–µ–∑ –¥—É–±–ª–∏–∫–∞—Ç–æ–≤
2. üó∫Ô∏è HashMap —Ö—Ä–∞–Ω–∏—Ç —Å–∏–º–≤–æ–ª ‚Üí –ø–æ—Å–ª–µ–¥–Ω—è—è_–ø–æ–∑–∏—Ü–∏—è
3. üîÑ –î–ª—è –∫–∞–∂–¥–æ–≥–æ —Å–∏–º–≤–æ–ª–∞:
    - –ï—Å–ª–∏ –¥—É–±–ª–∏–∫–∞—Ç –≤ –æ–∫–Ω–µ ‚Üí —Å–∂–∏–º–∞–µ–º —Å–ª–µ–≤–∞
    - –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é —Å–∏–º–≤–æ–ª–∞
    - –û–±–Ω–æ–≤–ª—è–µ–º –º–∞–∫—Å–∏–º–∞–ª—å–Ω—É—é –¥–ª–∏–Ω—É

```go
package main

import (
    "fmt"
    "testing"
)

// ‚úÖ –û–ü–¢–ò–ú–ê–õ–¨–ù–û–ï –†–ï–®–ï–ù–ò–ï - Sliding Window + HashMap
func lengthOfLongestSubstring(s string) int {
    if len(s) == 0 {
        return 0
    }
    
    // üó∫Ô∏è Map –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è: —Å–∏–º–≤–æ–ª -> –ø–æ—Å–ª–µ–¥–Ω—è—è –ø–æ–∑–∏—Ü–∏—è
    charIndex := make(map[byte]int)
    
    maxLen := 0
    left := 0  // üëà –õ–µ–≤–∞—è –≥—Ä–∞–Ω–∏—Ü–∞ –æ–∫–Ω–∞
    
    // üîÑ –†–∞—Å—à–∏—Ä—è–µ–º –æ–∫–Ω–æ –≤–ø—Ä–∞–≤–æ
    for right := 0; right < len(s); right++ {
        char := s[right]
        
        // üîç –ï—Å–ª–∏ —Å–∏–º–≤–æ–ª —É–∂–µ –≤—Å—Ç—Ä–µ—á–∞–ª—Å—è –∏ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ —Ç–µ–∫—É—â–µ–º –æ–∫–Ω–µ
        if lastIndex, exists := charIndex[char]; exists && lastIndex >= left {
            // üìè –°–∂–∏–º–∞–µ–º –æ–∫–Ω–æ —Å–ª–µ–≤–∞ (—É–±–∏—Ä–∞–µ–º –¥—É–±–ª–∏–∫–∞—Ç)
            left = lastIndex + 1
        }
        
        // üíæ –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é —Å–∏–º–≤–æ–ª–∞
        charIndex[char] = right
        
        // üìä –û–±–Ω–æ–≤–ª—è–µ–º –º–∞–∫—Å–∏–º–∞–ª—å–Ω—É—é –¥–ª–∏–Ω—É
        currentLen := right - left + 1
        if currentLen > maxLen {
            maxLen = currentLen
        }
    }
    
    return maxLen
}
```

```bash
// üìö –û–ë–£–ß–ê–Æ–©–ò–ï –ö–û–ú–ú–ï–ù–¢–ê–†–ò–ò
/*
üéØ –ê–õ–ì–û–†–ò–¢–ú Sliding Window –¥–ª—è longest substring:

1. ü™ü –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º –æ–∫–Ω–æ [left, right] –±–µ–∑ –ø–æ–≤—Ç–æ—Ä—è—é—â–∏—Ö—Å—è —Å–∏–º–≤–æ–ª–æ–≤
2. üó∫Ô∏è HashMap —Ö—Ä–∞–Ω–∏—Ç: —Å–∏–º–≤–æ–ª ‚Üí –ø–æ—Å–ª–µ–¥–Ω—è—è –ø–æ–∑–∏—Ü–∏—è
3. üîÑ –î–ª—è –∫–∞–∂–¥–æ–≥–æ —Å–∏–º–≤–æ–ª–∞ s[right]:
   a) üîç –ï—Å–ª–∏ —Å–∏–º–≤–æ–ª —É–∂–µ –µ—Å—Ç—å –≤ —Ç–µ–∫—É—â–µ–º –æ–∫–Ω–µ (lastIndex >= left)
   b) üìè –°–∂–∏–º–∞–µ–º –æ–∫–Ω–æ: left = lastIndex + 1
   c) üíæ –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é: charIndex[char] = right
   d) üìä –û–±–Ω–æ–≤–ª—è–µ–º –º–∞–∫—Å–∏–º—É–º: max(maxLen, right - left + 1)

üîë –ö–õ–Æ–ß–ï–í–´–ï –ú–û–ú–ï–ù–¢–´:
- –£—Å–ª–æ–≤–∏–µ lastIndex >= left –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç, —á—Ç–æ –¥—É–±–ª–∏–∫–∞—Ç –≤ —Ç–µ–∫—É—â–µ–º –æ–∫–Ω–µ
- –û–±–Ω–æ–≤–ª—è–µ–º left –¢–û–õ–¨–ö–û –ø—Ä–∏ –¥—É–±–ª–∏–∫–∞—Ç–µ –≤ –æ–∫–Ω–µ
- HashMap –¥–∞–µ—Ç O(1) –≤—Ä–µ–º—è –¥–æ—Å—Ç—É–ø–∞
- –ö–∞–∂–¥—ã–π —Å–∏–º–≤–æ–ª –ø–æ—Å–µ—â–∞–µ—Ç—Å—è –º–∞–∫—Å–∏–º—É–º 2 —Ä–∞–∑–∞ (right –∏ left)

‚ö†Ô∏è –ì–†–ê–ù–ò–ß–ù–´–ï –°–õ–£–ß–ê–ò:
- –ü—É—Å—Ç–∞—è —Å—Ç—Ä–æ–∫–∞ ‚Üí 0
- –û–¥–∏–Ω —Å–∏–º–≤–æ–ª ‚Üí 1
- –í—Å–µ —Å–∏–º–≤–æ–ª—ã —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ ‚Üí –¥–ª–∏–Ω–∞ —Å—Ç—Ä–æ–∫–∏
- –í—Å–µ —Å–∏–º–≤–æ–ª—ã –æ–¥–∏–Ω–∞–∫–æ–≤—ã–µ ‚Üí 1

üí° –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–ò:
- –ú–∞—Å—Å–∏–≤ –≤–º–µ—Å—Ç–æ HashMap –¥–ª—è ASCII (128 —ç–ª–µ–º–µ–Ω—Ç–æ–≤)
- –ë–∏—Ç–æ–≤–∞—è –º–∞—Å–∫–∞ –¥–ª—è —Ç–æ–ª—å–∫–æ –±—É–∫–≤ (52 –±–∏—Ç–∞)
- Rolling hash –¥–ª—è –æ—á–µ–Ω—å –¥–ª–∏–Ω–Ω—ã—Ö —Å—Ç—Ä–æ–∫

üé≠ –í–ê–†–ò–ê–¶–ò–ò –ó–ê–î–ê–ß–ò:
- Longest substring —Å –Ω–µ –±–æ–ª–µ–µ —á–µ–º k —É–Ω–∏–∫–∞–ª—å–Ω—ã–º–∏ —Å–∏–º–≤–æ–ª–∞–º–∏
- Shortest substring —Å–æ–¥–µ—Ä–∂–∞—â–∞—è –≤—Å–µ —Å–∏–º–≤–æ–ª—ã –∏–∑ pattern
- Longest substring —Å —Ä–∞–≤–Ω—ã–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ–º 0 –∏ 1
- Minimum window substring
*/
```

### –†–µ—à–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏ 5

>[–Ω–∞–∑–∞–¥](#-–ø–æ–¥—Å–∫–∞–∑–∫–∏-–¥–ª—è-–æ—Å–Ω–æ–≤–Ω—ã—Ö-–∑–∞–¥–∞—á)

#### üéØ –†–µ—à–µ–Ω–∏–µ Merge Two Sorted Arrays

üìä –ê–Ω–∞–ª–∏–∑ –∑–∞–¥–∞—á–∏:

```
–î–∞–Ω–æ: nums1 = [1,2,3,0,0,0], m = 3
      nums2 = [2,5,6],       n = 3

–†–µ–∑—É–ª—å—Ç–∞—Ç: nums1 = [1,2,2,3,5,6]
(–æ–±—ä–µ–¥–∏–Ω—è–µ–º in-place –≤ nums1)
```

üö´ –ù–∞–∏–≤–Ω—ã–π –ø–æ–¥—Ö–æ–¥ O(n¬≤):

```go
func mergeNaive(nums1 []int, m int, nums2 []int, n int) {
    // –ö–æ–ø–∏—Ä—É–µ–º nums2 –≤ nums1
    copy(nums1[m:], nums2)
    // –°–æ—Ä—Ç–∏—Ä—É–µ–º –≤–µ—Å—å –º–∞—Å—Å–∏–≤ - O((m+n)log(m+n))
    sort.Ints(nums1)
}
```

*"–ò—Å–ø–æ–ª—å–∑—É—é three pointers pattern. –ö–ª—é—á–µ–≤–∞—è –∏–¥–µ—è - –∑–∞–ø–æ–ª–Ω—è—Ç—å –º–∞—Å—Å–∏–≤ —Å –∫–æ–Ω—Ü–∞, —Å—Ä–∞–≤–Ω–∏–≤–∞—è –Ω–∞–∏–±–æ–ª—å—à–∏–µ —ç–ª–µ–º–µ–Ω—Ç—ã. –≠—Ç–æ –ø–æ–∑–≤–æ–ª—è–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å in-place –±–µ–∑ –ø–µ—Ä–µ–∑–∞–ø–∏—Å–∏ –¥–∞–Ω–Ω—ã—Ö. –í –∫–æ–Ω—Ü–µ –∫–æ–ø–∏—Ä—É—é –æ—Å—Ç–∞–≤—à–∏–µ—Å—è —ç–ª–µ–º–µ–Ω—Ç—ã –∏–∑ nums2, –µ—Å–ª–∏ –æ–Ω–∏ –µ—Å—Ç—å. O(m+n) –≤—Ä–µ–º—è, O(1) –ø–∞–º—è—Ç—å - –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ!"*

üéØ –û–±—ä—è—Å–Ω–µ–Ω–∏–µ —Ä–µ—à–µ–Ω–∏—è:

üß† –õ–æ–≥–∏–∫–∞ Three Pointers –ø–æ–¥—Ö–æ–¥–∞:

1. üîß –¢—Ä–∏ —É–∫–∞–∑–∞—Ç–µ–ª—è: i=m-1 (nums1), j=n-1 (nums2), k=m+n-1 (—Ä–µ–∑—É–ª—å—Ç–∞—Ç)
2. üîÑ –ó–∞–ø–æ–ª–Ω—è–µ–º —Å –∫–æ–Ω—Ü–∞: –≤—ã–±–∏—Ä–∞–µ–º –Ω–∞–∏–±–æ–ª—å—à–∏–π –∏–∑ –¥–≤—É—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤
3. ‚¨ÖÔ∏è –°–¥–≤–∏–≥–∞–µ–º —É–∫–∞–∑–∞—Ç–µ–ª–∏: —É–º–µ–Ω—å—à–∞–µ–º —Ç–æ—Ç, —ç–ª–µ–º–µ–Ω—Ç –∫–æ—Ç–æ—Ä–æ–≥–æ –≤–∑—è–ª–∏
4. üìã –ö–æ–ø–∏—Ä—É–µ–º –æ—Å—Ç–∞—Ç–∫–∏: –µ—Å–ª–∏ –æ—Å—Ç–∞–ª–∏—Å—å —ç–ª–µ–º–µ–Ω—Ç—ã –≤ nums2

```go
package main

import (
    "fmt"
    "sort"
    "testing"
)

// ‚úÖ –û–ü–¢–ò–ú–ê–õ–¨–ù–û–ï –†–ï–®–ï–ù–ò–ï - Three Pointers —Å –∫–æ–Ω—Ü–∞
func merge(nums1 []int, m int, nums2 []int, n int) {
    // üîß –¢—Ä–∏ —É–∫–∞–∑–∞—Ç–µ–ª—è
    i := m - 1      // üëà –ü–æ—Å–ª–µ–¥–Ω–∏–π —ç–ª–µ–º–µ–Ω—Ç nums1
    j := n - 1      // üëà –ü–æ—Å–ª–µ–¥–Ω–∏–π —ç–ª–µ–º–µ–Ω—Ç nums2  
    k := m + n - 1  // üëà –ü–æ—Å–ª–µ–¥–Ω—è—è –ø–æ–∑–∏—Ü–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
    
    // üîÑ –ó–∞–ø–æ–ª–Ω—è–µ–º —Å –∫–æ–Ω—Ü–∞, –≤—ã–±–∏—Ä–∞—è –Ω–∞–∏–±–æ–ª—å—à–∏–π —ç–ª–µ–º–µ–Ω—Ç
    for i >= 0 && j >= 0 {
        if nums1[i] > nums2[j] {
            nums1[k] = nums1[i]  // –ë–µ—Ä–µ–º –∏–∑ nums1
            i--
        } else {
            nums1[k] = nums2[j]  // –ë–µ—Ä–µ–º –∏–∑ nums2
            j--
        }
        k--
    }
    
    // üìã –ö–æ–ø–∏—Ä—É–µ–º –æ—Å—Ç–∞–≤—à–∏–µ—Å—è —ç–ª–µ–º–µ–Ω—Ç—ã –∏–∑ nums2 (–µ—Å–ª–∏ –µ—Å—Ç—å)
    for j >= 0 {
        nums1[k] = nums2[j]
        j--
        k--
    }
    
    // üí° –≠–ª–µ–º–µ–Ω—Ç—ã –∏–∑ nums1 —É–∂–µ –Ω–∞ —Å–≤–æ–∏—Ö –º–µ—Å—Ç–∞—Ö, –µ—Å–ª–∏ i >= 0
}
```

```bash
// üìö –û–ë–£–ß–ê–Æ–©–ò–ï –ö–û–ú–ú–ï–ù–¢–ê–†–ò–ò
/*
üéØ –ê–õ–ì–û–†–ò–¢–ú Three Pointers –¥–ª—è merge:

1. üîß –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º —Ç—Ä–∏ —É–∫–∞–∑–∞—Ç–µ–ª—è:
   - i = m - 1 (–ø–æ—Å–ª–µ–¥–Ω–∏–π —ç–ª–µ–º–µ–Ω—Ç nums1)
   - j = n - 1 (–ø–æ—Å–ª–µ–¥–Ω–∏–π —ç–ª–µ–º–µ–Ω—Ç nums2)  
   - k = m + n - 1 (–ø–æ—Å–ª–µ–¥–Ω—è—è –ø–æ–∑–∏—Ü–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞)

2. üîÑ –ü–æ–∫–∞ –æ–±–∞ –º–∞—Å—Å–∏–≤–∞ –Ω–µ –ø—É—Å—Ç—ã (i >= 0 && j >= 0):
   a) üîç –°—Ä–∞–≤–Ω–∏–≤–∞–µ–º nums1[i] –∏ nums2[j]
   b) üìù –ó–∞–ø–∏—Å—ã–≤–∞–µ–º –±–æ–ª—å—à–∏–π —ç–ª–µ–º–µ–Ω—Ç –≤ nums1[k]
   c) ‚¨ÖÔ∏è –£–º–µ–Ω—å—à–∞–µ–º —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–π —É–∫–∞–∑–∞—Ç–µ–ª—å (i –∏–ª–∏ j)
   d) ‚¨ÖÔ∏è –£–º–µ–Ω—å—à–∞–µ–º k

3. üìã –ö–æ–ø–∏—Ä—É–µ–º –æ—Å—Ç–∞–≤—à–∏–µ—Å—è —ç–ª–µ–º–µ–Ω—Ç—ã –∏–∑ nums2 (–µ—Å–ª–∏ j >= 0)

üîë –ö–õ–Æ–ß–ï–í–´–ï –ú–û–ú–ï–ù–¢–´:
- –ó–∞–ø–æ–ª–Ω—è–µ–º –° –ö–û–ù–¶–ê, —á—Ç–æ–±—ã –Ω–µ –ø–µ—Ä–µ–∑–∞–ø–∏—Å–∞—Ç—å –¥–∞–Ω–Ω—ã–µ
- –ï—Å–ª–∏ –æ—Å—Ç–∞–ª–∏—Å—å —ç–ª–µ–º–µ–Ω—Ç—ã –≤ nums1, –æ–Ω–∏ —É–∂–µ –Ω–∞ —Å–≤–æ–∏—Ö –º–µ—Å—Ç–∞—Ö
- –ï—Å–ª–∏ –æ—Å—Ç–∞–ª–∏—Å—å —ç–ª–µ–º–µ–Ω—Ç—ã –≤ nums2, –∫–æ–ø–∏—Ä—É–µ–º –∏—Ö
- –°—Ä–∞–≤–Ω–µ–Ω–∏–µ: >= –∏–ª–∏ > –≤–ª–∏—è–µ—Ç –Ω–∞ —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç—å —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏

‚ö†Ô∏è –ì–†–ê–ù–ò–ß–ù–´–ï –°–õ–£–ß–ê–ò:
- nums2 –ø—É—Å—Ç–æ–π (n=0) ‚Üí nums1 –æ—Å—Ç–∞–µ—Ç—Å—è –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π
- nums1 –ø—É—Å—Ç–æ–π (m=0) ‚Üí –ø—Ä–æ—Å—Ç–æ –∫–æ–ø–∏—Ä—É–µ–º nums2
- –í—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã nums2 –±–æ–ª—å—à–µ nums1 ‚Üí —Å–Ω–∞—á–∞–ª–∞ –∑–∞–ø–æ–ª–Ω–∏—Ç—Å—è nums2
- –í—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã nums1 –±–æ–ª—å—à–µ nums2 ‚Üí nums1 —Å–¥–≤–∏–≥–∞–µ—Ç—Å—è –Ω–∞–∑–∞–¥

üí° –ü–û–ß–ï–ú–£ –° –ö–û–ù–¶–ê:
- –ï—Å–ª–∏ –∑–∞–ø–æ–ª–Ω—è—Ç—å —Å –Ω–∞—á–∞–ª–∞, –Ω—É–∂–Ω–∞ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ø–∞–º—è—Ç—å
- –ó–∞–ø–æ–ª–Ω–µ–Ω–∏–µ —Å –∫–æ–Ω—Ü–∞ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç —Å–≤–æ–±–æ–¥–Ω–æ–µ –º–µ—Å—Ç–æ –≤ nums1
- –ù–∏–∫–æ–≥–¥–∞ –Ω–µ –ø–µ—Ä–µ–∑–∞–ø–∏—Å—ã–≤–∞–µ–º –µ—â–µ –Ω–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ

üé≠ –í–ê–†–ò–ê–¶–ò–ò –ó–ê–î–ê–ß–ò:
- Merge k –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –º–∞—Å—Å–∏–≤–æ–≤
- Merge —Å —É–¥–∞–ª–µ–Ω–∏–µ–º –¥—É–±–ª–∏–∫–∞—Ç–æ–≤
- Merge —Å–≤—è–∑–∞–Ω–Ω—ã—Ö —Å–ø–∏—Å–∫–æ–≤
- Merge —Å –ø–æ–¥—Å—á–µ—Ç–æ–º –∏–Ω–≤–µ—Ä—Å–∏–π
*/
```

### –†–µ—à–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏ 6

>[–Ω–∞–∑–∞–¥](#-–ø–æ–¥—Å–∫–∞–∑–∫–∏-–¥–ª—è-–æ—Å–Ω–æ–≤–Ω—ã—Ö-–∑–∞–¥–∞—á)

#### üéØ –†–µ—à–µ–Ω–∏–µ Intersection of Two Arrays

üìä –ê–Ω–∞–ª–∏–∑ –∑–∞–¥–∞—á–∏:

```bash
VERSION I - Intersection (—É–Ω–∏–∫–∞–ª—å–Ω—ã–µ):
–î–∞–Ω–æ: nums1 = [1,2,2,1], nums2 = [2,2]
–†–µ–∑—É–ª—å—Ç–∞—Ç: [2] (—Ç–æ–ª—å–∫–æ —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è)

VERSION II - Intersect (—Å –¥—É–±–ª–∏–∫–∞—Ç–∞–º–∏):  
–î–∞–Ω–æ: nums1 = [1,2,2,1], nums2 = [2,2]
–†–µ–∑—É–ª—å—Ç–∞—Ç: [2,2] (—É—á–∏—Ç—ã–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤—Ö–æ–∂–¥–µ–Ω–∏–π)

–î–∞–Ω–æ: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
VERSION I —Ä–µ–∑—É–ª—å—Ç–∞—Ç: [9,4] –∏–ª–∏ [4,9]
VERSION II —Ä–µ–∑—É–ª—å—Ç–∞—Ç: [4,9] –∏–ª–∏ [9,4]
```

*"–ò—Å–ø–æ–ª—å–∑—É—é HashMap –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –ø—Ä–æ–π–¥–µ–Ω–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤. –ó–∞ –æ–¥–∏–Ω –ø—Ä–æ—Ö–æ–¥ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —á–∏—Å–ª–∞ X –∏—â—É –¥–æ–ø–æ–ª–Ω–µ–Ω–∏–µ Y=target-X –≤ map. –ï—Å–ª–∏ –Ω–∞—à–µ–ª - –≤–æ–∑–≤—Ä–∞—â–∞—é –ø–∞—Ä—É, –µ—Å–ª–∏ –Ω–µ—Ç - —Å–æ—Ö—Ä–∞–Ω—è—é X. –°–ª–æ–∂–Ω–æ—Å—Ç—å O(n) –≤—Ä–µ–º—è, O(n) –ø–∞–º—è—Ç—å - –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ –¥–ª—è —ç—Ç–æ–π –∑–∞–¥–∞—á–∏."*

üéØ –û–±—ä—è—Å–Ω–µ–Ω–∏–µ —Ä–µ—à–µ–Ω–∏—è:  

üß† –õ–æ–≥–∏–∫–∞ HashMap –ø–æ–¥—Ö–æ–¥–∞:

1. üîß –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –ø–∞–º—è—Ç–∏: –ø–æ–º–µ—â–∞–µ–º –º–µ–Ω—å—à–∏–π –º–∞—Å—Å–∏–≤ –≤ HashMap  
2. üìã –î–ª—è Version I: –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π Set –∏–∑–±–µ–≥–∞–µ—Ç –¥—É–±–ª–∏–∫–∞—Ç–æ–≤ –≤ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–µ  
3. üîç –î–ª—è Version II: —É–º–µ–Ω—å—à–∞–µ–º —Å—á–µ—Ç—á–∏–∫ –ø—Ä–∏ –∫–∞–∂–¥–æ–º –Ω–∞–π–¥–µ–Ω–Ω–æ–º —ç–ª–µ–º–µ–Ω—Ç–µ  
4. üìä –°–±–æ—Ä–∫–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞: –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º Set ‚Üí slice –∏–ª–∏ –¥–æ–±–∞–≤–ª—è–µ–º –Ω–∞–ø—Ä—è–º—É—é

```go
// ‚úÖ INTERSECTION I - –£–Ω–∏–∫–∞–ª—å–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è
func intersection(nums1 []int, nums2 []int) []int {
    // üîß –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è: –º–µ–Ω—å—à–∏–π –º–∞—Å—Å–∏–≤ –≤ set
    if len(nums1) > len(nums2) {
        nums1, nums2 = nums2, nums1
    }
    
    // üó∫Ô∏è Set –¥–ª—è —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤ nums1
    set1 := make(map[int]bool)
    for _, num := range nums1 {
        set1[num] = true
    }
    
    // üìã Set –¥–ª—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ (–∏–∑–±–µ–≥–∞–µ–º –¥—É–±–ª–∏–∫–∞—Ç–æ–≤)
    resultSet := make(map[int]bool)
    
    // üîç –ò—â–µ–º –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è –≤ nums2
    for _, num := range nums2 {
        if set1[num] && !resultSet[num] {
            resultSet[num] = true
        }
    }
    
    // üìä –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º set –≤ slice
    result := make([]int, 0, len(resultSet))
    for num := range resultSet {
        result = append(result, num)
    }
    
    return result
}

// ‚úÖ INTERSECTION II - –° —É—á–µ—Ç–æ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –¥—É–±–ª–∏–∫–∞—Ç–æ–≤
func intersect(nums1 []int, nums2 []int) []int {
    // üîß –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è: –º–µ–Ω—å—à–∏–π –º–∞—Å—Å–∏–≤ –≤ map
    if len(nums1) > len(nums2) {
        nums1, nums2 = nums2, nums1
    }
    
    // üó∫Ô∏è HashMap: —ç–ª–µ–º–µ–Ω—Ç -> –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤ nums1
    countMap := make(map[int]int)
    for _, num := range nums1 {
        countMap[num]++
    }
    
    // üìä –°–æ–±–∏—Ä–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
    var result []int
    
    // üîç –ü—Ä–æ—Ö–æ–¥–∏–º –ø–æ nums2 –∏ —É–º–µ–Ω—å—à–∞–µ–º —Å—á–µ—Ç—á–∏–∫–∏
    for _, num := range nums2 {
        if count := countMap[num]; count > 0 {
            result = append(result, num)
            countMap[num]--  // –£–º–µ–Ω—å—à–∞–µ–º —Å—á–µ—Ç—á–∏–∫
        }
    }
    
    return result
}

```bash
/*
üéØ –ê–õ–ì–û–†–ò–¢–ú Intersection —Å HashMap:

–í–ï–†–°–ò–Ø I (—É–Ω–∏–∫–∞–ª—å–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã):
1. üîß –ú–µ–Ω—å—à–∏–π –º–∞—Å—Å–∏–≤ ‚Üí Set –¥–ª—è O(1) –ø–æ–∏—Å–∫–∞
2. üìã –°–æ–∑–¥–∞–µ–º resultSet –¥–ª—è –∏–∑–±–µ–∂–∞–Ω–∏—è –¥—É–±–ª–∏–∫–∞—Ç–æ–≤
3. üîç –î–ª—è –∫–∞–∂–¥–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞ –±–æ–ª—å—à–µ–≥–æ –º–∞—Å—Å–∏–≤–∞:
   - –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –≤ set –º–µ–Ω—å—à–µ–≥–æ
   - –î–æ–±–∞–≤–ª—è–µ–º –≤ result —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –µ—â–µ –Ω–µ –¥–æ–±–∞–≤–ª–µ–Ω
4. üìä –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º set ‚Üí slice

–í–ï–†–°–ò–Ø II (—Å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ–º):
1. üîß –ú–µ–Ω—å—à–∏–π –º–∞—Å—Å–∏–≤ ‚Üí HashMap (—ç–ª–µ–º–µ–Ω—Ç ‚Üí count)
2. üîç –î–ª—è –∫–∞–∂–¥–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞ –±–æ–ª—å—à–µ–≥–æ –º–∞—Å—Å–∏–≤–∞:
   - –ï—Å–ª–∏ count > 0: –¥–æ–±–∞–≤–ª—è–µ–º –≤ result
   - –£–º–µ–Ω—å—à–∞–µ–º count –Ω–∞ 1
3. üìä –í–æ–∑–≤—Ä–∞—â–∞–µ–º result

üîë –ö–õ–Æ–ß–ï–í–´–ï –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–ò:
- –ú–µ–Ω—å—à–∏–π –º–∞—Å—Å–∏–≤ –≤ map/set –¥–ª—è —ç–∫–æ–Ω–æ–º–∏–∏ –ø–∞–º—è—Ç–∏: O(min(n,m))
- –î–ª—è Version I: –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π set –∏–∑–±–µ–≥–∞–µ—Ç –¥—É–±–ª–∏–∫–∞—Ç–æ–≤
- –î–ª—è Version II: —É–º–µ–Ω—å—à–µ–Ω–∏–µ —Å—á–µ—Ç—á–∏–∫–∞ –∫–æ–Ω—Ç—Ä–æ–ª–∏—Ä—É–µ—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ

‚ö° –°–õ–û–ñ–ù–û–°–¢–¨:
- –í—Ä–µ–º—è: O(n + m) - –æ–¥–∏–Ω –ø—Ä–æ—Ö–æ–¥ –ø–æ –∫–∞–∂–¥–æ–º—É –º–∞—Å—Å–∏–≤—É
- –ü–∞–º—è—Ç—å: O(min(n, m)) - map —Ä–∞–∑–º–µ—Ä–æ–º —Å –º–µ–Ω—å—à–∏–π –º–∞—Å—Å–∏–≤

üé≠ –ê–õ–¨–¢–ï–†–ù–ê–¢–ò–í–´ –¥–ª—è –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –º–∞—Å—Å–∏–≤–æ–≤:
- Two Pointers: O(n + m) –≤—Ä–µ–º—è, O(1) –ø–∞–º—è—Ç—å
- –°–Ω–∞—á–∞–ª–∞ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ, –ø–æ—Ç–æ–º —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞

‚ö†Ô∏è –ì–†–ê–ù–ò–ß–ù–´–ï –°–õ–£–ß–ê–ò:
- –ü—É—Å—Ç—ã–µ –º–∞—Å—Å–∏–≤—ã ‚Üí –ø—É—Å—Ç–æ–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç
- –ù–µ—Ç –æ–±—â–∏—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤ ‚Üí –ø—É—Å—Ç–æ–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç  
- –û–¥–∏–Ω –º–∞—Å—Å–∏–≤ –ø–æ–¥–º–Ω–æ–∂–µ—Å—Ç–≤–æ –¥—Ä—É–≥–æ–≥–æ ‚Üí –º–µ–Ω—å—à–∏–π –º–∞—Å—Å–∏–≤
- –í—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã –æ–¥–∏–Ω–∞–∫–æ–≤—ã–µ ‚Üí –∑–∞–≤–∏—Å–∏—Ç –æ—Ç –≤–µ—Ä—Å–∏–∏

üí° –í–´–ë–û–† –ü–û–î–•–û–î–ê:
- HashMap: —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π, –¥–ª—è –ª—é–±—ã—Ö –º–∞—Å—Å–∏–≤–æ–≤
- Two Pointers: —Ç–æ–ª—å–∫–æ –¥–ª—è –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –º–∞—Å—Å–∏–≤–æ–≤
- Sort + Two Pointers: –µ—Å–ª–∏ –º–æ–∂–Ω–æ –º–æ–¥–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞—Ç—å –≤—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ

üîß FOLLOW-UP –≤–æ–ø—Ä–æ—Å—ã:
1. –ß—Ç–æ –µ—Å–ª–∏ –º–∞—Å—Å–∏–≤—ã –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω—ã? ‚Üí Two Pointers
2. –ß—Ç–æ –µ—Å–ª–∏ nums1 –Ω–∞–º–Ω–æ–≥–æ –º–µ–Ω—å—à–µ nums2? ‚Üí nums1 –≤ HashMap
3. –ß—Ç–æ –µ—Å–ª–∏ –º–∞—Å—Å–∏–≤—ã –Ω–∞ –¥–∏—Å–∫–µ –∏ –Ω–µ –ø–æ–º–µ—â–∞—é—Ç—Å—è –≤ –ø–∞–º—è—Ç—å? ‚Üí 
   External sort ‚Üí merge –ø–æ–¥—Ö–æ–¥ –ø–æ —á–∞—Å—Ç—è–º
4. –ß—Ç–æ –µ—Å–ª–∏ –Ω—É–∂–Ω–∞ —Å—Ç–∞–±–∏–ª—å–Ω–∞—è —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞? ‚Üí
   –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –ø–æ—Ä—è–¥–æ–∫ –∏–∑ –ø–µ—Ä–≤–æ–≥–æ –º–∞—Å—Å–∏–≤–∞
*/
```

### –†–µ—à–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏ 7

>[–Ω–∞–∑–∞–¥](#-–ø–æ–¥—Å–∫–∞–∑–∫–∏-–¥–ª—è-–æ—Å–Ω–æ–≤–Ω—ã—Ö-–∑–∞–¥–∞—á)

#### üéØ –†–µ—à–µ–Ω–∏–µ Binary Search

üìä –ê–Ω–∞–ª–∏–∑ –∑–∞–¥–∞—á–∏:

```
üìä –ê–ù–ê–õ–ò–ó –ó–ê–î–ê–ß–ò:

–ö–õ–ê–°–°–ò–ß–ï–°–ö–ò–ô –ü–û–ò–°–ö:
–î–∞–Ω–æ: nums = [-1,0,3,5,9,12], target = 9
–†–µ–∑—É–ª—å—Ç–∞—Ç: 4 (–∏–Ω–¥–µ–∫—Å —ç–ª–µ–º–µ–Ω—Ç–∞ 9)

–î–∞–Ω–æ: nums = [-1,0,3,5,9,12], target = 2  
–†–µ–∑—É–ª—å—Ç–∞—Ç: -1 (—ç–ª–µ–º–µ–Ω—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω)

–ü–û–ò–°–ö –ì–†–ê–ù–ò–¶:
–î–∞–Ω–æ: nums = [5,7,7,8,8,10], target = 8
–õ–µ–≤–∞—è –≥—Ä–∞–Ω–∏—Ü–∞: 3 (–ø–µ—Ä–≤–æ–µ –≤—Ö–æ–∂–¥–µ–Ω–∏–µ 8)
–ü—Ä–∞–≤–∞—è –≥—Ä–∞–Ω–∏—Ü–∞: 4 (–ø–æ—Å–ª–µ–¥–Ω–µ–µ –≤—Ö–æ–∂–¥–µ–Ω–∏–µ 8)

–ü–û–ò–°–ö –ü–û–ó–ò–¶–ò–ò –î–õ–Ø –í–°–¢–ê–í–ö–ò:
–î–∞–Ω–æ: nums = [1,3,5,6], target = 5
–†–µ–∑—É–ª—å—Ç–∞—Ç: 2 (–ø–æ–∑–∏—Ü–∏—è —ç–ª–µ–º–µ–Ω—Ç–∞ 5)
–î–∞–Ω–æ: nums = [1,3,5,6], target = 2
–†–µ–∑—É–ª—å—Ç–∞—Ç: 1 (–ø–æ–∑–∏—Ü–∏—è –¥–ª—è –≤—Å—Ç–∞–≤–∫–∏ –º–µ–∂–¥—É 1 –∏ 3)
```

*"Binary search –æ—Å–Ω–æ–≤–∞–Ω –Ω–∞ –¥–µ–ª–µ–Ω–∏–∏ –ø–æ–ø–æ–ª–∞–º. –ö–ª—é—á–µ–≤—ã–µ –º–æ–º–µ–Ω—Ç—ã: –∏–∑–±–µ–≥–∞–Ω–∏–µ –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏—è —á–µ—Ä–µ–∑ left + (right-left)/2, –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –≤—ã–±–æ—Ä –≥—Ä–∞–Ω–∏—Ü –∏ —É—Å–ª–æ–≤–∏–π —Ü–∏–∫–ª–∞ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –∑–∞–¥–∞—á–∏. –î–ª—è —Ç–æ—á–Ω–æ–≥–æ –ø–æ–∏—Å–∫–∞ –∏—Å–ø–æ–ª—å–∑—É—é left <= right, –¥–ª—è –ø–æ–∏—Å–∫–∞ –≥—Ä–∞–Ω–∏—Ü - left < right. O(log n) –≤—Ä–µ–º—è –±–ª–∞–≥–æ–¥–∞—Ä—è –¥–µ–ª–µ–Ω–∏—é –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–∞ –ø–æ–ø–æ–ª–∞–º."*

üéØ –û–±—ä—è—Å–Ω–µ–Ω–∏–µ —Ä–µ—à–µ–Ω–∏—è:

üß† –õ–æ–≥–∏–∫–∞ Binary Search:

1. üìç –î–µ–ª–µ–Ω–∏–µ –ø–æ–ø–æ–ª–∞–º: mid = left + (right - left) / 2
2. üéØ –°—Ä–∞–≤–Ω–µ–Ω–∏–µ: –Ω–∞–ø—Ä–∞–≤–ª—è–µ–º –ø–æ–∏—Å–∫ –≤ –Ω—É–∂–Ω—É—é –ø–æ–ª–æ–≤–∏–Ω—É
3. üîÑ –ü–æ–≤—Ç–æ—Ä–µ–Ω–∏–µ: –ø–æ–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–º –∏–ª–∏ –≥—Ä–∞–Ω–∏—Ü—ã –Ω–µ —Å–æ–π–¥—É—Ç—Å—è
4. ‚ö° –õ–æ–≥–∞—Ä–∏—Ñ–º–∏—á–µ—Å–∫–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: –∫–∞–∂–¥—ã–π —à–∞–≥ –¥–µ–ª–∏—Ç –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ –ø–æ–ø–æ–ª–∞–º

```go
// ‚úÖ –ö–õ–ê–°–°–ò–ß–ï–°–ö–ò–ô BINARY SEARCH - –ø–æ–∏—Å–∫ —Ç–æ—á–Ω–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞
func search(nums []int, target int) int {
    left, right := 0, len(nums)-1
    
    // üîÑ –ü–æ–∫–∞ –µ—Å—Ç—å —ç–ª–µ–º–µ–Ω—Ç—ã –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏
    for left <= right {
        // üîß –ò–∑–±–µ–≥–∞–µ–º –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏—è: left + (right - left) / 2
        mid := left + (right-left)/2
        
        if nums[mid] == target {
            return mid  // üéØ –ù–∞–π–¥–µ–Ω!
        } else if nums[mid] < target {
            left = mid + 1   // üîç –ò—â–µ–º –≤ –ø—Ä–∞–≤–æ–π –ø–æ–ª–æ–≤–∏–Ω–µ
        } else {
            right = mid - 1  // üîç –ò—â–µ–º –≤ –ª–µ–≤–æ–π –ø–æ–ª–æ–≤–∏–Ω–µ
        }
    }
    
    return -1  // ‚ùå –ù–µ –Ω–∞–π–¥–µ–Ω
}

// ‚úÖ –ü–û–ò–°–ö –õ–ï–í–û–ô –ì–†–ê–ù–ò–¶–´ - –ø–µ—Ä–≤–æ–µ –≤—Ö–æ–∂–¥–µ–Ω–∏–µ
func searchFirst(nums []int, target int) int {
    left, right := 0, len(nums)  // üîß right = len(nums), –Ω–µ len(nums)-1!
    
    for left < right {  // üîß –£—Å–ª–æ–≤–∏–µ: left < right (–Ω–µ <=)
        mid := left + (right-left)/2
        
        if nums[mid] < target {
            left = mid + 1   // üîç –ò—â–µ–º –ø—Ä–∞–≤–µ–µ
        } else {
            right = mid      // üîß –í–∫–ª—é—á–∞–µ–º mid (–º–æ–∂–µ—Ç –±—ã—Ç—å –ø–µ—Ä–≤—ã–º)
        }
    }
    
    // üîç –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
    if left < len(nums) && nums[left] == target {
        return left
    }
    return -1
}

// ‚úÖ –ü–û–ò–°–ö –ü–†–ê–í–û–ô –ì–†–ê–ù–ò–¶–´ - –ø–æ—Å–ª–µ–¥–Ω–µ–µ –≤—Ö–æ–∂–¥–µ–Ω–∏–µ
func searchLast(nums []int, target int) int {
    left, right := 0, len(nums)
    
    for left < right {
        mid := left + (right-left)/2
        
        if nums[mid] <= target {  // üîß <= –≤–º–µ—Å—Ç–æ <
            left = mid + 1
        } else {
            right = mid
        }
    }
    
    // üîç –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç—å (left-1 —Ç.–∫. –∏—â–µ–º –ø–æ—Å–ª–µ–¥–Ω–µ–µ)
    if left > 0 && nums[left-1] == target {
        return left - 1
    }
    return -1
}

// ‚úÖ –ü–û–ò–°–ö –ü–û–ó–ò–¶–ò–ò –î–õ–Ø –í–°–¢–ê–í–ö–ò
func searchInsert(nums []int, target int) int {
    left, right := 0, len(nums)
    
    for left < right {
        mid := left + (right-left)/2
        
        if nums[mid] < target {
            left = mid + 1
        } else {
            right = mid
        }
    }
    
    return left  // üéØ –ü–æ–∑–∏—Ü–∏—è –¥–ª—è –≤—Å—Ç–∞–≤–∫–∏
}

// ‚úÖ –ü–û–ò–°–ö –î–ò–ê–ü–ê–ó–û–ù–ê - –ø–µ—Ä–≤–æ–µ –∏ –ø–æ—Å–ª–µ–¥–Ω–µ–µ –≤—Ö–æ–∂–¥–µ–Ω–∏–µ
func searchRange(nums []int, target int) []int {
    first := searchFirst(nums, target)
    if first == -1 {
        return []int{-1, -1}  // –≠–ª–µ–º–µ–Ω—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω
    }
    
    last := searchLast(nums, target)
    return []int{first, last}
}

// üöÄ BINARY SEARCH –Ω–∞ —É—Å–ª–æ–≤–∏–∏ (–±–æ–ª–µ–µ –æ–±—â–∏–π –ø–æ–¥—Ö–æ–¥)
func binarySearchCondition(left, right int, condition func(int) bool) int {
    // –ù–∞—Ö–æ–¥–∏–º –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ, –¥–ª—è –∫–æ—Ç–æ—Ä–æ–≥–æ condition(x) == true
    for left < right {
        mid := left + (right-left)/2
        if condition(mid) {
            right = mid
        } else {
            left = mid + 1
        }
    }
    return left
}

// üéØ –ü–û–ò–°–ö –í –ü–û–í–ï–†–ù–£–¢–û–ú –û–¢–°–û–†–¢–ò–†–û–í–ê–ù–ù–û–ú –ú–ê–°–°–ò–í–ï
func searchRotated(nums []int, target int) int {
    left, right := 0, len(nums)-1
    
    for left <= right {
        mid := left + (right-left)/2
        
        if nums[mid] == target {
            return mid
        }
        
        // üîç –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∫–∞–∫–∞—è –ø–æ–ª–æ–≤–∏–Ω–∞ –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–∞
        if nums[left] <= nums[mid] {  // –õ–µ–≤–∞—è –ø–æ–ª–æ–≤–∏–Ω–∞ –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–∞
            if nums[left] <= target && target < nums[mid] {
                right = mid - 1  // target –≤ –ª–µ–≤–æ–π –ø–æ–ª–æ–≤–∏–Ω–µ
            } else {
                left = mid + 1   // target –≤ –ø—Ä–∞–≤–æ–π –ø–æ–ª–æ–≤–∏–Ω–µ
            }
        } else {  // –ü—Ä–∞–≤–∞—è –ø–æ–ª–æ–≤–∏–Ω–∞ –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–∞
            if nums[mid] < target && target <= nums[right] {
                left = mid + 1   // target –≤ –ø—Ä–∞–≤–æ–π –ø–æ–ª–æ–≤–∏–Ω–µ
            } else {
                right = mid - 1  // target –≤ –ª–µ–≤–æ–π –ø–æ–ª–æ–≤–∏–Ω–µ
            }
        }
    }
    
    return -1
}

// üîß Helper: –ø–æ–∏—Å–∫ –ø–∏–∫–∞ –≤ –º–∞—Å—Å–∏–≤–µ
func findPeakElement(nums []int) int {
    left, right := 0, len(nums)-1
    
    for left < right {
        mid := left + (right-left)/2
        
        if nums[mid] < nums[mid+1] {
            left = mid + 1   // –ü–∏–∫ —Å–ø—Ä–∞–≤–∞
        } else {
            right = mid      // –ü–∏–∫ —Å–ª–µ–≤–∞ –∏–ª–∏ mid - –ø–∏–∫
        }
    }
    
    return left
}
```

```bash
üéØ –ê–õ–ì–û–†–ò–¢–ú Binary Search (–∫–ª–∞—Å—Å–∏—á–µ—Å–∫–∏–π):

1. üîß –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –≥—Ä–∞–Ω–∏—Ü: left = 0, right = len(nums) - 1
2. üîÑ –ü–æ–∫–∞ left <= right:
   a) üìç mid = left + (right - left) / 2  (–∏–∑–±–µ–≥–∞–µ–º –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏—è)
   b) üéØ –ï—Å–ª–∏ nums[mid] == target ‚Üí return mid
   c) üîç –ï—Å–ª–∏ nums[mid] < target ‚Üí left = mid + 1
   d) üîç –ï—Å–ª–∏ nums[mid] > target ‚Üí right = mid - 1
3. ‚ùå Return -1 (–Ω–µ –Ω–∞–π–¥–µ–Ω)

üîë –ö–õ–Æ–ß–ï–í–´–ï –†–ê–ó–õ–ò–ß–ò–Ø –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤:

–ö–õ–ê–°–°–ò–ß–ï–°–ö–ò–ô (—Ç–æ—á–Ω—ã–π –ø–æ–∏—Å–∫):
- –£—Å–ª–æ–≤–∏–µ: left <= right
- –ì—Ä–∞–Ω–∏—Ü—ã: [0, len(nums)-1]
- –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ: right = mid - 1, left = mid + 1

–ü–û–ò–°–ö –ì–†–ê–ù–ò–¶:
- –£—Å–ª–æ–≤–∏–µ: left < right (–ù–ï <=)
- –ì—Ä–∞–Ω–∏—Ü—ã: [0, len(nums)] (–ù–ï len(nums)-1)
- –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ: right = mid (–≤–∫–ª—é—á–∞–µ–º mid)

‚ö†Ô∏è –ö–†–ò–¢–ò–ß–ï–°–ö–ò–ï –ú–û–ú–ï–ù–¢–´:
- mid = left + (right - left) / 2 –ò–ó–ë–ï–ì–ê–ï–¢ –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏—è
- –î–ª—è –ø–æ–∏—Å–∫–∞ –≥—Ä–∞–Ω–∏—Ü: right = len(nums), –ù–ï len(nums)-1
- –£—Å–ª–æ–≤–∏–µ —Ü–∏–∫–ª–∞: left < right vs left <= right
- –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≥—Ä–∞–Ω–∏—Ü: –≤–∫–ª—é—á–∞—Ç—å/–∏—Å–∫–ª—é—á–∞—Ç—å mid

üí° –í–´–ë–û–† –í–ê–†–ò–ê–ù–¢–ê:
- –¢–æ—á–Ω—ã–π –ø–æ–∏—Å–∫ ‚Üí –∫–ª–∞—Å—Å–∏—á–µ—Å–∫–∏–π –ø–æ–¥—Ö–æ–¥
- –ü–µ—Ä–≤–æ–µ/–ø–æ—Å–ª–µ–¥–Ω–µ–µ –≤—Ö–æ–∂–¥–µ–Ω–∏–µ ‚Üí –ø–æ–∏—Å–∫ –≥—Ä–∞–Ω–∏—Ü  
- Insert position ‚Üí –∫–∞–∫ –ø–æ–∏—Å–∫ –ª–µ–≤–æ–π –≥—Ä–∞–Ω–∏—Ü—ã
- –£—Å–ª–æ–≤–Ω—ã–π –ø–æ–∏—Å–∫ ‚Üí –æ–±—â–∏–π template —Å —Ñ—É–Ω–∫—Ü–∏–µ–π

üé≠ –ü–†–ò–ú–ï–ù–ï–ù–ò–Ø:
- –ü–æ–∏—Å–∫ –≤ –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–º –º–∞—Å—Å–∏–≤–µ
- –ü–æ–∏—Å–∫ –≤ –ø–æ–≤–µ—Ä–Ω—É—Ç–æ–º –º–∞—Å—Å–∏–≤–µ  
- –ü–æ–∏—Å–∫ –ø–∏–∫–∞/–º–∏–Ω–∏–º—É–º–∞
- –ü–æ–∏—Å–∫ –∫–≤–∞–¥—Ä–∞—Ç–Ω–æ–≥–æ –∫–æ—Ä–Ω—è
- Capacity to ship packages
- Koko eating bananas

‚ö° –°–õ–û–ñ–ù–û–°–¢–¨:
- –í—Ä–µ–º—è: O(log n) - –∫–∞–∂–¥–∞—è –∏—Ç–µ—Ä–∞—Ü–∏—è –¥–µ–ª–∏—Ç –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ –ø–æ–ø–æ–ª–∞–º
- –ü–∞–º—è—Ç—å: O(1) - —Ç–æ–ª—å–∫–æ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –≥—Ä–∞–Ω–∏—Ü

üîß –®–ê–ë–õ–û–ù –¥–ª—è —Ä–µ—à–µ–Ω–∏—è "–ø–æ–∏—Å–∫ –ø–æ –æ—Ç–≤–µ—Ç—É":
1. –û–ø—Ä–µ–¥–µ–ª–∏—Ç—å –≥—Ä–∞–Ω–∏—Ü—ã –ø–æ–∏—Å–∫–∞ [left, right]
2. –ù–∞–ø–∏—Å–∞—Ç—å —Ñ—É–Ω–∫—Ü–∏—é –ø—Ä–æ–≤–µ—Ä–∫–∏ condition(mid)
3. –ü—Ä–∏–º–µ–Ω–∏—Ç—å binary search template
4. –í–µ—Ä–Ω—É—Ç—å –Ω–∞–π–¥–µ–Ω–Ω—É—é –≥—Ä–∞–Ω–∏—Ü—É

```

### –†–µ—à–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏ 8

>[–Ω–∞–∑–∞–¥](#-–ø–æ–¥—Å–∫–∞–∑–∫–∏-–¥–ª—è-–æ—Å–Ω–æ–≤–Ω—ã—Ö-–∑–∞–¥–∞—á)

#### üéØ –†–µ—à–µ–Ω–∏–µ Kth Largest Element

üìä –ê–Ω–∞–ª–∏–∑ –∑–∞–¥–∞—á–∏:

```
üìä –ê–ù–ê–õ–ò–ó –ó–ê–î–ê–ß–ò:

–ü–û–ò–°–ö K-–ì–û –ù–ê–ò–ë–û–õ–¨–®–ï–ì–û:
–î–∞–Ω–æ: nums = [3,2,1,5,6,4], k = 2
–†–µ–∑—É–ª—å—Ç–∞—Ç: 5 (–≤—Ç–æ—Ä–æ–π –Ω–∞–∏–±–æ–ª—å—à–∏–π —ç–ª–µ–º–µ–Ω—Ç)
–û–±—ä—è—Å–Ω–µ–Ω–∏–µ: –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π = [6,5,4,3,2,1], 2-–π —ç–ª–µ–º–µ–Ω—Ç = 5

–î–∞–Ω–æ: nums = [3,2,3,1,2,4,5,5,6], k = 4  
–†–µ–∑—É–ª—å—Ç–∞—Ç: 4 (—á–µ—Ç–≤–µ—Ä—Ç—ã–π –Ω–∞–∏–±–æ–ª—å—à–∏–π —ç–ª–µ–º–µ–Ω—Ç)
–û–±—ä—è—Å–Ω–µ–Ω–∏–µ: –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π = [6,5,5,4,3,3,2,2,1], 4-–π —ç–ª–µ–º–µ–Ω—Ç = 4

–í–ê–ñ–ù–û: –∏—â–µ–º k-–π –Ω–∞–∏–±–æ–ª—å—à–∏–π –≤ –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ,
–ù–ï k-–π —É–Ω–∏–∫–∞–ª—å–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç!
```

*"QuickSelect - —ç—Ç–æ –º–æ–¥–∏—Ñ–∏–∫–∞—Ü–∏—è QuickSort, –≥–¥–µ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –æ–¥–Ω—É —Å—Ç–æ—Ä–æ–Ω—É –æ—Ç pivot. –ö–ª—é—á–µ–≤—ã–µ –º–æ–º–µ–Ω—Ç—ã: —Ä–∞–Ω–¥–æ–º–∏–∑–∞—Ü–∏—è pivot –¥–ª—è O(n) —Å—Ä–µ–¥–Ω–µ–≥–æ –≤—Ä–µ–º–µ–Ω–∏, –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π partitioning –∏ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ k-–π –Ω–∞–∏–±–æ–ª—å—à–∏–π –≤ (n-k)-–π –Ω–∞–∏–º–µ–Ω—å—à–∏–π. –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–∞ - Min-Heap —Ä–∞–∑–º–µ—Ä–∞ k –¥–ª—è O(n log k) —Å –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–π –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å—é."*

üéØ –û–±—ä—è—Å–Ω–µ–Ω–∏–µ —Ä–µ—à–µ–Ω–∏—è:

üß† –õ–æ–≥–∏–∫–∞ QuickSelect:

1. üîß –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –∑–∞–¥–∞—á–∏: k-–π –Ω–∞–∏–±–æ–ª—å—à–∏–π = (n-k)-–π –Ω–∞–∏–º–µ–Ω—å—à–∏–π
2. üé≤ –†–∞–Ω–¥–æ–º–∏–∑–∞—Ü–∏—è pivot: –∏–∑–±–µ–≥–∞–µ–º O(n¬≤) –Ω–∞ –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –º–∞—Å—Å–∏–≤–∞—Ö
3. üîß Partitioning: —Ä–∞–∑–¥–µ–ª—è–µ–º –º–∞—Å—Å–∏–≤ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –æ–ø–æ—Ä–Ω–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞
4. üéØ –°—Ä–∞–≤–Ω–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–π: –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –Ω—É–∂–Ω—É—é –ø–æ–ª–æ–≤–∏–Ω—É
5. üîÑ –†–µ–∫—É—Ä—Å–∏—è: –ø–æ–≤—Ç–æ—Ä—è–µ–º –¥–æ –Ω–∞—Ö–æ–∂–¥–µ–Ω–∏—è —Ü–µ–ª–µ–≤–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞

```go
import (
    "container/heap"
    "math/rand"
    "time"
)

// ‚úÖ –û–ü–¢–ò–ú–ê–õ–¨–ù–û–ï –†–ï–®–ï–ù–ò–ï - QuickSelect
func findKthLargest(nums []int, k int) int {
    // üîß –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –∑–∞–¥–∞—á—É: k-–π –Ω–∞–∏–±–æ–ª—å—à–∏–π = (n-k)-–π –Ω–∞–∏–º–µ–Ω—å—à–∏–π
    return quickSelect(nums, 0, len(nums)-1, len(nums)-k)
}

func quickSelect(nums []int, left, right, k int) int {
    // üé≤ –†–∞–Ω–¥–æ–º–∏–∑–∞—Ü–∏—è pivot –¥–ª—è –ª—É—á—à–µ–π –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
    randomPivot := left + rand.Intn(right-left+1)
    nums[randomPivot], nums[right] = nums[right], nums[randomPivot]
    
    // üîß Partitioning: —Ä–∞–∑–¥–µ–ª—è–µ–º –º–∞—Å—Å–∏–≤ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ pivot
    pivotIndex := partition(nums, left, right)
    
    if pivotIndex == k {
        return nums[pivotIndex]  // üéØ –ù–∞—à–ª–∏ k-–π —ç–ª–µ–º–µ–Ω—Ç!
    } else if pivotIndex < k {
        // üîç –ò—Å–∫–æ–º—ã–π —ç–ª–µ–º–µ–Ω—Ç —Å–ø—Ä–∞–≤–∞ –æ—Ç pivot
        return quickSelect(nums, pivotIndex+1, right, k)
    } else {
        // üîç –ò—Å–∫–æ–º—ã–π —ç–ª–µ–º–µ–Ω—Ç —Å–ª–µ–≤–∞ –æ—Ç pivot  
        return quickSelect(nums, left, pivotIndex-1, k)
    }
}

func partition(nums []int, left, right int) int {
    pivot := nums[right]  // –ü–æ—Å–ª–µ–¥–Ω–∏–π —ç–ª–µ–º–µ–Ω—Ç –∫–∞–∫ pivot
    i := left            // –£–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ –º–µ—Å—Ç–æ –¥–ª—è —Å–ª–µ–¥—É—é—â–µ–≥–æ –º–∞–ª–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞
    
    // üîÑ –ü–µ—Ä–µ–º–µ—â–∞–µ–º —ç–ª–µ–º–µ–Ω—Ç—ã –º–µ–Ω—å—à–µ pivot –≤–ª–µ–≤–æ
    for j := left; j < right; j++ {
        if nums[j] <= pivot {
            nums[i], nums[j] = nums[j], nums[i]
            i++
        }
    }
    
    // üîß –ü–æ–º–µ—â–∞–µ–º pivot –Ω–∞ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–µ –º–µ—Å—Ç–æ
    nums[i], nums[right] = nums[right], nums[i]
    return i
}

// ‚úÖ –ê–õ–¨–¢–ï–†–ù–ê–¢–ò–í–ê - Min-Heap —Ä–∞–∑–º–µ—Ä–∞ k (–≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å)
type MinHeap []int

func (h MinHeap) Len() int           { return len(h) }
func (h MinHeap) Less(i, j int) bool { return h[i] < h[j] }
func (h MinHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }

func (h *MinHeap) Push(x interface{}) {
    *h = append(*h, x.(int))
}

func (h *MinHeap) Pop() interface{} {
    old := *h
    n := len(old)
    x := old[n-1]
    *h = old[0 : n-1]
    return x
}

func findKthLargestHeap(nums []int, k int) int {
    // üèóÔ∏è –°–æ–∑–¥–∞–µ–º min-heap —Ä–∞–∑–º–µ—Ä–∞ k
    h := &MinHeap{}
    heap.Init(h)
    
    for _, num := range nums {
        heap.Push(h, num)
        
        // üîß –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä heap = k
        if h.Len() > k {
            heap.Pop(h)  // –£–¥–∞–ª—è–µ–º –Ω–∞–∏–º–µ–Ω—å—à–∏–π —ç–ª–µ–º–µ–Ω—Ç
        }
    }
    
    // üéØ –ö–æ—Ä–µ–Ω—å min-heap —Å–æ–¥–µ—Ä–∂–∏—Ç k-–π –Ω–∞–∏–±–æ–ª—å—à–∏–π —ç–ª–µ–º–µ–Ω—Ç
    return (*h)[0]
}

// üöÄ –ò–¢–ï–†–ê–¢–ò–í–ù–ê–Ø –í–ï–†–°–ò–Ø QuickSelect (–∏–∑–±–µ–≥–∞–µ—Ç recursion overhead)
func findKthLargestIterative(nums []int, k int) int {
    left, right := 0, len(nums)-1
    target := len(nums) - k
    
    for left <= right {
        // –†–∞–Ω–¥–æ–º–∏–∑–∞—Ü–∏—è pivot
        randomPivot := left + rand.Intn(right-left+1)
        nums[randomPivot], nums[right] = nums[right], nums[randomPivot]
        
        pivotIndex := partition(nums, left, right)
        
        if pivotIndex == target {
            return nums[pivotIndex]
        } else if pivotIndex < target {
            left = pivotIndex + 1
        } else {
            right = pivotIndex - 1
        }
    }
    
    return nums[target]
}

// üéØ –£–õ–£–ß–®–ï–ù–ù–´–ô QuickSelect —Å 3-way partitioning (–¥–ª—è –¥—É–±–ª–∏–∫–∞—Ç–æ–≤)
func findKthLargestThreeWay(nums []int, k int) int {
    target := len(nums) - k
    left, right := 0, len(nums)-1
    
    for left <= right {
        // –†–∞–Ω–¥–æ–º–∏–∑–∞—Ü–∏—è
        randomPivot := left + rand.Intn(right-left+1)
        nums[randomPivot], nums[right] = nums[right], nums[randomPivot]
        
        // 3-way partitioning
        lt, gt := threeWayPartition(nums, left, right)
        
        if target >= lt && target <= gt {
            return nums[target]  // target –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ —Ä–∞–≤–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤
        } else if target < lt {
            right = lt - 1
        } else {
            left = gt + 1
        }
    }
    
    return nums[target]
}

func threeWayPartition(nums []int, left, right int) (int, int) {
    pivot := nums[right]
    lt := left      // –í—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã [left, lt) < pivot
    gt := right     // –í—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã (gt, right] > pivot
    i := left       // –¢–µ–∫—É—â–∏–π –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º—ã–π —ç–ª–µ–º–µ–Ω—Ç
    
    for i < gt {
        if nums[i] < pivot {
            nums[lt], nums[i] = nums[i], nums[lt]
            lt++
            i++
        } else if nums[i] > pivot {
            gt--
            nums[i], nums[gt] = nums[gt], nums[i]
            // –ù–µ —É–≤–µ–ª–∏—á–∏–≤–∞–µ–º i, —Ç.–∫. –Ω—É–∂–Ω–æ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –æ–±–º–µ–Ω–µ–Ω–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç
        } else {
            i++  // nums[i] == pivot
        }
    }
    
    // –ü–æ–º–µ—â–∞–µ–º pivot –≤ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–µ –º–µ—Å—Ç–æ
    nums[gt], nums[right] = nums[right], nums[gt]
    return lt, gt
}

func init() {
    // üé≤ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º random seed
    rand.Seed(time.Now().UnixNano())
}
```

```bash
üéØ –ê–õ–ì–û–†–ò–¢–ú QuickSelect:

1. üîß –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ: k-–π –Ω–∞–∏–±–æ–ª—å—à–∏–π = (n-k)-–π –Ω–∞–∏–º–µ–Ω—å—à–∏–π –≤ 0-indexed
2. üé≤ –†–∞–Ω–¥–æ–º–∏–∑–∞—Ü–∏—è pivot –¥–ª—è –∏–∑–±–µ–∂–∞–Ω–∏—è O(n¬≤) –≤ —Ö—É–¥—à–µ–º —Å–ª—É—á–∞–µ
3. üîß Partitioning: —Ä–∞–∑–¥–µ–ª—è–µ–º –º–∞—Å—Å–∏–≤ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ pivot
4. üéØ –°—Ä–∞–≤–Ω–∏–≤–∞–µ–º poz–∏—Ü–∏—é pivot —Å —Ü–µ–ª–µ–≤–æ–π:
   - –ï—Å–ª–∏ —Ä–∞–≤–Ω–æ ‚Üí –Ω–∞—à–ª–∏ –æ—Ç–≤–µ—Ç
   - –ï—Å–ª–∏ –º–µ–Ω—å—à–µ ‚Üí –∏—â–µ–º –≤ –ø—Ä–∞–≤–æ–π —á–∞—Å—Ç–∏  
   - –ï—Å–ª–∏ –±–æ–ª—å—à–µ ‚Üí –∏—â–µ–º –≤ –ª–µ–≤–æ–π —á–∞—Å—Ç–∏
5. üîÑ –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –Ω—É–∂–Ω—É—é –ø–æ–ª–æ–≤–∏–Ω—É

üîë –ö–õ–Æ–ß–ï–í–´–ï –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–ò:

–†–ê–ù–î–û–ú–ò–ó–ê–¶–ò–Ø PIVOT:
- –ò–∑–±–µ–≥–∞–µ—Ç O(n¬≤) –Ω–∞ –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –º–∞—Å—Å–∏–≤–∞—Ö
- –ì–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç O(n) —Å—Ä–µ–¥–Ω–µ–µ –≤—Ä–µ–º—è

3-WAY PARTITIONING:
- –≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –¥—É–±–ª–∏–∫–∞—Ç—ã
- –≠–ª–µ–º–µ–Ω—Ç—ã —Ä–∞–≤–Ω—ã–µ pivot –≥—Ä—É–ø–ø–∏—Ä—É—é—Ç—Å—è –≤–º–µ—Å—Ç–µ

–ò–¢–ï–†–ê–¢–ò–í–ù–ê–Ø –í–ï–†–°–ò–Ø:
- –ò–∑–±–µ–≥–∞–µ—Ç overhead —Ä–µ–∫—É—Ä—Å–∏–∏
- –≠–∫–æ–Ω–æ–º–∏—Ç –ø–∞–º—è—Ç—å —Å—Ç–µ–∫–∞

‚ö° –°–†–ê–í–ù–ï–ù–ò–ï –ü–û–î–•–û–î–û–í:

QuickSelect:
- –í—Ä–µ–º—è: O(n) —Å—Ä–µ–¥–Ω–µ–µ, O(n¬≤) —Ö—É–¥—à–∏–π —Å–ª—É—á–∞–π
- –ü–∞–º—è—Ç—å: O(1) –∏—Ç–µ—Ä–∞—Ç–∏–≤–Ω—ã–π, O(log n) —Ä–µ–∫—É—Ä—Å–∏–≤–Ω—ã–π
- –ú–æ–¥–∏—Ñ–∏—Ü–∏—Ä—É–µ—Ç –∏—Å—Ö–æ–¥–Ω—ã–π –º–∞—Å—Å–∏–≤

Min-Heap:
- –í—Ä–µ–º—è: O(n log k) –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ
- –ü–∞–º—è—Ç—å: O(k)  
- –ù–µ –º–æ–¥–∏—Ñ–∏—Ü–∏—Ä—É–µ—Ç –∏—Å—Ö–æ–¥–Ω—ã–π –º–∞—Å—Å–∏–≤

–°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ + –∏–Ω–¥–µ–∫—Å:
- –í—Ä–µ–º—è: O(n log n)
- –ü–∞–º—è—Ç—å: O(1) –∏–ª–∏ O(n) –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –∞–ª–≥–æ—Ä–∏—Ç–º–∞
- –ü—Ä–æ—Å—Ç–æ—Ç–∞ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏

üí° –í–´–ë–û–† –ü–û–î–•–û–î–ê:
- QuickSelect: –∫–æ–≥–¥–∞ –Ω—É–∂–Ω–∞ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å
- Min-Heap: –∫–æ–≥–¥–∞ k –Ω–∞–º–Ω–æ–≥–æ –º–µ–Ω—å—à–µ n –∏–ª–∏ –Ω—É–∂–Ω–∞ —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç—å
- Sort: –∫–æ–≥–¥–∞ –ø—Ä–æ—Å—Ç–æ—Ç–∞ –≤–∞–∂–Ω–µ–µ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏

üé≠ –ü–†–ò–ú–ï–ù–ï–ù–ò–Ø:
- –ú–µ–¥–∏–∞–Ω–∞ –º–∞—Å—Å–∏–≤–∞ (k = n/2)
- Top-K —ç–ª–µ–º–µ–Ω—Ç–æ–≤
- Percentile –≤—ã—á–∏—Å–ª–µ–Ω–∏—è
- Streaming –∞–ª–≥–æ—Ä–∏—Ç–º—ã —Å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω–æ–π –ø–∞–º—è—Ç—å—é

‚ö†Ô∏è –ì–†–ê–ù–ò–ß–ù–´–ï –°–õ–£–ß–ê–ò:
- k = 1 ‚Üí –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç
- k = n ‚Üí –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç  
- –í—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã –æ–¥–∏–Ω–∞–∫–æ–≤—ã–µ ‚Üí –ª—é–±–æ–π —ç–ª–µ–º–µ–Ω—Ç
- k > n ‚Üí –Ω–µ–≤–∞–ª–∏–¥–Ω—ã–π input
```

### –†–µ—à–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏ 9

>[–Ω–∞–∑–∞–¥](#-–ø–æ–¥—Å–∫–∞–∑–∫–∏-–¥–ª—è-–æ—Å–Ω–æ–≤–Ω—ã—Ö-–∑–∞–¥–∞—á)

#### –†–µ—à–µ–Ω–∏–µ Valid Parentheses

üìä –ê–Ω–∞–ª–∏–∑ –∑–∞–¥–∞—á–∏:

```
üìä –ê–ù–ê–õ–ò–ó –ó–ê–î–ê–ß–ò:

–í–ê–õ–ò–î–ù–´–ï –°–¢–†–û–ö–ò:
–î–∞–Ω–æ: s = "()"
–†–µ–∑—É–ª—å—Ç–∞—Ç: true (–ø—Ä–æ—Å—Ç–∞—è –ø–∞—Ä–∞ —Å–∫–æ–±–æ–∫)

–î–∞–Ω–æ: s = "()[]{}"  
–†–µ–∑—É–ª—å—Ç–∞—Ç: true (–≤—Å–µ —Ç–∏–ø—ã —Å–∫–æ–±–æ–∫ –ø—Ä–∞–≤–∏–ª—å–Ω–æ –≤–ª–æ–∂–µ–Ω—ã)

–î–∞–Ω–æ: s = "{[]}"
–†–µ–∑—É–ª—å—Ç–∞—Ç: true (–ø—Ä–∞–≤–∏–ª—å–Ω–æ–µ –≤–ª–æ–∂–µ–Ω–∏–µ)

–ù–ï–í–ê–õ–ò–î–ù–´–ï –°–¢–†–û–ö–ò:
–î–∞–Ω–æ: s = "([)]"
–†–µ–∑—É–ª—å—Ç–∞—Ç: false (–Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ–µ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ —Å–∫–æ–±–æ–∫)

–î–∞–Ω–æ: s = "((("
–†–µ–∑—É–ª—å—Ç–∞—Ç: false (–Ω–µ–∑–∞–∫—Ä—ã—Ç—ã–µ —Å–∫–æ–±–∫–∏)

–î–∞–Ω–æ: s = ")))"
–†–µ–∑—É–ª—å—Ç–∞—Ç: false (–ª–∏—à–Ω–∏–µ –∑–∞–∫—Ä—ã–≤–∞—é—â–∏–µ)

–ü–†–ê–í–ò–õ–ê:
- –û—Ç–∫—Ä—ã–≤–∞—é—â–∏–µ —Å–∫–æ–±–∫–∏: '(', '[', '{'
- –ó–∞–∫—Ä—ã–≤–∞—é—â–∏–µ —Å–∫–æ–±–∫–∏: ')', ']', '}'  
- –ö–∞–∂–¥–∞—è –æ—Ç–∫—Ä—ã–≤–∞—é—â–∞—è –¥–æ–ª–∂–Ω–∞ –∏–º–µ—Ç—å —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â—É—é –∑–∞–∫—Ä—ã–≤–∞—é—â—É—é
- –°–∫–æ–±–∫–∏ –¥–æ–ª–∂–Ω—ã –∑–∞–∫—Ä—ã–≤–∞—Ç—å—Å—è –≤ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ
```

*"–ö–ª–∞—Å—Å–∏—á–µ—Å–∫–∞—è –∑–∞–¥–∞—á–∞ –Ω–∞ —Å—Ç–µ–∫. –ö–ª—é—á–µ–≤–∞—è –∏–¥–µ—è: —Å—Ç–µ–∫ —Ö—Ä–∞–Ω–∏—Ç –æ—Ç–∫—Ä—ã–≤–∞—é—â–∏–µ —Å–∫–æ–±–∫–∏ –≤ –ø–æ—Ä—è–¥–∫–µ –∏—Ö –ø–æ—è–≤–ª–µ–Ω–∏—è. –ü—Ä–∏ –∑–∞–∫—Ä—ã–≤–∞—é—â–µ–π —Å–∫–æ–±–∫–µ –ø—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ —Å –ø–æ—Å–ª–µ–¥–Ω–µ–π –æ—Ç–∫—Ä—ã–≤–∞—é—â–µ–π. –û–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø—Ä–æ–≤–µ—Ä–∫–∏: –ø—É—Å—Ç–æ—Ç–∞ —Å—Ç–µ–∫–∞ –∏ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ —Ç–∏–ø–æ–≤. –í –∫–æ–Ω—Ü–µ —Å—Ç–µ–∫ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø—É—Å—Ç—ã–º. O(n) –≤—Ä–µ–º—è –∏ –ø–∞–º—è—Ç—å."*

üéØ –û–±—ä—è—Å–Ω–µ–Ω–∏–µ —Ä–µ—à–µ–Ω–∏—è:
üß† –õ–æ–≥–∏–∫–∞ Stack –ø–æ–¥—Ö–æ–¥–∞:

1. üó∫Ô∏è –ú–∞–ø–ø–∏–Ω–≥ —Å–∫–æ–±–æ–∫: —Å–æ–∑–¥–∞–µ–º —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ –∑–∞–∫—Ä—ã–≤–∞—é—â–∏—Ö ‚Üí –æ—Ç–∫—Ä—ã–≤–∞—é—â–∏—Ö
2. üìö –°—Ç–µ–∫: –æ—Ç—Å–ª–µ–∂–∏–≤–∞–µ–º –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å –æ—Ç–∫—Ä—ã–≤–∞—é—â–∏—Ö —Å–∫–æ–±–æ–∫
3. üîÑ –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–∏–º–≤–æ–ª–æ–≤: push –æ—Ç–∫—Ä—ã–≤–∞—é—â–∏–µ, –ø—Ä–æ–≤–µ—Ä—è–µ–º –∏ pop –∑–∞–∫—Ä—ã–≤–∞—é—â–∏–µ
4. üéØ –§–∏–Ω–∞–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞: —Å—Ç–µ–∫ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø—É—Å—Ç—ã–º

```go
// ‚úÖ –û–ü–¢–ò–ú–ê–õ–¨–ù–û–ï –†–ï–®–ï–ù–ò–ï - Stack approach
func isValid(s string) bool {
    // üó∫Ô∏è –ú–∞–ø–ø–∏–Ω–≥ –∑–∞–∫—Ä—ã–≤–∞—é—â–∏—Ö —Å–∫–æ–±–æ–∫ –∫ –æ—Ç–∫—Ä—ã–≤–∞—é—â–∏–º
    pairs := map[rune]rune{
        ')': '(',
        ']': '[', 
        '}': '{',
    }
    
    // üìö –°—Ç–µ–∫ –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –æ—Ç–∫—Ä—ã–≤–∞—é—â–∏—Ö —Å–∫–æ–±–æ–∫
    var stack []rune
    
    // üîÑ –ü—Ä–æ—Ö–æ–¥–∏–º –ø–æ –∫–∞–∂–¥–æ–º—É —Å–∏–º–≤–æ–ª—É
    for _, char := range s {
        // üîç –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–∏–ø —Å–∏–º–≤–æ–ª–∞
        if opening, isClosing := pairs[char]; isClosing {
            // üìù –ó–∞–∫—Ä—ã–≤–∞—é—â–∞—è —Å–∫–æ–±–∫–∞
            
            // ‚ö†Ô∏è –ü—Ä–æ–≤–µ—Ä—è–µ–º: –µ—Å—Ç—å –ª–∏ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∞—è –æ—Ç–∫—Ä—ã–≤–∞—é—â–∞—è?
            if len(stack) == 0 || stack[len(stack)-1] != opening {
                return false  // –ù–µ—Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ –∏–ª–∏ –ø—É—Å—Ç–æ–π —Å—Ç–µ–∫
            }
            
            // ‚úÖ –£–¥–∞–ª—è–µ–º —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â—É—é –æ—Ç–∫—Ä—ã–≤–∞—é—â—É—é —Å–∫–æ–±–∫—É
            stack = stack[:len(stack)-1]  // Pop –æ–ø–µ—Ä–∞—Ü–∏—è
            
        } else {
            // üìù –û—Ç–∫—Ä—ã–≤–∞—é—â–∞—è —Å–∫–æ–±–∫–∞ - –¥–æ–±–∞–≤–ª—è–µ–º –≤ —Å—Ç–µ–∫
            stack = append(stack, char)  // Push –æ–ø–µ—Ä–∞—Ü–∏—è
        }
    }
    
    // üéØ –í–∞–ª–∏–¥–Ω–∞ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –≤—Å–µ —Å–∫–æ–±–∫–∏ –∑–∞–∫—Ä—ã—Ç—ã (—Å—Ç–µ–∫ –ø—É—Å—Ç)
    return len(stack) == 0
}

// üöÄ –ê–õ–¨–¢–ï–†–ù–ê–¢–ò–í–ù–ê–Ø –†–ï–ê–õ–ò–ó–ê–¶–ò–Ø —Å —è–≤–Ω–æ–π –ø—Ä–æ–≤–µ—Ä–∫–æ–π —Ç–∏–ø–æ–≤
func isValidExplicit(s string) bool {
    var stack []rune
    
    for _, char := range s {
        switch char {
        case '(', '[', '{':
            // üìù –û—Ç–∫—Ä—ã–≤–∞—é—â–∞—è —Å–∫–æ–±–∫–∞
            stack = append(stack, char)
            
        case ')', ']', '}':
            // üìù –ó–∞–∫—Ä—ã–≤–∞—é—â–∞—è —Å–∫–æ–±–∫–∞
            if len(stack) == 0 {
                return false  // –ù–µ—Ç —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–µ–π –æ—Ç–∫—Ä—ã–≤–∞—é—â–µ–π
            }
            
            // üîç –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ —Ç–∏–ø–æ–≤
            top := stack[len(stack)-1]
            if !isMatchingPair(top, char) {
                return false
            }
            
            // ‚úÖ –£–±–∏—Ä–∞–µ–º –æ—Ç–∫—Ä—ã–≤–∞—é—â—É—é —Å–∫–æ–±–∫—É
            stack = stack[:len(stack)-1]
            
        default:
            // üö´ –ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Å–∏–º–≤–æ–ª (–µ—Å–ª–∏ —Ç—Ä–µ–±—É–µ—Ç—Å—è –æ–±—Ä–∞–±–æ—Ç–∫–∞)
            return false
        }
    }
    
    return len(stack) == 0
}

// üîß Helper —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏—è –ø–∞—Ä
func isMatchingPair(opening, closing rune) bool {
    return (opening == '(' && closing == ')') ||
           (opening == '[' && closing == ']') ||
           (opening == '{' && closing == '}')
}

// üéØ –†–ê–°–®–ò–†–ï–ù–ù–ê–Ø –í–ï–†–°–ò–Ø - –æ–±—Ä–∞–±–æ—Ç–∫–∞ –ª—é–±—ã—Ö —Å–∏–º–≤–æ–ª–æ–≤
func isValidMixed(s string) bool {
    pairs := map[rune]rune{')': '(', ']': '[', '}': '{'}
    openBrackets := map[rune]bool{'(': true, '[': true, '{': true}
    
    var stack []rune
    
    for _, char := range s {
        if openBrackets[char] {
            // –û—Ç–∫—Ä—ã–≤–∞—é—â–∞—è —Å–∫–æ–±–∫–∞
            stack = append(stack, char)
        } else if opening, isClosing := pairs[char]; isClosing {
            // –ó–∞–∫—Ä—ã–≤–∞—é—â–∞—è —Å–∫–æ–±–∫–∞  
            if len(stack) == 0 || stack[len(stack)-1] != opening {
                return false
            }
            stack = stack[:len(stack)-1]
        }
        // –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –æ—Å—Ç–∞–ª—å–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã
    }
    
    return len(stack) == 0
}

// üîß Stack —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–ª—è –±–æ–ª–µ–µ —è–≤–Ω–æ–π —Ä–∞–±–æ—Ç—ã
type Stack struct {
    items []rune
}

func (s *Stack) Push(item rune) {
    s.items = append(s.items, item)
}

func (s *Stack) Pop() (rune, bool) {
    if len(s.items) == 0 {
        return 0, false
    }
    
    index := len(s.items) - 1
    item := s.items[index]
    s.items = s.items[:index]
    return item, true
}

func (s *Stack) IsEmpty() bool {
    return len(s.items) == 0
}

func (s *Stack) Peek() (rune, bool) {
    if len(s.items) == 0 {
        return 0, false
    }
    return s.items[len(s.items)-1], true
}

// üöÄ –†–ï–®–ï–ù–ò–ï —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º Stack —Å—Ç—Ä—É–∫—Ç—É—Ä—ã
func isValidWithStack(s string) bool {
    pairs := map[rune]rune{')': '(', ']': '[', '}': '{'}
    stack := &Stack{}
    
    for _, char := range s {
        if opening, isClosing := pairs[char]; isClosing {
            // –ó–∞–∫—Ä—ã–≤–∞—é—â–∞—è —Å–∫–æ–±–∫–∞
            if top, ok := stack.Pop(); !ok || top != opening {
                return false
            }
        } else {
            // –û—Ç–∫—Ä—ã–≤–∞—é—â–∞—è —Å–∫–æ–±–∫–∞
            stack.Push(char)
        }
    }
    
    return stack.IsEmpty()
}
```

```bash
üéØ –ê–õ–ì–û–†–ò–¢–ú Valid Parentheses:

1. üó∫Ô∏è –°–æ–∑–¥–∞–µ–º mapping –∑–∞–∫—Ä—ã–≤–∞—é—â–∏—Ö ‚Üí –æ—Ç–∫—Ä—ã–≤–∞—é—â–∏—Ö —Å–∫–æ–±–æ–∫
2. üìö –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –ø—É—Å—Ç–æ–π —Å—Ç–µ–∫
3. üîÑ –î–ª—è –∫–∞–∂–¥–æ–≥–æ —Å–∏–º–≤–æ–ª–∞ –≤ —Å—Ç—Ä–æ–∫–µ:
   a) üìù –ï—Å–ª–∏ –æ—Ç–∫—Ä—ã–≤–∞—é—â–∞—è —Å–∫–æ–±–∫–∞ ‚Üí Push –≤ —Å—Ç–µ–∫
   b) üìù –ï—Å–ª–∏ –∑–∞–∫—Ä—ã–≤–∞—é—â–∞—è —Å–∫–æ–±–∫–∞:
      - –ü—Ä–æ–≤–µ—Ä—è–µ–º: —Å—Ç–µ–∫ –Ω–µ –ø—É—Å—Ç?
      - –ü—Ä–æ–≤–µ—Ä—è–µ–º: top —Å—Ç–µ–∫–∞ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç —Ç–∏–ø—É?
      - Pop –∏–∑ —Å—Ç–µ–∫–∞
   c) üö´ –ï—Å–ª–∏ –Ω–µ—Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ ‚Üí return false
4. üéØ –í –∫–æ–Ω—Ü–µ: —Å—Ç–µ–∫ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø—É—Å—Ç–æ–π

üîë –ö–õ–Æ–ß–ï–í–´–ï –ü–†–û–í–ï–†–ö–ò:

–ü–£–°–¢–û–ô –°–¢–ï–ö –ø—Ä–∏ –∑–∞–∫—Ä—ã–≤–∞—é—â–µ–π —Å–∫–æ–±–∫–µ:
- –û–∑–Ω–∞—á–∞–µ—Ç –ª–∏—à–Ω—é—é –∑–∞–∫—Ä—ã–≤–∞—é—â—É—é —Å–∫–æ–±–∫—É
- –ü—Ä–∏–º–µ—Ä: ")" –∏–ª–∏ "())"

–ù–ï–°–û–û–¢–í–ï–¢–°–¢–í–ò–ï –¢–ò–ü–û–í:
- Top —Å—Ç–µ–∫–∞ –Ω–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç –∑–∞–∫—Ä—ã–≤–∞—é—â–µ–π —Å–∫–æ–±–∫–µ  
- –ü—Ä–∏–º–µ—Ä: "([)]" - '[' –≤ —Å—Ç–µ–∫–µ, –Ω–æ –ø—Ä–∏—à–ª–∞ ')'

–ù–ï–ü–£–°–¢–û–ô –°–¢–ï–ö –≤ –∫–æ–Ω—Ü–µ:
- –û—Å—Ç–∞–ª–∏—Å—å –Ω–µ–∑–∞–∫—Ä—ã—Ç—ã–µ —Å–∫–æ–±–∫–∏
- –ü—Ä–∏–º–µ—Ä: "(((" –∏–ª–∏ "([{"

‚ö° –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–ò:

–ò–°–ü–û–õ–¨–ó–û–í–ê–ù–ò–ï MAP:
- O(1) –ø—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏—è —Ç–∏–ø–æ–≤
- –ë–æ–ª–µ–µ —á–∏—Ç–∞–µ–º—ã–π –∫–æ–¥ —á–µ–º switch/if

SLICE –∫–∞–∫ –°–¢–ï–ö:
- append() –¥–ª—è push
- slice[:len-1] –¥–ª—è pop  
- len() –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø—É—Å—Ç–æ—Ç—ã

–†–ê–ù–ù–ï–ï –ó–ê–í–ï–†–®–ï–ù–ò–ï:
- Return false —Å—Ä–∞–∑—É –ø—Ä–∏ –Ω–µ—Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–∏
- –ù–µ –Ω—É–∂–Ω–æ –ø—Ä–æ–≤–µ—Ä—è—Ç—å –≤—Å—é —Å—Ç—Ä–æ–∫—É

üé≠ –í–ê–†–ò–ê–¶–ò–ò –ó–ê–î–ê–ß–ò:
- –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –¥–ª—è –≤–∞–ª–∏–¥–Ω–æ—Å—Ç–∏
- –ü–æ–¥—Å—á–µ—Ç –≤–∞–ª–∏–¥–Ω—ã—Ö –ø–æ–¥—Å—Ç—Ä–æ–∫
- –ë–∞–ª–∞–Ω—Å —Å–∫–æ–±–æ–∫ –≤ –≤—ã—Ä–∞–∂–µ–Ω–∏—è—Ö
- Nested —Å—Ç—Ä—É–∫—Ç—É—Ä—ã (XML, JSON)

üí° –ü–†–ò–ú–ï–ù–ï–ù–ò–Ø:
- –ü–∞—Ä—Å–µ—Ä—ã —è–∑—ã–∫–æ–≤ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è
- –í–∞–ª–∏–¥–∞—Ü–∏—è JSON/XML
- –ú–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ –≤—ã—Ä–∞–∂–µ–Ω–∏—è
- IDE –ø—Ä–æ–≤–µ—Ä–∫–∞ —Å–∏–Ω—Ç–∞–∫—Å–∏—Å–∞

‚ö†Ô∏è –ì–†–ê–ù–ò–ß–ù–´–ï –°–õ–£–ß–ê–ò:
- –ü—É—Å—Ç–∞—è —Å—Ç—Ä–æ–∫–∞ ‚Üí true (–Ω–µ—Ç —Å–∫–æ–±–æ–∫ = –≤–∞–ª–∏–¥–Ω–æ)
- –û–¥–Ω–∞ —Å–∫–æ–±–∫–∞ ‚Üí false  
- –¢–æ–ª—å–∫–æ –æ—Ç–∫—Ä—ã–≤–∞—é—â–∏–µ ‚Üí false
- –¢–æ–ª—å–∫–æ –∑–∞–∫—Ä—ã–≤–∞—é—â–∏–µ ‚Üí false
- –°–º–µ—à–∞–Ω–Ω—ã–µ —Å –¥—Ä—É–≥–∏–º–∏ —Å–∏–º–≤–æ–ª–∞–º–∏ ‚Üí –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º –∏–ª–∏ –æ—à–∏–±–∫–∞

üîß –°–õ–û–ñ–ù–û–°–¢–¨:
- –í—Ä–µ–º—è: O(n) - –æ–¥–∏–Ω –ø—Ä–æ—Ö–æ–¥ –ø–æ —Å—Ç—Ä–æ–∫–µ
- –ü–∞–º—è—Ç—å: O(n) - –≤ —Ö—É–¥—à–µ–º —Å–ª—É—á–∞–µ –≤—Å–µ —Å–∏–º–≤–æ–ª—ã –≤ —Å—Ç–µ–∫–µ
```

### –†–µ—à–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏ 10

>[–Ω–∞–∑–∞–¥](#-–ø–æ–¥—Å–∫–∞–∑–∫–∏-–¥–ª—è-–æ—Å–Ω–æ–≤–Ω—ã—Ö-–∑–∞–¥–∞—á)

#### üéØ –†–µ—à–µ–Ω–∏–µ Greatest Common Divisor

üìä –ê–Ω–∞–ª–∏–∑ –∑–∞–¥–∞—á–∏:

```
üìä –ê–ù–ê–õ–ò–ó –ó–ê–î–ê–ß–ò:

–ü–û–ò–°–ö –ù–û–î (GCD):
–î–∞–Ω–æ: a = 48, b = 18
–†–µ–∑—É–ª—å—Ç–∞—Ç: 6 (–Ω–∞–∏–±–æ–ª—å—à–∏–π –æ–±—â–∏–π –¥–µ–ª–∏—Ç–µ–ª—å)
–û–±—ä—è—Å–Ω–µ–Ω–∏–µ: –¥–µ–ª–∏—Ç–µ–ª–∏ 48 = [1,2,3,4,6,8,12,16,24,48]
            –¥–µ–ª–∏—Ç–µ–ª–∏ 18 = [1,2,3,6,9,18]  
            –æ–±—â–∏–µ = [1,2,3,6], –Ω–∞–∏–±–æ–ª—å—à–∏–π = 6

–î–∞–Ω–æ: a = 17, b = 13  
–†–µ–∑—É–ª—å—Ç–∞—Ç: 1 (–≤–∑–∞–∏–º–Ω–æ –ø—Ä–æ—Å—Ç—ã–µ —á–∏—Å–ª–∞)

–î–∞–Ω–æ: a = 0, b = 5
–†–µ–∑—É–ª—å—Ç–∞—Ç: 5 (gcd(0, n) = n)

–ü–†–ò–ú–ï–ù–ï–ù–ò–Ø:
- –£–ø—Ä–æ—â–µ–Ω–∏–µ –¥—Ä–æ–±–µ–π: 12/18 = 4/6 (–ø–æ–¥–µ–ª–∏—Ç—å –Ω–∞ gcd(12,18)=6)
- –í—ã—á–∏—Å–ª–µ–Ω–∏–µ LCM: lcm(a,b) = (a*b) / gcd(a,b)
- –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–∑–∞–∏–º–Ω–æ–π –ø—Ä–æ—Å—Ç–æ—Ç—ã: gcd(a,b) = 1
- –ö—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏—è: –∞–ª–≥–æ—Ä–∏—Ç–º RSA
```

*"–ê–ª–≥–æ—Ä–∏—Ç–º –ï–≤–∫–ª–∏–¥–∞ –æ—Å–Ω–æ–≤–∞–Ω –Ω–∞ —Å–≤–æ–π—Å—Ç–≤–µ gcd(a,b) = gcd(b, a%b). –†–∞–±–æ—Ç–∞–µ—Ç –ø–æ–∫–∞ –æ–¥–∏–Ω –∏–∑ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤ –Ω–µ —Å—Ç–∞–Ω–µ—Ç –Ω—É–ª–µ–º. –õ–æ–≥–∞—Ä–∏—Ñ–º–∏—á–µ—Å–∫–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å O(log min(a,b)) –±–ª–∞–≥–æ–¥–∞—Ä—è –±—ã—Å—Ç—Ä–æ–º—É —É–º–µ–Ω—å—à–µ–Ω–∏—é –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤. –ü—Ä–∏–º–µ–Ω—è–µ—Ç—Å—è –¥–ª—è —É–ø—Ä–æ—â–µ–Ω–∏—è –¥—Ä–æ–±–µ–π, –≤—ã—á–∏—Å–ª–µ–Ω–∏—è LCM, –ø—Ä–æ–≤–µ—Ä–∫–∏ –≤–∑–∞–∏–º–Ω–æ–π –ø—Ä–æ—Å—Ç–æ—Ç—ã."*

üéØ –û–±—ä—è—Å–Ω–µ–Ω–∏–µ —Ä–µ—à–µ–Ω–∏—è:

üß† –õ–æ–≥–∏–∫–∞ –∞–ª–≥–æ—Ä–∏—Ç–º–∞ –ï–≤–∫–ª–∏–¥–∞:

1. üîë –û—Å–Ω–æ–≤–Ω–∞—è —Ñ–æ—Ä–º—É–ª–∞: gcd(a,b) = gcd(b, a%b)
2. üõë –ë–∞–∑–æ–≤—ã–π —Å–ª—É—á–∞–π: gcd(a,0) = a
3. üîÑ –ò—Ç–µ—Ä–∞—Ü–∏—è: –∑–∞–º–µ–Ω—è–µ–º –ø–∞—Ä—É (a,b) –Ω–∞ (b, a%b)
4. üéØ –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ: –∫–æ–≥–¥–∞ –æ–¥–∏–Ω –∏–∑ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤ —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è 0

```go
// ‚úÖ –û–ü–¢–ò–ú–ê–õ–¨–ù–û–ï –†–ï–®–ï–ù–ò–ï - –ê–ª–≥–æ—Ä–∏—Ç–º –ï–≤–∫–ª–∏–¥–∞ (—Ä–µ–∫—É—Ä—Å–∏–≤–Ω—ã–π)
func gcd(a, b int) int {
    // üõë –ë–∞–∑–æ–≤—ã–π —Å–ª—É—á–∞–π: –µ—Å–ª–∏ –æ–¥–∏–Ω –∏–∑ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤ 0
    if b == 0 {
        return a
    }
    
    // üîÑ –†–µ–∫—É—Ä—Å–∏–≤–Ω—ã–π –≤—ã–∑–æ–≤: gcd(a,b) = gcd(b, a%b)
    return gcd(b, a%b)
}

// üöÄ –ò–¢–ï–†–ê–¢–ò–í–ù–ê–Ø –í–ï–†–°–ò–Ø (–∏–∑–±–µ–≥–∞–µ—Ç —Ä–µ–∫—É—Ä—Å–∏—é)
func gcdIterative(a, b int) int {
    // üîÑ –ü–æ–∫–∞ –≤—Ç–æ—Ä–æ–π –∞—Ä–≥—É–º–µ–Ω—Ç –Ω–µ —Ä–∞–≤–µ–Ω 0
    for b != 0 {
        // üíæ –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ—Å—Ç–∞—Ç–æ–∫
        remainder := a % b
        
        // üîÑ –°–¥–≤–∏–≥–∞–µ–º –∑–Ω–∞—á–µ–Ω–∏—è: (a,b) ‚Üí (b, a%b)
        a = b
        b = remainder
    }
    
    return a
}

// üéØ –û–ë–†–ê–ë–û–¢–ö–ê –û–¢–†–ò–¶–ê–¢–ï–õ–¨–ù–´–• –ß–ò–°–ï–õ
func gcdSafe(a, b int) int {
    // üîß –ü—Ä–∏–≤–æ–¥–∏–º –∫ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–º –∑–Ω–∞—á–µ–Ω–∏—è–º
    if a < 0 {
        a = -a
    }
    if b < 0 {
        b = -b
    }
    
    // üìä –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –∞–ª–≥–æ—Ä–∏—Ç–º –ï–≤–∫–ª–∏–¥–∞
    return gcd(a, b)
}

// üåü –†–ê–°–®–ò–†–ï–ù–ù–´–ô –ê–õ–ì–û–†–ò–¢–ú –ï–í–ö–õ–ò–î–ê - –Ω–∞—Ö–æ–¥–∏—Ç –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç—ã x, y
// –¢–∞–∫–∏–µ —á—Ç–æ: gcd(a,b) = a*x + b*y (—É—Ä–∞–≤–Ω–µ–Ω–∏–µ –ë–µ–∑—É)
func extendedGCD(a, b int) (gcd, x, y int) {
    if b == 0 {
        // –ë–∞–∑–æ–≤—ã–π —Å–ª—É—á–∞–π: gcd(a,0) = a, –≥–¥–µ a*1 + 0*0 = a
        return a, 1, 0
    }
    
    // –†–µ–∫—É—Ä—Å–∏–≤–Ω—ã–π –≤—ã–∑–æ–≤
    gcd1, x1, y1 := extendedGCD(b, a%b)
    
    // üîß –û–±–Ω–æ–≤–ª—è–µ–º –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç—ã:
    // x = y1
    // y = x1 - (a/b) * y1
    x = y1
    y = x1 - (a/b)*y1
    
    return gcd1, x, y
}

// üìä –ù–ê–ò–ú–ï–ù–¨–®–ï–ï –û–ë–©–ï–ï –ö–†–ê–¢–ù–û–ï (LCM) —á–µ—Ä–µ–∑ GCD
func lcm(a, b int) int {
    if a == 0 || b == 0 {
        return 0
    }
    
    // üí° –§–æ—Ä–º—É–ª–∞: lcm(a,b) = |a*b| / gcd(a,b)
    gcdValue := gcdSafe(a, b)
    
    // üîß –ò–∑–±–µ–≥–∞–µ–º –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏—è: –¥–µ–ª–∏–º —Å–Ω–∞—á–∞–ª–∞
    if a < 0 {
        a = -a
    }
    if b < 0 {
        b = -b
    }
    
    return (a / gcdValue) * b
}

// üéØ GCD –¥–ª—è –º–∞—Å—Å–∏–≤–∞ —á–∏—Å–µ–ª
func gcdArray(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
    
    result := nums[0]
    if result < 0 {
        result = -result
    }
    
    // üîÑ gcd(a,b,c) = gcd(gcd(a,b), c)
    for i := 1; i < len(nums); i++ {
        result = gcdSafe(result, nums[i])
        
        // üöÄ –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è: –µ—Å–ª–∏ gcd = 1, –¥–∞–ª—å—à–µ –ø—Ä–æ–≤–µ—Ä—è—Ç—å –Ω–µ –Ω—É–∂–Ω–æ
        if result == 1 {
            break
        }
    }
    
    return result
}

// üîß –ü–†–û–í–ï–†–ö–ê –í–ó–ê–ò–ú–ù–û–ô –ü–†–û–°–¢–û–¢–´
func areCoprime(a, b int) bool {
    return gcdSafe(a, b) == 1
}

// üéØ –£–ü–†–û–©–ï–ù–ò–ï –î–†–û–ë–ò
type Fraction struct {
    Numerator   int
    Denominator int
}

func (f *Fraction) Simplify() {
    if f.Denominator == 0 {
        return // –ù–µ–¥–æ–ø—É—Å—Ç–∏–º–∞—è –¥—Ä–æ–±—å
    }
    
    // üîß –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∑–Ω–∞–∫
    if f.Denominator < 0 {
        f.Numerator = -f.Numerator
        f.Denominator = -f.Denominator
    }
    
    // üìä –ù–∞—Ö–æ–¥–∏–º GCD –∏ —É–ø—Ä–æ—â–∞–µ–º
    gcdValue := gcdSafe(f.Numerator, f.Denominator)
    f.Numerator /= gcdValue
    f.Denominator /= gcdValue
}

// üöÄ –ë–´–°–¢–†–´–ô GCD —Å –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–µ–π –¥–ª—è –±–æ–ª—å—à–∏—Ö —á–∏—Å–µ–ª
func gcdFast(a, b int) int {
    if a == 0 {
        return b
    }
    if b == 0 {
        return a
    }
    
    // üîß –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–µ —á–∏—Å–ª–∞
    if a < 0 {
        a = -a
    }
    if b < 0 {
        b = -b
    }
    
    // üöÄ –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è: —É–±–∏—Ä–∞–µ–º —Å—Ç–µ–ø–µ–Ω–∏ –¥–≤–æ–π–∫–∏
    // gcd(2^k * a, 2^j * b) = 2^min(k,j) * gcd(a,b)
    zeros := 0
    for a&1 == 0 && b&1 == 0 {
        a >>= 1
        b >>= 1
        zeros++
    }
    
    // –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –∞–ª–≥–æ—Ä–∏—Ç–º –ï–≤–∫–ª–∏–¥–∞
    for b != 0 {
        a, b = b, a%b
    }
    
    return a << zeros
}

// üé≠ –ú–û–î–£–õ–¨–ù–ê–Ø –ê–†–ò–§–ú–ï–¢–ò–ö–ê - –æ–±—Ä–∞—Ç–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç
func modularInverse(a, mod int) int {
    gcdValue, x, _ := extendedGCD(a, mod)
    
    if gcdValue != 1 {
        return -1 // –û–±—Ä–∞—Ç–Ω–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
    }
    
    // üîß –ü—Ä–∏–≤–æ–¥–∏–º –∫ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–º—É –∑–Ω–∞—á–µ–Ω–∏—é
    return ((x % mod) + mod) % mod
}

// üîß Helper —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏
func findAllDivisors(n int) []int {
    if n < 0 {
        n = -n
    }
    
    var divisors []int
    for i := 1; i*i <= n; i++ {
        if n%i == 0 {
            divisors = append(divisors, i)
            if i != n/i {
                divisors = append(divisors, n/i)
            }
        }
    }
    
    return divisors
}
```

```bash
üéØ –ê–õ–ì–û–†–ò–¢–ú –ï–í–ö–õ–ò–î–ê:

–û–°–ù–û–í–ù–ê–Ø –ò–î–ï–Ø:
gcd(a, b) = gcd(b, a mod b)

–î–û–ö–ê–ó–ê–¢–ï–õ–¨–°–¢–í–û:
–ü—É—Å—Ç—å d = gcd(a,b). –¢–æ–≥–¥–∞:
- a = d*k1, b = d*k2 –¥–ª—è –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö k1, k2
- a mod b = a - (a/b)*b = d*k1 - (a/b)*d*k2 = d*(k1 - (a/b)*k2)
- –ó–Ω–∞—á–∏—Ç d —Ç–∞–∫–∂–µ –¥–µ–ª–∏—Ç (a mod b)
- –û–±—Ä–∞—Ç–Ω–æ–µ —É—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –¥–æ–∫–∞–∑—ã–≤–∞–µ—Ç—Å—è –∞–Ω–∞–ª–æ–≥–∏—á–Ω–æ

–ë–ê–ó–û–í–´–ô –°–õ–£–ß–ê–ô:
gcd(a, 0) = a (–ª—é–±–æ–µ —á–∏—Å–ª–æ –¥–µ–ª–∏—Ç—Å—è –Ω–∞ —Å–∞–º–æ —Å–µ–±—è)

üîë –ö–õ–Æ–ß–ï–í–´–ï –°–í–û–ô–°–¢–í–ê:

–ö–û–ú–ú–£–¢–ê–¢–ò–í–ù–û–°–¢–¨:
gcd(a, b) = gcd(b, a)

–ê–°–°–û–¶–ò–ê–¢–ò–í–ù–û–°–¢–¨:  
gcd(a, b, c) = gcd(gcd(a, b), c)

–î–ò–°–¢–†–ò–ë–£–¢–ò–í–ù–û–°–¢–¨:
gcd(k*a, k*b) = k * gcd(a, b)

–°–í–Ø–ó–¨ –° LCM:
lcm(a, b) * gcd(a, b) = a * b

‚ö° –°–õ–û–ñ–ù–û–°–¢–¨:
- –í—Ä–µ–º—è: O(log min(a, b)) - –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∏—Ç–µ—Ä–∞—Ü–∏–π –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–æ
- –ü–∞–º—è—Ç—å: O(1) –∏—Ç–µ—Ä–∞—Ç–∏–≤–Ω–æ, O(log min(a, b)) —Ä–µ–∫—É—Ä—Å–∏–≤–Ω–æ

üé≠ –ü–†–ò–ú–ï–ù–ï–ù–ò–Ø:

–£–ü–†–û–©–ï–ù–ò–ï –î–†–û–ë–ï–ô:
numerator/denominator ‚Üí (numerator/gcd)/(denominator/gcd)

–í–´–ß–ò–°–õ–ï–ù–ò–ï LCM:
lcm(a, b) = (a * b) / gcd(a, b)

–ú–û–î–£–õ–¨–ù–ê–Ø –ê–†–ò–§–ú–ï–¢–ò–ö–ê:
–ù–∞—Ö–æ–∂–¥–µ–Ω–∏–µ –æ–±—Ä–∞—Ç–Ω–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞ —á–µ—Ä–µ–∑ —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π –∞–ª–≥–æ—Ä–∏—Ç–º

–ö–†–ò–ü–¢–û–ì–†–ê–§–ò–Ø:
RSA –∞–ª–≥–æ—Ä–∏—Ç–º –∏—Å–ø–æ–ª—å–∑—É–µ—Ç gcd –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –≤–∑–∞–∏–º–Ω–æ–π –ø—Ä–æ—Å—Ç–æ—Ç—ã

üí° –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–ò:

–ë–ò–ù–ê–†–ù–´–ô GCD:
–ò—Å–ø–æ–ª—å–∑—É–µ—Ç –±–∏—Ç–æ–≤—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ –≤–º–µ—Å—Ç–æ –¥–µ–ª–µ–Ω–∏—è –ø–æ –º–æ–¥—É–ª—é
–≠—Ñ—Ñ–µ–∫—Ç–∏–≤–µ–Ω –¥–ª—è –æ—á–µ–Ω—å –±–æ–ª—å—à–∏—Ö —á–∏—Å–µ–ª

–†–ê–ù–ù–ï–ï –ó–ê–í–ï–†–®–ï–ù–ò–ï:
–ï—Å–ª–∏ gcd –º–∞—Å—Å–∏–≤–∞ —Å—Ç–∞–ª —Ä–∞–≤–µ–Ω 1, –¥–∞–ª—å—à–µ –ø—Ä–æ–≤–µ—Ä—è—Ç—å –Ω–µ –Ω—É–∂–Ω–æ

–û–ë–†–ê–ë–û–¢–ö–ê –ó–ù–ê–ö–û–í:
gcd –≤—Å–µ–≥–¥–∞ –ø–æ–ª–æ–∂–∏—Ç–µ–ª–µ–Ω –ø–æ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—é

‚ö†Ô∏è –ì–†–ê–ù–ò–ß–ù–´–ï –°–õ–£–ß–ê–ò:
- gcd(0, n) = n
- gcd(n, 0) = n  
- gcd(0, 0) = 0 (–º–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏ –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ, –Ω–æ —á–∞—Å—Ç–æ –ø—Ä–∏–Ω–∏–º–∞–µ—Ç—Å—è)
- gcd(1, n) = 1
- gcd(n, n) = n

üîß –í–ê–†–ò–ê–¶–ò–ò:
- –†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π –∞–ª–≥–æ—Ä–∏—Ç–º –ï–≤–∫–ª–∏–¥–∞
- –ë–∏–Ω–∞—Ä–Ω—ã–π GCD (–∞–ª–≥–æ—Ä–∏—Ç–º –®—Ç–µ–π–Ω–∞)
- GCD –¥–ª—è –ø–æ–ª–∏–Ω–æ–º–æ–≤
- GCD –º–Ω–æ–∂–µ—Å—Ç–≤–∞ —á–∏—Å–µ–ª
```

### –†–µ—à–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏ 11

>[–Ω–∞–∑–∞–¥](#-–ø–æ–¥—Å–∫–∞–∑–∫–∏-–¥–ª—è-–æ—Å–Ω–æ–≤–Ω—ã—Ö-–∑–∞–¥–∞—á)

#### üéØ –†–µ—à–µ–Ω–∏–µ QuickSort Implementation

üìä –ê–Ω–∞–ª–∏–∑ –∑–∞–¥–∞—á–∏:

```bash
üìä –ê–ù–ê–õ–ò–ó –ó–ê–î–ê–ß–ò:

–°–û–†–¢–ò–†–û–í–ö–ê –ú–ê–°–°–ò–í–ê:
–î–∞–Ω–æ: arr = [64, 34, 25, 12, 22, 11, 90]
–†–µ–∑—É–ª—å—Ç–∞—Ç: [11, 12, 22, 25, 34, 64, 90]

–î–∞–Ω–æ: arr = [3, 6, 8, 10, 1, 2, 1]  
–†–µ–∑—É–ª—å—Ç–∞—Ç: [1, 1, 2, 3, 6, 8, 10]

–ü–†–ò–ù–¶–ò–ü –†–ê–ë–û–¢–´:
1. –í—ã–±–∏—Ä–∞–µ–º pivot —ç–ª–µ–º–µ–Ω—Ç
2. –†–∞–∑–¥–µ–ª—è–µ–º –º–∞—Å—Å–∏–≤: —ç–ª–µ–º–µ–Ω—Ç—ã ‚â§ pivot —Å–ª–µ–≤–∞, > pivot —Å–ø—Ä–∞–≤–∞  
3. –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ —Å–æ—Ä—Ç–∏—Ä—É–µ–º –ª–µ–≤—É—é –∏ –ø—Ä–∞–≤—É—é —á–∞—Å—Ç–∏
4. –†–µ–∑—É–ª—å—Ç–∞—Ç: –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –º–∞—Å—Å–∏–≤

–°–•–ï–ú–´ PARTITIONING:
- Lomuto: –ø—Ä–æ—Å—Ç–∞—è, pivot –≤—Å–µ–≥–¥–∞ —Å–ø—Ä–∞–≤–∞
- Hoare: –±–æ–ª–µ–µ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–∞—è, –¥–≤—É—Ö—Å—Ç–æ—Ä–æ–Ω–Ω–∏–µ —É–∫–∞–∑–∞—Ç–µ–ª–∏
- 3-way: –¥–ª—è –º–∞—Å—Å–∏–≤–æ–≤ —Å –¥—É–±–ª–∏–∫–∞—Ç–∞–º–∏
```

*"QuickSort –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –ø—Ä–∏–Ω—Ü–∏–ø '—Ä–∞–∑–¥–µ–ª—è–π –∏ –≤–ª–∞—Å—Ç–≤—É–π'. –ö–ª—é—á–µ–≤—ã–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã: –≤—ã–±–æ—Ä pivot, partitioning –≤–æ–∫—Ä—É–≥ –Ω–µ–≥–æ, —Ä–µ–∫—É—Ä—Å–∏–≤–Ω–∞—è —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ —á–∞—Å—Ç–µ–π. –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏ –≤–∞–∂–Ω–∞ —Ä–∞–Ω–¥–æ–º–∏–∑–∞—Ü–∏—è pivot –¥–ª—è –∏–∑–±–µ–∂–∞–Ω–∏—è O(n¬≤) –Ω–∞ –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö. Lomuto —Å—Ö–µ–º–∞ –ø—Ä–æ—â–µ –¥–ª—è –ø–æ–Ω–∏–º–∞–Ω–∏—è, 3-way partitioning —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–µ–Ω –¥–ª—è –¥—É–±–ª–∏–∫–∞—Ç–æ–≤. O(n log n) —Å—Ä–µ–¥–Ω–µ–µ –≤—Ä–µ–º—è, in-place —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞."*

üéØ –û–±—ä—è—Å–Ω–µ–Ω–∏–µ —Ä–µ—à–µ–Ω–∏—è:

üß† –õ–æ–≥–∏–∫–∞ "—Ä–∞–∑–¥–µ–ª—è–π –∏ –≤–ª–∞—Å—Ç–≤—É–π":

1. üéØ –í—ã–±–æ—Ä pivot: —Ä–∞–Ω–¥–æ–º–∏–∑–∏—Ä—É–µ–º –¥–ª—è –∏–∑–±–µ–∂–∞–Ω–∏—è O(n¬≤)
2. üîß Partitioning: –ø–µ—Ä–µ—Å—Ç—Ä–∞–∏–≤–∞–µ–º –º–∞—Å—Å–∏–≤ –≤–æ–∫—Ä—É–≥ pivot
3. üîÑ –†–µ–∫—É—Ä—Å–∏—è: —Å–æ—Ä—Ç–∏—Ä—É–µ–º –ª–µ–≤—É—é –∏ –ø—Ä–∞–≤—É—é —á–∞—Å—Ç–∏ –Ω–µ–∑–∞–≤–∏—Å–∏–º–æ
4. ‚úÖ –û–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ: –Ω–µ –Ω—É–∂–Ω–æ! –ú–∞—Å—Å–∏–≤ —É–∂–µ –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω in-place

```go
import (
    "math/rand"
    "time"
)

// ‚úÖ –ö–õ–ê–°–°–ò–ß–ï–°–ö–ò–ô QUICKSORT —Å Lomuto partitioning
func quickSort(arr []int) {
    if len(arr) <= 1 {
        return
    }
    quickSortHelper(arr, 0, len(arr)-1)
}

func quickSortHelper(arr []int, low, high int) {
    if low < high {
        // üîß Partitioning: —Ä–∞–∑–¥–µ–ª—è–µ–º –º–∞—Å—Å–∏–≤ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ pivot
        pivotIndex := lomutoPartition(arr, low, high)
        
        // üîÑ –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ —Å–æ—Ä—Ç–∏—Ä—É–µ–º —á–∞—Å—Ç–∏
        quickSortHelper(arr, low, pivotIndex-1)   // –õ–µ–≤–∞—è —á–∞—Å—Ç—å
        quickSortHelper(arr, pivotIndex+1, high)  // –ü—Ä–∞–≤–∞—è —á–∞—Å—Ç—å
    }
}

// üìä LOMUTO PARTITIONING - –ø—Ä–æ—Å—Ç–∞—è —Å—Ö–µ–º–∞
func lomutoPartition(arr []int, low, high int) int {
    // üéØ Pivot - –ø–æ—Å–ª–µ–¥–Ω–∏–π —ç–ª–µ–º–µ–Ω—Ç
    pivot := arr[high]
    
    // üìç i - –≥—Ä–∞–Ω–∏—Ü–∞ –º–µ–∂–¥—É –º–∞–ª—ã–º–∏ –∏ –±–æ–ª—å—à–∏–º–∏ —ç–ª–µ–º–µ–Ω—Ç–∞–º–∏
    i := low - 1
    
    // üîÑ –ü–µ—Ä–µ–º–µ—â–∞–µ–º —ç–ª–µ–º–µ–Ω—Ç—ã ‚â§ pivot –≤ –Ω–∞—á–∞–ª–æ
    for j := low; j < high; j++ {
        if arr[j] <= pivot {
            i++
            arr[i], arr[j] = arr[j], arr[i]
        }
    }
    
    // üîß –ü–æ–º–µ—â–∞–µ–º pivot –Ω–∞ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–µ –º–µ—Å—Ç–æ
    arr[i+1], arr[high] = arr[high], arr[i+1]
    return i + 1
}

// üöÄ –û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–ù–´–ô QUICKSORT —Å —Ä–∞–Ω–¥–æ–º–∏–∑–∞—Ü–∏–µ–π
func quickSortRandomized(arr []int) {
    if len(arr) <= 1 {
        return
    }
    quickSortRandomizedHelper(arr, 0, len(arr)-1)
}

func quickSortRandomizedHelper(arr []int, low, high int) {
    if low < high {
        // üé≤ –†–∞–Ω–¥–æ–º–∏–∑–∞—Ü–∏—è pivot –¥–ª—è –ª—É—á—à–µ–π –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
        randomIndex := low + rand.Intn(high-low+1)
        arr[randomIndex], arr[high] = arr[high], arr[randomIndex]
        
        pivotIndex := lomutoPartition(arr, low, high)
        
        quickSortRandomizedHelper(arr, low, pivotIndex-1)
        quickSortRandomizedHelper(arr, pivotIndex+1, high)
    }
}

// ‚ö° HOARE PARTITIONING - –±–æ–ª–µ–µ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–∞—è —Å—Ö–µ–º–∞
func quickSortHoare(arr []int) {
    if len(arr) <= 1 {
        return
    }
    quickSortHoareHelper(arr, 0, len(arr)-1)
}

func quickSortHoareHelper(arr []int, low, high int) {
    if low < high {
        // üé≤ –†–∞–Ω–¥–æ–º–∏–∑–∞—Ü–∏—è
        randomIndex := low + rand.Intn(high-low+1)
        arr[randomIndex], arr[low] = arr[low], arr[randomIndex]
        
        pivotIndex := hoarePartition(arr, low, high)
        
        quickSortHoareHelper(arr, low, pivotIndex)     // ‚ö†Ô∏è pivotIndex, –Ω–µ pivotIndex-1
        quickSortHoareHelper(arr, pivotIndex+1, high)
    }
}

func hoarePartition(arr []int, low, high int) int {
    // üéØ Pivot - –ø–µ—Ä–≤—ã–π —ç–ª–µ–º–µ–Ω—Ç
    pivot := arr[low]
    
    // üìç –î–≤—É—Ö—Å—Ç–æ—Ä–æ–Ω–Ω–∏–µ —É–∫–∞–∑–∞—Ç–µ–ª–∏
    i := low - 1
    j := high + 1
    
    for {
        // üîç –ù–∞—Ö–æ–¥–∏–º —ç–ª–µ–º–µ–Ω—Ç —Å–ª–µ–≤–∞ –±–æ–ª—å—à–µ pivot
        for {
            i++
            if arr[i] >= pivot {
                break
            }
        }
        
        // üîç –ù–∞—Ö–æ–¥–∏–º —ç–ª–µ–º–µ–Ω—Ç —Å–ø—Ä–∞–≤–∞ –º–µ–Ω—å—à–µ pivot
        for {
            j--
            if arr[j] <= pivot {
                break
            }
        }
        
        // üõë –ï—Å–ª–∏ —É–∫–∞–∑–∞—Ç–µ–ª–∏ –≤—Å—Ç—Ä–µ—Ç–∏–ª–∏—Å—å
        if i >= j {
            return j
        }
        
        // üîÑ –û–±–º–µ–Ω–∏–≤–∞–µ–º —ç–ª–µ–º–µ–Ω—Ç—ã
        arr[i], arr[j] = arr[j], arr[i]
    }
}

// üåü 3-WAY PARTITIONING –¥–ª—è –º–∞—Å—Å–∏–≤–æ–≤ —Å –¥—É–±–ª–∏–∫–∞—Ç–∞–º–∏
func quickSort3Way(arr []int) {
    if len(arr) <= 1 {
        return
    }
    quickSort3WayHelper(arr, 0, len(arr)-1)
}

func quickSort3WayHelper(arr []int, low, high int) {
    if low < high {
        // üé≤ –†–∞–Ω–¥–æ–º–∏–∑–∞—Ü–∏—è
        randomIndex := low + rand.Intn(high-low+1)
        arr[randomIndex], arr[high] = arr[high], arr[randomIndex]
        
        // üîß 3-way partitioning: <pivot, =pivot, >pivot
        lt, gt := threeWayPartition(arr, low, high)
        
        // üîÑ –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ —Å–æ—Ä—Ç–∏—Ä—É–µ–º —Ç–æ–ª—å–∫–æ —á–∞—Å—Ç–∏ —Å <pivot –∏ >pivot
        quickSort3WayHelper(arr, low, lt-1)    // –≠–ª–µ–º–µ–Ω—Ç—ã < pivot
        quickSort3WayHelper(arr, gt+1, high)   // –≠–ª–µ–º–µ–Ω—Ç—ã > pivot
        // –≠–ª–µ–º–µ–Ω—Ç—ã = pivot —É–∂–µ –Ω–∞ —Å–≤–æ–∏—Ö –º–µ—Å—Ç–∞—Ö!
    }
}

func threeWayPartition(arr []int, low, high int) (int, int) {
    pivot := arr[high]
    lt := low      // –í—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã [low, lt) < pivot
    gt := high     // –í—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã (gt, high] > pivot  
    i := low       // –¢–µ–∫—É—â–∏–π —ç–ª–µ–º–µ–Ω—Ç
    
    for i < gt {
        if arr[i] < pivot {
            arr[lt], arr[i] = arr[i], arr[lt]
            lt++
            i++
        } else if arr[i] > pivot {
            gt--
            arr[i], arr[gt] = arr[gt], arr[i]
            // –ù–µ —É–≤–µ–ª–∏—á–∏–≤–∞–µ–º i - –Ω—É–∂–Ω–æ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –æ–±–º–µ–Ω–µ–Ω–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç
        } else {
            i++  // arr[i] == pivot
        }
    }
    
    // üîß –ü–æ–º–µ—â–∞–µ–º pivot –≤ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–µ –º–µ—Å—Ç–æ
    arr[gt], arr[high] = arr[high], arr[gt]
    return lt, gt
}

// üéØ –ò–¢–ï–†–ê–¢–ò–í–ù–ê–Ø –í–ï–†–°–ò–Ø (–∏–∑–±–µ–≥–∞–µ—Ç —Ä–µ–∫—É—Ä—Å–∏—é)
func quickSortIterative(arr []int) {
    if len(arr) <= 1 {
        return
    }
    
    // üìö –°—Ç–µ–∫ –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –≥—Ä–∞–Ω–∏—Ü –ø–æ–¥–º–∞—Å—Å–∏–≤–æ–≤
    type bounds struct{ low, high int }
    stack := []bounds{{0, len(arr) - 1}}
    
    for len(stack) > 0 {
        // üì§ Pop –≥—Ä–∞–Ω–∏—Ü—ã –∏–∑ —Å—Ç–µ–∫–∞
        current := stack[len(stack)-1]
        stack = stack[:len(stack)-1]
        
        low, high := current.low, current.high
        
        if low < high {
            // üé≤ –†–∞–Ω–¥–æ–º–∏–∑–∞—Ü–∏—è
            randomIndex := low + rand.Intn(high-low+1)
            arr[randomIndex], arr[high] = arr[high], arr[randomIndex]
            
            pivotIndex := lomutoPartition(arr, low, high)
            
            // üì• Push –Ω–æ–≤—ã–µ –≥—Ä–∞–Ω–∏—Ü—ã –≤ —Å—Ç–µ–∫
            stack = append(stack, bounds{low, pivotIndex - 1})
            stack = append(stack, bounds{pivotIndex + 1, high})
        }
    }
}

// üîß –ì–ò–ë–†–ò–î–ù–´–ô QUICKSORT (QuickSort + InsertionSort –¥–ª—è –º–∞–ª—ã—Ö –º–∞—Å—Å–∏–≤–æ–≤)
const insertionSortThreshold = 10

func quickSortHybrid(arr []int) {
    if len(arr) <= 1 {
        return
    }
    quickSortHybridHelper(arr, 0, len(arr)-1)
}

func quickSortHybridHelper(arr []int, low, high int) {
    if low < high {
        // üîß –î–ª—è –º–∞–ª—ã—Ö –º–∞—Å—Å–∏–≤–æ–≤ –∏—Å–ø–æ–ª—å–∑—É–µ–º insertion sort
        if high - low + 1 <= insertionSortThreshold {
            insertionSort(arr, low, high)
            return
        }
        
        // üé≤ –†–∞–Ω–¥–æ–º–∏–∑–∞—Ü–∏—è
        randomIndex := low + rand.Intn(high-low+1)
        arr[randomIndex], arr[high] = arr[high], arr[randomIndex]
        
        pivotIndex := lomutoPartition(arr, low, high)
        
        quickSortHybridHelper(arr, low, pivotIndex-1)
        quickSortHybridHelper(arr, pivotIndex+1, high)
    }
}

func insertionSort(arr []int, low, high int) {
    for i := low + 1; i <= high; i++ {
        key := arr[i]
        j := i - 1
        
        for j >= low && arr[j] > key {
            arr[j+1] = arr[j]
            j--
        }
        arr[j+1] = key
    }
}

// üéØ QUICKSELECT (–Ω–∞–π—Ç–∏ k-–π —ç–ª–µ–º–µ–Ω—Ç –±–µ–∑ –ø–æ–ª–Ω–æ–π —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏)
func quickSelect(arr []int, k int) int {
    if k < 0 || k >= len(arr) {
        return -1  // –ù–µ–¥–æ–ø—É—Å—Ç–∏–º—ã–π –∏–Ω–¥–µ–∫—Å
    }
    
    return quickSelectHelper(arr, 0, len(arr)-1, k)
}

func quickSelectHelper(arr []int, low, high, k int) int {
    if low == high {
        return arr[low]
    }
    
    // üé≤ –†–∞–Ω–¥–æ–º–∏–∑–∞—Ü–∏—è
    randomIndex := low + rand.Intn(high-low+1)
    arr[randomIndex], arr[high] = arr[high], arr[randomIndex]
    
    pivotIndex := lomutoPartition(arr, low, high)
    
    if pivotIndex == k {
        return arr[pivotIndex]
    } else if pivotIndex > k {
        return quickSelectHelper(arr, low, pivotIndex-1, k)
    } else {
        return quickSelectHelper(arr, pivotIndex+1, high, k)
    }
}

func init() {
    // üé≤ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º random seed
    rand.Seed(time.Now().UnixNano())
}
```

```bash
üéØ –ê–õ–ì–û–†–ò–¢–ú QUICKSORT:

–û–°–ù–û–í–ù–û–ô –ü–†–ò–ù–¶–ò–ü:
1. üéØ –í—ã–±–∏—Ä–∞–µ–º pivot —ç–ª–µ–º–µ–Ω—Ç
2. üîß Partitioning: —Ä–∞–∑–¥–µ–ª—è–µ–º –º–∞—Å—Å–∏–≤ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ pivot
3. üîÑ –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ —Å–æ—Ä—Ç–∏—Ä—É–µ–º –ª–µ–≤—É—é –∏ –ø—Ä–∞–≤—É—é —á–∞—Å—Ç–∏
4. ‚úÖ –ë–∞–∑–æ–≤—ã–π —Å–ª—É—á–∞–π: –º–∞—Å—Å–∏–≤ –∏–∑ 0-1 —ç–ª–µ–º–µ–Ω—Ç–∞ —É–∂–µ –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω

üîë –°–•–ï–ú–´ PARTITIONING:

LOMUTO (–±–æ–ª–µ–µ –ø—Ä–æ—Å—Ç–∞—è):
- Pivot - –ø–æ—Å–ª–µ–¥–Ω–∏–π —ç–ª–µ–º–µ–Ω—Ç
- –û–¥–∏–Ω —É–∫–∞–∑–∞—Ç–µ–ª—å i –æ—Ç—Å–ª–µ–∂–∏–≤–∞–µ—Ç –≥—Ä–∞–Ω–∏—Ü—É
- –ü—Ä–æ—â–µ –ø–æ–Ω—è—Ç—å –∏ —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å
- ~3n —Å—Ä–∞–≤–Ω–µ–Ω–∏–π –≤ —Å—Ä–µ–¥–Ω–µ–º

HOARE (–±–æ–ª–µ–µ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–∞—è):
- Pivot - –ø–µ—Ä–≤—ã–π —ç–ª–µ–º–µ–Ω—Ç  
- –î–≤–∞ —É–∫–∞–∑–∞—Ç–µ–ª—è –¥–≤–∏–∂—É—Ç—Å—è –Ω–∞–≤—Å—Ç—Ä–µ—á—É
- –ú–µ–Ω—å—à–µ –æ–±–º–µ–Ω–æ–≤ (~n/6 –ø—Ä–æ—Ç–∏–≤ ~n/2)
- ~2n —Å—Ä–∞–≤–Ω–µ–Ω–∏–π –≤ —Å—Ä–µ–¥–Ω–µ–º

3-WAY (–¥–ª—è –¥—É–±–ª–∏–∫–∞—Ç–æ–≤):
- –†–∞–∑–¥–µ–ª—è–µ—Ç –Ω–∞ <pivot, =pivot, >pivot
- –≠–ª–µ–º–µ–Ω—Ç—ã —Ä–∞–≤–Ω—ã–µ pivot –Ω–µ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—é—Ç—Å—è –ø–æ–≤—Ç–æ—Ä–Ω–æ
- –û–ø—Ç–∏–º–∞–ª–µ–Ω –¥–ª—è –º–∞—Å—Å–∏–≤–æ–≤ —Å –¥—É–±–ª–∏–∫–∞—Ç–∞–º–∏

‚ö° –°–õ–û–ñ–ù–û–°–¢–¨:

–õ–£–ß–®–ò–ô/–°–†–ï–î–ù–ò–ô –°–õ–£–ß–ê–ô: O(n log n)
- Pivot –¥–µ–ª–∏—Ç –º–∞—Å—Å–∏–≤ –ø–æ–ø–æ–ª–∞–º
- –ì–ª—É–±–∏–Ω–∞ —Ä–µ–∫—É—Ä—Å–∏–∏: log n
- –ö–∞–∂–¥—ã–π —É—Ä–æ–≤–µ–Ω—å: O(n) –æ–ø–µ—Ä–∞—Ü–∏–π

–•–£–î–®–ò–ô –°–õ–£–ß–ê–ô: O(n¬≤)
- Pivot –≤—Å–µ–≥–¥–∞ –Ω–∞–∏–º–µ–Ω—å—à–∏–π/–Ω–∞–∏–±–æ–ª—å—à–∏–π
- –ì–ª—É–±–∏–Ω–∞ —Ä–µ–∫—É—Ä—Å–∏–∏: n
- –ü—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –Ω–∞ –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –º–∞—Å—Å–∏–≤–∞—Ö –±–µ–∑ —Ä–∞–Ω–¥–æ–º–∏–∑–∞—Ü–∏–∏

–ü–ê–ú–Ø–¢–¨: O(log n) —Ä–µ–∫—É—Ä—Å–∏–≤–Ω–æ, O(n) –∏—Ç–µ—Ä–∞—Ç–∏–≤–Ω–æ

üé≤ –†–ê–ù–î–û–ú–ò–ó–ê–¶–ò–Ø –ö–†–ò–¢–ò–ß–ù–ê:
- –ò–∑–±–µ–≥–∞–µ—Ç O(n¬≤) –Ω–∞ –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
- –ì–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç O(n log n) —Å—Ä–µ–¥–Ω–µ–µ –≤—Ä–µ–º—è
- –ü—Ä–æ—Å—Ç–∞—è –∑–∞—â–∏—Ç–∞ –æ—Ç —Ö—É–¥—à–µ–≥–æ —Å–ª—É—á–∞—è

üí° –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–ò:

–ì–ò–ë–†–ò–î–ù–´–ô –ü–û–î–•–û–î:
- QuickSort –¥–ª—è –±–æ–ª—å—à–∏—Ö –º–∞—Å—Å–∏–≤–æ–≤
- InsertionSort –¥–ª—è –º–∞–ª—ã—Ö (<10-20 —ç–ª–µ–º–µ–Ω—Ç–æ–≤)
- –õ—É—á—à–∞—è –∫–æ–Ω—Å—Ç–∞–Ω—Ç–∞ –≤ O(n log n)

–ú–ï–î–ò–ê–ù–ê 3-–•:
- Pivot = median(first, middle, last)
- –õ—É—á—à–µ —Å–ª—É—á–∞–π–Ω–æ–≥–æ –≤—ã–±–æ—Ä–∞
- –ò–∑–±–µ–≥–∞–µ—Ç —Ö—É–¥—à–µ–≥–æ —Å–ª—É—á–∞—è

TAIL RECURSION:
- –°–Ω–∞—á–∞–ª–∞ —Å–æ—Ä—Ç–∏—Ä—É–µ–º –º–µ–Ω—å—à—É—é —á–∞—Å—Ç—å
- –ë–æ–ª—å—à—É—é —á–∞—Å—Ç—å –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∏—Ç–µ—Ä–∞—Ç–∏–≤–Ω–æ
- –ì–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç O(log n) –ø–∞–º—è—Ç–∏

üé≠ –ü–†–ò–ú–ï–ù–ï–ù–ò–Ø:
- –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è –±–∏–±–ª–∏–æ—Ç–µ—á–Ω–∞—è —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞
- QuickSelect –¥–ª—è –ø–æ–∏—Å–∫–∞ k-–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞
- –û—Å–Ω–æ–≤–∞ –¥–ª—è –¥—Ä—É–≥–∏—Ö –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤ (IntroSort)

‚ö†Ô∏è –ì–†–ê–ù–ò–ß–ù–´–ï –°–õ–£–ß–ê–ò:
- –ü—É—Å—Ç–æ–π –º–∞—Å—Å–∏–≤ ‚Üí –Ω–∏—á–µ–≥–æ –Ω–µ –¥–µ–ª–∞–µ–º
- –û–¥–∏–Ω —ç–ª–µ–º–µ–Ω—Ç ‚Üí —É–∂–µ –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω
- –í—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã –æ–¥–∏–Ω–∞–∫–æ–≤—ã–µ ‚Üí 3-way partitioning
- –û—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –º–∞—Å—Å–∏–≤ ‚Üí —Ä–∞–Ω–¥–æ–º–∏–∑–∞—Ü–∏—è —Å–ø–∞—Å–∞–µ—Ç

üîß –°–†–ê–í–ù–ï–ù–ò–ï –° –î–†–£–ì–ò–ú–ò –°–û–†–¢–ò–†–û–í–ö–ê–ú–ò:
- –ë—ã—Å—Ç—Ä–µ–µ MergeSort –Ω–∞ –ø—Ä–∞–∫—Ç–∏–∫–µ (–º–µ–Ω—å—à–µ –æ–ø–µ—Ä–∞—Ü–∏–π)
- –ù–µ—Å—Ç–∞–±–∏–ª—å–Ω–∞—è —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ (–≤ –æ—Ç–ª–∏—á–∏–µ –æ—Ç MergeSort)
- In-place (–≤ –æ—Ç–ª–∏—á–∏–µ –æ—Ç MergeSort)
- –•—É–∂–µ –≤ —Ö—É–¥—à–µ–º —Å–ª—É—á–∞–µ (–≤ –æ—Ç–ª–∏—á–∏–µ –æ—Ç HeapSort)
```

### –†–µ—à–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏ 12

>[–Ω–∞–∑–∞–¥](#-–ø–æ–¥—Å–∫–∞–∑–∫–∏-–¥–ª—è-–æ—Å–Ω–æ–≤–Ω—ã—Ö-–∑–∞–¥–∞—á)

#### üéØ –†–µ—à–µ–Ω–∏–µ Linked List Cycle

üìä –ê–Ω–∞–ª–∏–∑ –∑–∞–¥–∞—á–∏:

```bash
üìä –ê–ù–ê–õ–ò–ó –ó–ê–î–ê–ß–ò:

–î–ï–¢–ï–ö–¢–ò–†–û–í–ê–ù–ò–ï –¶–ò–ö–õ–ê:
–î–∞–Ω–æ: 3 ‚Üí 2 ‚Üí 0 ‚Üí -4 ‚Üí ‚Üë
                    ‚Üì     |
                    +-----+
–†–µ–∑—É–ª—å—Ç–∞—Ç: true (–µ—Å—Ç—å —Ü–∏–∫–ª, -4 —É–∫–∞–∑—ã–≤–∞–µ—Ç –Ω–∞ 2)

–î–∞–Ω–æ: 1 ‚Üí 2 ‚Üí NULL
–†–µ–∑—É–ª—å—Ç–∞—Ç: false (–Ω–µ—Ç —Ü–∏–∫–ª–∞)

–î–∞–Ω–æ: 1 ‚Üí ‚Üë
         |_|
–†–µ–∑—É–ª—å—Ç–∞—Ç: true (—É–∑–µ–ª —É–∫–∞–∑—ã–≤–∞–µ—Ç –Ω–∞ —Å–µ–±—è)

–ü–û–ò–°–ö –ù–ê–ß–ê–õ–ê –¶–ò–ö–õ–ê:
–î–ª—è —Å–ø–∏—Å–∫–∞ 3 ‚Üí 2 ‚Üí 0 ‚Üí -4 ‚Üí (—É–∫–∞–∑—ã–≤–∞–µ—Ç –Ω–∞ 2)
–†–µ–∑—É–ª—å—Ç–∞—Ç: —É–∑–µ–ª —Å–æ –∑–Ω–∞—á–µ–Ω–∏–µ–º 2 (–Ω–∞—á–∞–ª–æ —Ü–∏–∫–ª–∞)

–î–õ–ò–ù–ê –¶–ò–ö–õ–ê:
–î–ª—è —Ç–æ–≥–æ –∂–µ —Å–ø–∏—Å–∫–∞: –¥–ª–∏–Ω–∞ —Ü–∏–∫–ª–∞ = 3 (—É–∑–ª—ã 2, 0, -4)
```

*"–ò—Å–ø–æ–ª—å–∑—É—é Ha"–ò—Å–ø–æ–ª—å–∑—É—é –∞–ª–≥–æ—Ä–∏—Ç–º Floyd's Cycle Detection —Å –¥–≤—É–º—è —É–∫–∞–∑–∞—Ç–µ–ª—è–º–∏ —Ä–∞–∑–Ω–æ–π —Å–∫–æ—Ä–æ—Å—Ç–∏. Slow –¥–≤–∏–∂–µ—Ç—Å—è –Ω–∞ 1 —à–∞–≥, fast –Ω–∞ 2. –ï—Å–ª–∏ –µ—Å—Ç—å —Ü–∏–∫–ª, fast –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –¥–æ–≥–æ–Ω–∏—Ç slow –≤–Ω—É—Ç—Ä–∏ –Ω–µ–≥–æ. –ö–ª—é—á–µ–≤–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞: fast.Next != nil –ø–µ—Ä–µ–¥ fast.Next.Next. –î–ª—è –ø–æ–∏—Å–∫–∞ –Ω–∞—á–∞–ª–∞ —Ü–∏–∫–ª–∞: –ø–æ—Å–ª–µ –≤—Å—Ç—Ä–µ—á–∏ –æ–¥–∏–Ω —É–∫–∞–∑–∞—Ç–µ–ª—å –∫ –≥–æ–ª–æ–≤–µ, –¥–≤–∏–∂–µ–º—Å—è —Å –æ–¥–∏–Ω–∞–∫–æ–≤–æ–π —Å–∫–æ—Ä–æ—Å—Ç—å—é. O(n) –≤—Ä–µ–º—è, O(1) –ø–∞–º—è—Ç—å."*

üéØ –û–±—ä—è—Å–Ω–µ–Ω–∏–µ —Ä–µ—à–µ–Ω–∏—è:

üß† –õ–æ–≥–∏–∫–∞ Floyd's Cycle Detection:

1. üê¢üê∞ –î–≤–∞ —É–∫–∞–∑–∞—Ç–µ–ª—è: slow (—à–∞–≥ 1) –∏ fast (—à–∞–≥ 2)
2. üîÑ –î–≤–∏–∂–µ–Ω–∏–µ: –µ—Å–ª–∏ –µ—Å—Ç—å —Ü–∏–∫–ª, fast –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –¥–æ–≥–æ–Ω–∏—Ç slow
3. üéØ –í—Å—Ç—Ä–µ—á–∞: —É–∫–∞–∑–∞—Ç–µ–ª–∏ –≤—Å—Ç—Ä–µ—Ç—è—Ç—Å—è –≤–Ω—É—Ç—Ä–∏ —Ü–∏–∫–ª–∞
4. üìç –ü–æ–∏—Å–∫ –Ω–∞—á–∞–ª–∞: –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è —Ñ–∞–∑–∞ –¥–ª—è –Ω–∞—Ö–æ–∂–¥–µ–Ω–∏—è –≤—Ö–æ–¥–∞ –≤ —Ü–∏–∫–ª

```go
// üìã –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã ListNode
type ListNode struct {
    Val  int
    Next *ListNode
}

// ‚úÖ –û–ü–¢–ò–ú–ê–õ–¨–ù–û–ï –†–ï–®–ï–ù–ò–ï - Floyd's Cycle Detection Algorithm
func hasCycle(head *ListNode) bool {
    if head == nil || head.Next == nil {
        return false // –ú–µ–Ω–µ–µ 2 —É–∑–ª–æ–≤ ‚Üí —Ü–∏–∫–ª–∞ –±—ã—Ç—å –Ω–µ –º–æ–∂–µ—Ç
    }
    
    // üê¢ –ú–µ–¥–ª–µ–Ω–Ω—ã–π —É–∫–∞–∑–∞—Ç–µ–ª—å (—á–µ—Ä–µ–ø–∞—Ö–∞): —à–∞–≥ = 1
    slow := head
    // üê∞ –ë—ã—Å—Ç—Ä—ã–π —É–∫–∞–∑–∞—Ç–µ–ª—å (–∑–∞—è—Ü): —à–∞–≥ = 2  
    fast := head
    
    // üîÑ –î–≤–∏–≥–∞–µ–º —É–∫–∞–∑–∞—Ç–µ–ª–∏ –ø–æ–∫–∞ fast –Ω–µ –¥–æ—Å—Ç–∏–≥–Ω–µ—Ç –∫–æ–Ω—Ü–∞
    for fast != nil && fast.Next != nil {
        slow = slow.Next      // üê¢ –®–∞–≥ 1
        fast = fast.Next.Next // üê∞ –®–∞–≥ 2
        
        // üéØ –ï—Å–ª–∏ —É–∫–∞–∑–∞—Ç–µ–ª–∏ –≤—Å—Ç—Ä–µ—Ç–∏–ª–∏—Å—å ‚Üí –µ—Å—Ç—å —Ü–∏–∫–ª
        if slow == fast {
            return true
        }
    }
    
    return false // fast –¥–æ—Å—Ç–∏–≥ –∫–æ–Ω—Ü–∞ ‚Üí —Ü–∏–∫–ª–∞ –Ω–µ—Ç
}

// üîç –ü–û–ò–°–ö –ù–ê–ß–ê–õ–ê –¶–ò–ö–õ–ê - Floyd's Algorithm Phase 2
func detectCycle(head *ListNode) *ListNode {
    if head == nil || head.Next == nil {
        return nil
    }
    
    // Phase 1: –û–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ —Ü–∏–∫–ª–∞
    slow, fast := head, head
    hasCycleFlag := false
    
    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
        
        if slow == fast {
            hasCycleFlag = true
            break
        }
    }
    
    if !hasCycleFlag {
        return nil // –¶–∏–∫–ª–∞ –Ω–µ—Ç
    }
    
    // Phase 2: –ü–æ–∏—Å–∫ –Ω–∞—á–∞–ª–∞ —Ü–∏–∫–ª–∞
    // üîß –û–¥–∏–Ω —É–∫–∞–∑–∞—Ç–µ–ª—å –∫ –Ω–∞—á–∞–ª—É —Å–ø–∏—Å–∫–∞, –¥—Ä—É–≥–æ–π –æ—Å—Ç–∞–µ—Ç—Å—è –≤ —Ç–æ—á–∫–µ –≤—Å—Ç—Ä–µ—á–∏
    finder := head
    
    // üîÑ –î–≤–∏–≥–∞–µ–º –æ–±–∞ —É–∫–∞–∑–∞—Ç–µ–ª—è —Å –æ–¥–∏–Ω–∞–∫–æ–≤–æ–π —Å–∫–æ—Ä–æ—Å—Ç—å—é
    for finder != slow {
        finder = finder.Next
        slow = slow.Next
    }
    
    return finder // üéØ –ù–∞—á–∞–ª–æ —Ü–∏–∫–ª–∞
}

// üìè –î–õ–ò–ù–ê –¶–ò–ö–õ–ê
func cycleLength(head *ListNode) int {
    if head == nil || head.Next == nil {
        return 0
    }
    
    // –ù–∞—Ö–æ–¥–∏–º —Ç–æ—á–∫—É –≤—Å—Ç—Ä–µ—á–∏
    slow, fast := head, head
    
    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
        
        if slow == fast {
            // üî¢ –°—á–∏—Ç–∞–µ–º –¥–ª–∏–Ω—É —Ü–∏–∫–ª–∞
            length := 1
            current := slow.Next
            
            for current != slow {
                current = current.Next
                length++
            }
            
            return length
        }
    }
    
    return 0 // –¶–∏–∫–ª–∞ –Ω–µ—Ç
}

// üéØ –ü–û–õ–ù–ê–Ø –ò–ù–§–û–†–ú–ê–¶–ò–Ø –û –¶–ò–ö–õ–ï
type CycleInfo struct {
    HasCycle    bool
    StartNode   *ListNode
    Length      int
    MeetingNode *ListNode
}

func analyzeCycle(head *ListNode) CycleInfo {
    info := CycleInfo{}
    
    if head == nil || head.Next == nil {
        return info
    }
    
    // Phase 1: –î–µ—Ç–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ
    slow, fast := head, head
    
    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
        
        if slow == fast {
            info.HasCycle = true
            info.MeetingNode = slow
            break
        }
    }
    
    if !info.HasCycle {
        return info
    }
    
    // Phase 2: –ü–æ–∏—Å–∫ –Ω–∞—á–∞–ª–∞ —Ü–∏–∫–ª–∞
    finder := head
    for finder != slow {
        finder = finder.Next
        slow = slow.Next
    }
    info.StartNode = finder
    
    // Phase 3: –î–ª–∏–Ω–∞ —Ü–∏–∫–ª–∞
    length := 1
    current := info.StartNode.Next
    for current != info.StartNode {
        current = current.Next
        length++
    }
    info.Length = length
    
    return info
}

// üîß –ê–õ–¨–¢–ï–†–ù–ê–¢–ò–í–ê - HashSet –ø–æ–¥—Ö–æ–¥ (O(n) –ø–∞–º—è—Ç—å)
func hasCycleHashSet(head *ListNode) bool {
    visited := make(map[*ListNode]bool)
    
    current := head
    for current != nil {
        if visited[current] {
            return true // –£–∑–µ–ª —É–∂–µ –ø–æ—Å–µ—â–µ–Ω ‚Üí —Ü–∏–∫–ª
        }
        
        visited[current] = true
        current = current.Next
    }
    
    return false
}

// üöÄ –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–Ø - —Ä–∞–Ω–Ω–∏–π –≤—ã—Ö–æ–¥ –ø—Ä–∏ –º–∞–ª—ã—Ö —Å–ø–∏—Å–∫–∞—Ö
func hasCycleFast(head *ListNode) bool {
    // üöÄ –ë—ã—Å—Ç—Ä–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –¥–ª—è –æ—á–µ–Ω—å –∫–æ—Ä–æ—Ç–∫–∏—Ö —Å–ø–∏—Å–∫–æ–≤
    if head == nil {
        return false
    }
    if head.Next == nil {
        return false
    }
    if head.Next.Next == nil {
        return false
    }
    if head.Next.Next == head {
        return true // –¶–∏–∫–ª –¥–ª–∏–Ω—ã 2
    }
    
    // –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π Floyd's –∞–ª–≥–æ—Ä–∏—Ç–º
    slow, fast := head, head.Next.Next
    
    for fast != nil && fast.Next != nil {
        if slow == fast {
            return true
        }
        slow = slow.Next
        fast = fast.Next.Next
    }
    
    return false
}

// üîß Helper —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è —Å–ø–∏—Å–∫–æ–≤ —Å —Ü–∏–∫–ª–∞–º–∏
func createListWithCycle(values []int, cyclePos int) *ListNode {
    if len(values) == 0 {
        return nil
    }
    
    // –°–æ–∑–¥–∞–µ–º —É–∑–ª—ã
    nodes := make([]*ListNode, len(values))
    for i, val := range values {
        nodes[i] = &ListNode{Val: val}
    }
    
    // –°–≤—è–∑—ã–≤–∞–µ–º —É–∑–ª—ã
    for i := 0; i < len(nodes)-1; i++ {
        nodes[i].Next = nodes[i+1]
    }
    
    // –°–æ–∑–¥–∞–µ–º —Ü–∏–∫–ª –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
    if cyclePos >= 0 && cyclePos < len(nodes) {
        nodes[len(nodes)-1].Next = nodes[cyclePos]
    }
    
    return nodes[0]
}

func createListNoCycle(values []int) *ListNode {
    return createListWithCycle(values, -1)
}

// üìä –ü–µ—á–∞—Ç—å —Å–ø–∏—Å–∫–∞ (—Å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ–º –¥–ª—è —Ü–∏–∫–ª–∏—á–µ—Å–∫–∏—Ö)
func printList(head *ListNode, maxNodes int) []int {
    var result []int
    current := head
    count := 0
    
    for current != nil && count < maxNodes {
        result = append(result, current.Val)
        current = current.Next
        count++
    }
    
    return result
}

// üîç –ü–æ–∏—Å–∫ —É–∑–ª–∞ –ø–æ –∑–Ω–∞—á–µ–Ω–∏—é (–¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è)
func findNode(head *ListNode, val int) *ListNode {
    current := head
    for current != nil {
        if current.Val == val {
            return current
        }
        current = current.Next
        
        // –ó–∞—â–∏—Ç–∞ –æ—Ç –±–µ—Å–∫–æ–Ω–µ—á–Ω–æ–≥–æ —Ü–∏–∫–ª–∞
        // –í —Ä–µ–∞–ª—å–Ω–æ—Å—Ç–∏ –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ–º, —Ç–æ–ª—å–∫–æ –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏
    }
    return nil
}
```

```bash
üéØ –ê–õ–ì–û–†–ò–¢–ú FLOYD'S CYCLE DETECTION:

–ü–†–ò–ù–¶–ò–ü "–ß–ï–†–ï–ü–ê–•–ê –ò –ó–ê–Ø–¶":
- Slow pointer (—á–µ—Ä–µ–ø–∞—Ö–∞): –¥–≤–∏–∂–µ—Ç—Å—è –Ω–∞ 1 —à–∞–≥
- Fast pointer (–∑–∞—è—Ü): –¥–≤–∏–∂–µ—Ç—Å—è –Ω–∞ 2 —à–∞–≥–∞  
- –ï—Å–ª–∏ –µ—Å—Ç—å —Ü–∏–∫–ª, fast –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –¥–æ–≥–æ–Ω–∏—Ç slow

–ú–ê–¢–ï–ú–ê–¢–ò–ß–ï–°–ö–û–ï –û–ë–û–°–ù–û–í–ê–ù–ò–ï:
–ü—É—Å—Ç—å —Ü–∏–∫–ª –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è –Ω–∞ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–∏ k –æ—Ç –≥–æ–ª–æ–≤—ã, –¥–ª–∏–Ω–∞ —Ü–∏–∫–ª–∞ = L
- –ö–æ–≥–¥–∞ slow –≤—Ö–æ–¥–∏—Ç –≤ —Ü–∏–∫–ª, fast —É–∂–µ –≤–Ω—É—Ç—Ä–∏
- –û—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å fast –∫ slow = 1 —à–∞–≥ –∑–∞ –∏—Ç–µ—Ä–∞—Ü–∏—é
- –í —Ü–∏–∫–ª–µ –¥–ª–∏–Ω—ã L –æ–Ω–∏ –≤—Å—Ç—Ä–µ—Ç—è—Ç—Å—è –º–∞–∫—Å–∏–º—É–º –∑–∞ L —à–∞–≥–æ–≤

–ü–û–ò–°–ö –ù–ê–ß–ê–õ–ê –¶–ò–ö–õ–ê (Phase 2):
–ü–æ—Å–ª–µ –≤—Å—Ç—Ä–µ—á–∏ –≤ —Ç–æ—á–∫–µ M:
- –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –æ—Ç –≥–æ–ª–æ–≤—ã –¥–æ –Ω–∞—á–∞–ª–∞ —Ü–∏–∫–ª–∞ = k
- –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –æ—Ç M –¥–æ –Ω–∞—á–∞–ª–∞ —Ü–∏–∫–ª–∞ —Ç–∞–∫–∂–µ = k
- –ü–æ—ç—Ç–æ–º—É —É–∫–∞–∑–∞—Ç–µ–ª–∏ —Å –æ–¥–∏–Ω–∞–∫–æ–≤–æ–π —Å–∫–æ—Ä–æ—Å—Ç—å—é –≤—Å—Ç—Ä–µ—Ç—è—Ç—Å—è –≤ –Ω–∞—á–∞–ª–µ

üîë –ö–õ–Æ–ß–ï–í–´–ï –ò–ù–í–ê–†–ò–ê–ù–¢–´:

–ü–†–û–í–ï–†–ö–ê –ì–†–ê–ù–ò–¶:
- fast.Next != nil –ø–µ—Ä–µ–¥ fast.Next.Next
- –ò–Ω–∞—á–µ –±—É–¥–µ—Ç null pointer dereference

–£–°–õ–û–í–ò–ï –¶–ò–ö–õ–ê:
- fast != nil && fast.Next != nil
- –ü–æ–∫—Ä—ã–≤–∞–µ—Ç –≤—Å–µ —Å–ª—É—á–∞–∏ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–≥–æ –¥–≤–∏–∂–µ–Ω–∏—è

–¢–û–ß–ö–ê –í–°–¢–†–ï–ß–ò:
- slow == fast (—Å—Ä–∞–≤–Ω–∏–≤–∞–µ–º —É–∫–∞–∑–∞—Ç–µ–ª–∏, –Ω–µ –∑–Ω–∞—á–µ–Ω–∏—è)
- –í —Ü–∏–∫–ª–µ —É–∫–∞–∑–∞—Ç–µ–ª–∏ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –≤—Å—Ç—Ä–µ—Ç—è—Ç—Å—è

‚ö° –°–õ–û–ñ–ù–û–°–¢–¨:

–í–†–ï–ú–Ø: O(n)
- –í —Ö—É–¥—à–µ–º —Å–ª—É—á–∞–µ slow –ø—Ä–æ—Ö–æ–¥–∏—Ç n —É–∑–ª–æ–≤
- fast –ø—Ä–æ—Ö–æ–¥–∏—Ç –º–∞–∫—Å–∏–º—É–º 2n —É–∑–ª–æ–≤
- –í —Ü–∏–∫–ª–µ –≤—Å—Ç—Ä–µ—á–∞ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –∑–∞ O(L) –≥–¥–µ L - –¥–ª–∏–Ω–∞ —Ü–∏–∫–ª–∞

–ü–ê–ú–Ø–¢–¨: O(1)
- –¢–æ–ª—å–∫–æ –¥–≤–∞ —É–∫–∞–∑–∞—Ç–µ–ª—è
- –ù–µ –∑–∞–≤–∏—Å–∏—Ç –æ—Ç —Ä–∞–∑–º–µ—Ä–∞ –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö

üé≠ –í–ê–†–ò–ê–¶–ò–ò –ó–ê–î–ê–ß–ò:

–ù–ê–ß–ê–õ–û –¶–ò–ö–õ–ê:
- Phase 1: –¥–µ—Ç–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ
- Phase 2: –ø–æ–∏—Å–∫ –Ω–∞—á–∞–ª–∞ (–æ–¥–∏–Ω —É–∫–∞–∑–∞—Ç–µ–ª—å –∫ –≥–æ–ª–æ–≤–µ)

–î–õ–ò–ù–ê –¶–ò–ö–õ–ê:
- –ü–æ—Å–ª–µ –≤—Å—Ç—Ä–µ—á–∏ –æ–¥–Ω–∏–º —É–∫–∞–∑–∞—Ç–µ–ª–µ–º –æ–±—Ö–æ–¥–∏–º —Ü–∏–∫–ª

–ü–û–ó–ò–¶–ò–Ø –ù–ê–ß–ê–õ–ê:
- –°—á–∏—Ç–∞–µ–º —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –æ—Ç –≥–æ–ª–æ–≤—ã –¥–æ –Ω–∞—á–∞–ª–∞ —Ü–∏–∫–ª–∞

–£–î–ê–õ–ï–ù–ò–ï –¶–ò–ö–õ–ê:
- –ù–∞—Ö–æ–¥–∏–º —É–∑–µ–ª –ø–µ—Ä–µ–¥ –Ω–∞—á–∞–ª–æ–º —Ü–∏–∫–ª–∞ –∏ –∑–∞–Ω—É–ª—è–µ–º –µ–≥–æ Next

üí° –ê–õ–¨–¢–ï–†–ù–ê–¢–ò–í–ù–´–ï –ü–û–î–•–û–î–´:

HASHSET (O(n) –ø–∞–º—è—Ç—å):
- –•—Ä–∞–Ω–∏–º –ø–æ—Å–µ—â–µ–Ω–Ω—ã–µ —É–∑–ª—ã
- –ü–µ—Ä–≤—ã–π –ø–æ–≤—Ç–æ—Ä–Ω—ã–π —É–∑–µ–ª = —Ü–∏–∫–ª

–ú–û–î–ò–§–ò–ö–ê–¶–ò–Ø –£–ó–õ–û–í:
- –ü–æ–º–µ—á–∞–µ–º –ø–æ—Å–µ—â–µ–Ω–Ω—ã–µ —É–∑–ª—ã
- –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–æ—Å–ª–µ –ø—Ä–æ–≤–µ—Ä–∫–∏

–û–ì–†–ê–ù–ò–ß–ï–ù–ò–ï –ò–¢–ï–†–ê–¶–ò–ô:
- –ï—Å–ª–∏ > n —à–∞–≥–æ–≤, —Ç–æ —Ü–∏–∫–ª –µ—Å—Ç—å
- –¢—Ä–µ–±—É–µ—Ç –∑–Ω–∞–Ω–∏—è —Ä–∞–∑–º–µ—Ä–∞ —Å–ø–∏—Å–∫–∞

‚ö†Ô∏è –ì–†–ê–ù–ò–ß–ù–´–ï –°–õ–£–ß–ê–ò:

–ü–£–°–¢–û–ô –°–ü–ò–°–û–ö: head == nil ‚Üí false
–û–î–ò–ù –£–ó–ï–õ: 
- –ë–µ–∑ —Ü–∏–∫–ª–∞ ‚Üí false
- –° —Å–∞–º–æ–∑–∞—Ü–∏–∫–ª–∏–≤–∞–Ω–∏–µ–º ‚Üí true

–î–í–ê –£–ó–õ–ê:
- –ë–µ–∑ —Ü–∏–∫–ª–∞: 1‚Üí2‚ÜíNULL ‚Üí false  
- –° —Ü–∏–∫–ª–æ–º: 1‚áÑ2 ‚Üí true

–í–ï–°–¨ –°–ü–ò–°–û–ö - –¶–ò–ö–õ:
- –ü–æ—Å–ª–µ–¥–Ω–∏–π —É–∑–µ–ª —É–∫–∞–∑—ã–≤–∞–µ—Ç –Ω–∞ –ø–µ—Ä–≤—ã–π
- –î–µ—Ç–µ–∫—Ç–∏—Ä—É–µ—Ç—Å—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ

üîß –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–ò:

–†–ê–ù–ù–ò–ô –í–´–•–û–î:
- –ü—Ä–æ–≤–µ—Ä–∫–∞ –æ—á–µ–Ω—å –∫–æ—Ä–æ—Ç–∫–∏—Ö —Å–ø–∏—Å–∫–æ–≤
- –°–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ —Å–ª—É—á–∞–∏ –¥–ª—è length ‚â§ 2

–ö–≠–®–ò–†–û–í–ê–ù–ò–ï –ü–†–û–í–ï–†–û–ö:
- –î–ª—è –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã—Ö –≤—ã–∑–æ–≤–æ–≤ –Ω–∞ —Ç–æ–º –∂–µ —Å–ø–∏—Å–∫–µ
- –¢—Ä–µ–±—É–µ—Ç –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–π –ø–∞–º—è—Ç–∏

–ü–ê–†–ê–õ–õ–ï–õ–¨–ù–ê–Ø –û–ë–†–ê–ë–û–¢–ö–ê:
- –î–ª—è –æ—á–µ–Ω—å –±–æ–ª—å—à–∏—Ö —Å–ø–∏—Å–∫–æ–≤
- –°–ª–æ–∂–Ω–æ—Å—Ç—å —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏

üéØ –ü–†–ò–ú–ï–ù–ï–ù–ò–Ø:
- –î–µ—Ç–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Ü–∏–∫–ª–æ–≤ –≤ –≥—Ä–∞—Ñ–∞—Ö
- –ê–Ω–∞–ª–∏–∑ —Å—Ç—Ä—É–∫—Ç—É—Ä –¥–∞–Ω–Ω—ã—Ö –Ω–∞ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç—å
- Debugging memory leaks
- –í–∞–ª–∏–¥–∞—Ü–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏—Ö —Å—Ç—Ä—É–∫—Ç—É—Ä
```

### –†–µ—à–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏ 13

>[–Ω–∞–∑–∞–¥](#-–ø–æ–¥—Å–∫–∞–∑–∫–∏-–¥–ª—è-–æ—Å–Ω–æ–≤–Ω—ã—Ö-–∑–∞–¥–∞—á)

#### üéØ –†–µ—à–µ–Ω–∏–µ Reverse String/Array

üìä –ê–Ω–∞–ª–∏–∑ –∑–∞–¥–∞—á–∏:

```bash
üìä –ê–ù–ê–õ–ò–ó –ó–ê–î–ê–ß–ò:

REVERSE ARRAY:
–î–∞–Ω–æ: nums = [1, 2, 3, 4, 5]
–†–µ–∑—É–ª—å—Ç–∞—Ç: [5, 4, 3, 2, 1] (—ç–ª–µ–º–µ–Ω—Ç—ã –≤ –æ–±—Ä–∞—Ç–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ)

–î–∞–Ω–æ: nums = [1, 2, 3, 4]
–†–µ–∑—É–ª—å—Ç–∞—Ç: [4, 3, 2, 1] (—á–µ—Ç–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤)

REVERSE STRING:
–î–∞–Ω–æ: s = ["h","e","l","l","o"]
–†–µ–∑—É–ª—å—Ç–∞—Ç: ["o","l","l","e","h"] (—Å–∏–º–≤–æ–ª—ã –≤ –æ–±—Ä–∞—Ç–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ)

–î–∞–Ω–æ: s = ["a"]
–†–µ–∑—É–ª—å—Ç–∞—Ç: ["a"] (–æ–¥–∏–Ω —ç–ª–µ–º–µ–Ω—Ç –æ—Å—Ç–∞–µ—Ç—Å—è –Ω–∞ –º–µ—Å—Ç–µ)

–í–ê–ñ–ù–û: –º–æ–¥–∏—Ñ–∏–∫–∞—Ü–∏—è in-place, –±–µ–∑ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–≥–æ –º–∞—Å—Å–∏–≤–∞
```

*"–ö–ª–∞—Å—Å–∏—á–µ—Å–∫–∏–π two pointers pattern. –°—Ç–∞–≤–∏–º —É–∫–∞–∑–∞—Ç–µ–ª–∏ –Ω–∞ –∫–æ–Ω—Ü—ã –º–∞—Å—Å–∏–≤–∞, –º–µ–Ω—è–µ–º —ç–ª–µ–º–µ–Ω—Ç—ã –º–µ—Å—Ç–∞–º–∏ –∏ –¥–≤–∏–≥–∞–µ–º –∫ —Ü–µ–Ω—Ç—Ä—É. –ö–ª—é—á–µ–≤–æ–µ —É—Å–ª–æ–≤–∏–µ: left < right, —á—Ç–æ–±—ã –ø—Ä–∏ –Ω–µ—á–µ—Ç–Ω–æ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–µ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ —Å—Ä–µ–¥–Ω–∏–π –æ—Å—Ç–∞–ª—Å—è –Ω–∞ –º–µ—Å—Ç–µ. O(n) –≤—Ä–µ–º—è, O(1) –ø–∞–º—è—Ç—å, in-place –º–æ–¥–∏—Ñ–∏–∫–∞—Ü–∏—è. –û—Å–Ω–æ–≤–∞ –¥–ª—è –º–Ω–æ–≥–∏—Ö –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤ –≤–∫–ª—é—á–∞—è –ø—Ä–æ–≤–µ—Ä–∫—É –ø–∞–ª–∏–Ω–¥—Ä–æ–º–æ–≤."*

üéØ –û–±—ä—è—Å–Ω–µ–Ω–∏–µ —Ä–µ—à–µ–Ω–∏—è:

üß† –õ–æ–≥–∏–∫–∞ Two Pointers:

1. üìç –£–∫–∞–∑–∞—Ç–µ–ª–∏ –Ω–∞ –∫–æ–Ω—Ü–∞—Ö: left = 0, right = len-1
2. üîÑ Swap —ç–ª–µ–º–µ–Ω—Ç–æ–≤: nums[left], nums[right] = nums[right], nums[left]
3. ‚û°Ô∏è –î–≤–∏–∂–µ–Ω–∏–µ –∫ —Ü–µ–Ω—Ç—Ä—É: left++, right--
4. üõë –£—Å–ª–æ–≤–∏–µ –æ—Å—Ç–∞–Ω–æ–≤–∫–∏: left < right (–ù–ï <=)

```go
// ‚úÖ –û–ü–¢–ò–ú–ê–õ–¨–ù–û–ï –†–ï–®–ï–ù–ò–ï - Reverse Array (Two Pointers)
func reverseArray(nums []int) {
    left, right := 0, len(nums)-1
    
    // üîÑ –î–≤–∏–≥–∞–µ–º —É–∫–∞–∑–∞—Ç–µ–ª–∏ –æ—Ç –∫—Ä–∞–µ–≤ –∫ —Ü–µ–Ω—Ç—Ä—É
    for left < right {
        // üîÑ –ú–µ–Ω—è–µ–º —ç–ª–µ–º–µ–Ω—Ç—ã –º–µ—Å—Ç–∞–º–∏
        nums[left], nums[right] = nums[right], nums[left]
        
        // ‚û°Ô∏è –°–¥–≤–∏–≥–∞–µ–º —É–∫–∞–∑–∞—Ç–µ–ª–∏ –∫ —Ü–µ–Ω—Ç—Ä—É
        left++
        right--
    }
}

// ‚úÖ REVERSE STRING - –¥–ª—è –º–∞—Å—Å–∏–≤–∞ –±–∞–π—Ç (Go strings immutable)
func reverseString(s []byte) {
    left, right := 0, len(s)-1
    
    for left < right {
        // üîÑ Swap —Å–∏–º–≤–æ–ª–æ–≤
        s[left], s[right] = s[right], s[left]
        left++
        right--
    }
}

// üöÄ –û–ë–û–ë–©–ï–ù–ù–û–ï –†–ï–®–ï–ù–ò–ï - –¥–ª—è –ª—é–±–æ–≥–æ —Ç–∏–ø–∞ —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π swap
func reverseSlice[T any](slice []T) {
    left, right := 0, len(slice)-1
    
    for left < right {
        slice[left], slice[right] = slice[right], slice[left]
        left++
        right--
    }
}

// üåü –†–ï–ö–£–†–°–ò–í–ù–ê–Ø –í–ï–†–°–ò–Ø (–¥–ª—è –ø–æ–Ω–∏–º–∞–Ω–∏—è)
func reverseArrayRecursive(nums []int) {
    reverseHelper(nums, 0, len(nums)-1)
}

func reverseHelper(nums []int, left, right int) {
    // üõë –ë–∞–∑–æ–≤—ã–π —Å–ª—É—á–∞–π: —É–∫–∞–∑–∞—Ç–µ–ª–∏ –≤—Å—Ç—Ä–µ—Ç–∏–ª–∏—Å—å –∏–ª–∏ –ø–µ—Ä–µ—Å–µ–∫–ª–∏—Å—å
    if left >= right {
        return
    }
    
    // üîÑ –ú–µ–Ω—è–µ–º —Ç–µ–∫—É—â–∏–µ —ç–ª–µ–º–µ–Ω—Ç—ã
    nums[left], nums[right] = nums[right], nums[left]
    
    // üîÑ –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –≤–Ω—É—Ç—Ä–µ–Ω–Ω—é—é —á–∞—Å—Ç—å
    reverseHelper(nums, left+1, right-1)
}

// üéØ REVERSE –ü–û–î–ú–ê–°–°–ò–í–ê/–ü–û–î–°–¢–†–û–ö–ò
func reverseRange(nums []int, start, end int) {
    // üîß –ü—Ä–æ–≤–µ—Ä–∫–∞ –≥—Ä–∞–Ω–∏—Ü
    if start < 0 || end >= len(nums) || start >= end {
        return
    }
    
    left, right := start, end
    
    for left < right {
        nums[left], nums[right] = nums[right], nums[left]
        left++
        right--
    }
}

// üîß REVERSE STRING –∏ –≤–æ–∑–≤—Ä–∞—Ç –Ω–æ–≤–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è (–Ω–µ in-place)
func reverseStringCopy(s string) string {
    // üìã –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ slice –±–∞–π—Ç –¥–ª—è –º–æ–¥–∏—Ñ–∏–∫–∞—Ü–∏–∏
    bytes := []byte(s)
    reverseString(bytes)
    return string(bytes)
}

// üöÄ REVERSE —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º rune (–¥–ª—è Unicode —Å–∏–º–≤–æ–ª–æ–≤)
func reverseStringUnicode(s string) string {
    // üî§ –†–∞–±–æ—Ç–∞–µ–º —Å rune –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏ Unicode
    runes := []rune(s)
    left, right := 0, len(runes)-1
    
    for left < right {
        runes[left], runes[right] = runes[right], runes[left]
        left++
        right--
    }
    
    return string(runes)
}

// üé≠ REVERSE WORDS –≤ —Å—Ç—Ä–æ–∫–µ (–¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –≤–∞—Ä–∏–∞—Ü–∏—è)
func reverseWords(s string) string {
    // –†–∞–∑–±–∏–≤–∞–µ–º –Ω–∞ —Å–ª–æ–≤–∞, –æ–±—Ä–∞—â–∞–µ–º –ø–æ—Ä—è–¥–æ–∫ —Å–ª–æ–≤
    words := strings.Fields(s)
    reverseSlice(words)
    return strings.Join(words, " ")
}

// üîÑ REVERSE –∫–∞–∂–¥–æ–µ —Å–ª–æ–≤–æ –≤ —Å—Ç—Ä–æ–∫–µ –æ—Ç–¥–µ–ª—å–Ω–æ
func reverseEachWord(s string) string {
    words := strings.Fields(s)
    
    for i, word := range words {
        words[i] = reverseStringCopy(word)
    }
    
    return strings.Join(words, " ")
}

// üîß Helper —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏ –∏ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
func copyArray(nums []int) []int {
    result := make([]int, len(nums))
    copy(result, nums)
    return result
}

func arrayToString(nums []int) string {
    if len(nums) == 0 {
        return "[]"
    }
    
    result := "["
    for i, num := range nums {
        if i > 0 {
            result += ", "
        }
        result += fmt.Sprintf("%d", num)
    }
    result += "]"
    return result
}

// üéØ –ü–†–û–í–ï–†–ö–ê –ü–ê–õ–ò–ù–î–†–û–ú–ê —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º reverse logic
func isPalindrome(s string) bool {
    // –û—á–∏—â–∞–µ–º —Å—Ç—Ä–æ–∫—É –æ—Ç –Ω–µ-–±—É–∫–≤–µ–Ω–Ω—ã—Ö —Å–∏–º–≤–æ–ª–æ–≤
    cleaned := strings.ToLower(regexp.MustCompile(`[^a-zA-Z0-9]`).ReplaceAllString(s, ""))
    
    left, right := 0, len(cleaned)-1
    
    for left < right {
        if cleaned[left] != cleaned[right] {
            return false
        }
        left++
        right--
    }
    
    return true
}

// üöÄ –û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–ù–ê–Ø –í–ï–†–°–ò–Ø –¥–ª—è –æ—á–µ–Ω—å –±–æ–ª—å—à–∏—Ö –º–∞—Å—Å–∏–≤–æ–≤
func reverseArrayOptimized(nums []int) {
    if len(nums) <= 1 {
        return // –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –¥–ª—è —Ç—Ä–∏–≤–∏–∞–ª—å–Ω—ã—Ö —Å–ª—É—á–∞–µ–≤
    }
    
    // üîß –ò—Å–ø–æ–ª—å–∑—É–µ–º –±–∏—Ç–æ–≤—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ –¥–ª—è –Ω–∞—Ö–æ–∂–¥–µ–Ω–∏—è —Å–µ—Ä–µ–¥–∏–Ω—ã
    n := len(nums)
    mid := n >> 1  // –î–µ–ª–µ–Ω–∏–µ –Ω–∞ 2 —á–µ—Ä–µ–∑ –±–∏—Ç–æ–≤—ã–π —Å–¥–≤–∏–≥
    
    // üîÑ –û–±–º–µ–Ω–∏–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –¥–æ —Å–µ—Ä–µ–¥–∏–Ω—ã
    for i := 0; i < mid; i++ {
        j := n - 1 - i
        nums[i], nums[j] = nums[j], nums[i]
    }
}

// üìä –ê–ù–ê–õ–ò–ó –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ —Ä–∞–∑–Ω—ã—Ö –ø–æ–¥—Ö–æ–¥–æ–≤
func benchmarkReverse() {
    sizes := []int{100, 1000, 10000, 100000}
    
    for _, size := range sizes {
        // –°–æ–∑–¥–∞–µ–º —Ç–µ—Å—Ç–æ–≤—ã–π –º–∞—Å—Å–∏–≤
        nums := make([]int, size)
        for i := range nums {
            nums[i] = i
        }
        
        // –ö–æ–ø–∏—Ä—É–µ–º –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Ç–µ—Å—Ç–∞
        test1 := copyArray(nums)
        test2 := copyArray(nums)
        
        // –¢–µ—Å—Ç–∏—Ä—É–µ–º —Ä–∞–∑–Ω—ã–µ –ø–æ–¥—Ö–æ–¥—ã
        start := time.Now()
        reverseArray(test1)
        iterativeTime := time.Since(start)
        
        start = time.Now()
        reverseArrayRecursive(test2)
        recursiveTime := time.Since(start)
        
        fmt.Printf("Size %d: Iterative=%v, Recursive=%v\n", 
            size, iterativeTime, recursiveTime)
    }
}
```

```bash
üéØ –ê–õ–ì–û–†–ò–¢–ú TWO POINTERS REVERSE:

–û–°–ù–û–í–ù–ê–Ø –ò–î–ï–Ø:
1. üîß –£–∫–∞–∑–∞—Ç–µ–ª–∏ –Ω–∞ –∫–æ–Ω—Ü–∞—Ö –º–∞—Å—Å–∏–≤–∞: left=0, right=n-1
2. üîÑ –û–±–º–µ–Ω–∏–≤–∞–µ–º —ç–ª–µ–º–µ–Ω—Ç—ã: swap(arr[left], arr[right])  
3. ‚û°Ô∏è –°–¥–≤–∏–≥–∞–µ–º —É–∫–∞–∑–∞—Ç–µ–ª–∏: left++, right--
4. üîÑ –ü–æ–≤—Ç–æ—Ä—è–µ–º –ø–æ–∫–∞ left < right

–ò–ù–í–ê–†–ò–ê–ù–¢ –¶–ò–ö–õ–ê:
- –≠–ª–µ–º–µ–Ω—Ç—ã [0, left) —É–∂–µ –Ω–∞ —Å–≤–æ–∏—Ö —Ñ–∏–Ω–∞–ª—å–Ω—ã—Ö –ø–æ–∑–∏—Ü–∏—è—Ö
- –≠–ª–µ–º–µ–Ω—Ç—ã (right, n-1] —É–∂–µ –Ω–∞ —Å–≤–æ–∏—Ö —Ñ–∏–Ω–∞–ª—å–Ω—ã—Ö –ø–æ–∑–∏—Ü–∏—è—Ö  
- –≠–ª–µ–º–µ–Ω—Ç—ã [left, right] –µ—â–µ –Ω—É–∂–¥–∞—é—Ç—Å—è –≤ –æ–±—Ä–∞–±–æ—Ç–∫–µ

üîë –ö–õ–Æ–ß–ï–í–´–ï –ú–û–ú–ï–ù–¢–´:

–£–°–õ–û–í–ò–ï –û–°–¢–ê–ù–û–í–ö–ò:
left < right (–ù–ï left <= right)
- –ü—Ä–∏ —á–µ—Ç–Ω–æ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–µ: left –≤—Å—Ç—Ä–µ—Ç–∏—Ç—Å—è —Å right
- –ü—Ä–∏ –Ω–µ—á–µ—Ç–Ω–æ–º: left –ø–µ—Ä–µ—Å–µ—á–µ—Ç right, —Å—Ä–µ–¥–Ω–∏–π —ç–ª–µ–º–µ–Ω—Ç –æ—Å—Ç–∞–µ—Ç—Å—è

SWAP –û–ü–ï–†–ê–¶–ò–Ø:
Go —Å–∏–Ω—Ç–∞–∫—Å–∏—Å: a, b = b, a
- –ê—Ç–æ–º–∞—Ä–Ω–∞—è –æ–ø–µ—Ä–∞—Ü–∏—è, –Ω–µ –Ω—É–∂–Ω–∞ –≤—Ä–µ–º–µ–Ω–Ω–∞—è –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è
- –ö–æ–º–ø–∏–ª—è—Ç–æ—Ä –æ–ø—Ç–∏–º–∏–∑–∏—Ä—É–µ—Ç —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ

–û–ë–†–ê–ë–û–¢–ö–ê –ì–†–ê–ù–ò–ß–ù–´–• –°–õ–£–ß–ê–ï–í:
- –ü—É—Å—Ç–æ–π –º–∞—Å—Å–∏–≤: len=0 ‚Üí —Ü–∏–∫–ª –Ω–µ –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è
- –û–¥–∏–Ω —ç–ª–µ–º–µ–Ω—Ç: left=0, right=0 ‚Üí left < right false
- –î–≤–∞ —ç–ª–µ–º–µ–Ω—Ç–∞: left=0, right=1 ‚Üí –æ–¥–∏–Ω swap

‚ö° –°–õ–û–ñ–ù–û–°–¢–¨:

–í–†–ï–ú–Ø: O(n)
- –ö–∞–∂–¥—ã–π —ç–ª–µ–º–µ–Ω—Ç —É—á–∞—Å—Ç–≤—É–µ—Ç –≤ –º–∞–∫—Å–∏–º—É–º –æ–¥–Ω–æ–º swap
- –†–æ–≤–Ω–æ n/2 –æ–ø–µ—Ä–∞—Ü–∏–π –æ–±–º–µ–Ω–∞
- –õ–∏–Ω–µ–π–Ω–æ–µ –≤—Ä–µ–º—è –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ —Ä–∞–∑–º–µ—Ä–∞

–ü–ê–ú–Ø–¢–¨: O(1)  
- –¢–æ–ª—å–∫–æ –¥–≤–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ —É–∫–∞–∑–∞—Ç–µ–ª–µ–π
- In-place –º–æ–¥–∏—Ñ–∏–∫–∞—Ü–∏—è –±–µ–∑ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–≥–æ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–∞
- –ù–µ –∑–∞–≤–∏—Å–∏—Ç –æ—Ç —Ä–∞–∑–º–µ—Ä–∞ –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö

üé≠ –í–ê–†–ò–ê–¶–ò–ò –ó–ê–î–ê–ß–ò:

REVERSE –ü–û–î–ú–ê–°–°–ò–í–ê:
reverse(arr, start, end) - –æ–±—Ä–∞—â–∞–µ—Ç —Ç–æ–ª—å–∫–æ —á–∞—Å—Ç—å –º–∞—Å—Å–∏–≤–∞

REVERSE –°–¢–†–û–ö–ò:
- –ë–∞–π—Ç–æ–≤—ã–µ —Å—Ç—Ä–æ–∫–∏: []byte –¥–ª—è –º–æ–¥–∏—Ñ–∏–∫–∞—Ü–∏–∏
- Unicode —Å—Ç—Ä–æ–∫–∏: []rune –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏

REVERSE WORDS:
- "Hello World" ‚Üí "World Hello"
- –û–±—Ä–∞—â–µ–Ω–∏–µ –ø–æ—Ä—è–¥–∫–∞ —Å–ª–æ–≤

REVERSE –ö–ê–ñ–î–û–ï –°–õ–û–í–û:
- "Hello World" ‚Üí "olleH dlroW"  
- –ö–∞–∂–¥–æ–µ —Å–ª–æ–≤–æ –æ–±—Ä–∞—â–∞–µ—Ç—Å—è –æ—Ç–¥–µ–ª—å–Ω–æ

üí° –ü–†–ò–ú–ï–ù–ï–ù–ò–Ø:

–ü–ê–õ–ò–ù–î–†–û–ú –ü–†–û–í–ï–†–ö–ê:
- –°—Ä–∞–≤–Ω–∏–≤–∞–µ–º —Å–∏–º–≤–æ–ª—ã —Å –∫–æ–Ω—Ü–æ–≤ –∫ —Ü–µ–Ω—Ç—Ä—É
- –¢–æ—Ç –∂–µ two pointers pattern

ROTATING ARRAY:
- –ö–æ–º–±–∏–Ω–∞—Ü–∏—è –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö reverse –æ–ø–µ—Ä–∞—Ü–∏–π
- rotate(arr, k) —á–µ—Ä–µ–∑ reverse –ø–æ–¥—Ö–æ–¥–æ–º

–°–û–†–¢–ò–†–û–í–ö–ê:
- Pancake sorting –∏—Å–ø–æ–ª—å–∑—É–µ—Ç reverse
- Bubble sort –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏

‚ö†Ô∏è –û–°–û–ë–ï–ù–ù–û–°–¢–ò –†–ï–ê–õ–ò–ó–ê–¶–ò–ò:

STRINGS –í GO:
- –°—Ç—Ä–æ–∫–∏ immutable ‚Üí –Ω—É–∂–Ω–æ []byte –∏–ª–∏ []rune
- UTF-8 encoding ‚Üí rune –¥–ª—è Unicode —Å–∏–º–≤–æ–ª–æ–≤

GENERIC –†–ï–®–ï–ù–ò–ï:
- type –ø–∞—Ä–∞–º–µ—Ç—Ä—ã [T any] –¥–ª—è —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–æ—Å—Ç–∏  
- –†–∞–±–æ—Ç–∞–µ—Ç —Å –ª—é–±—ã–º–∏ —Ç–∏–ø–∞–º–∏ –¥–∞–Ω–Ω—ã—Ö

–†–ï–ö–£–†–°–ò–í–ù–ê–Ø –í–ï–†–°–ò–Ø:
- O(n) –ø–∞–º—è—Ç—å –∏–∑-–∑–∞ —Å—Ç–µ–∫–∞ –≤—ã–∑–æ–≤–æ–≤
- –ú–µ–Ω–µ–µ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–∞, –Ω–æ –¥–µ–º–æ–Ω—Å—Ç—Ä–∏—Ä—É–µ—Ç –ø—Ä–∏–Ω—Ü–∏–ø

üîß –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–ò:

–†–ê–ù–ù–ò–ô –í–´–•–û–î:
- –ü—Ä–æ–≤–µ—Ä–∫–∞ len <= 1 –ø–µ—Ä–µ–¥ —Ü–∏–∫–ª–æ–º
- –ò–∑–±–µ–≥–∞–µ–º –Ω–µ–Ω—É–∂–Ω—ã–µ –≤—ã—á–∏—Å–ª–µ–Ω–∏—è

–ë–ò–¢–û–í–´–ï –û–ü–ï–†–ê–¶–ò–ò:
- n >> 1 –≤–º–µ—Å—Ç–æ n / 2 –¥–ª—è –Ω–∞—Ö–æ–∂–¥–µ–Ω–∏—è —Å–µ—Ä–µ–¥–∏–Ω—ã
- –ú–∏–∫—Ä–æ–æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –¥–ª—è –æ—á–µ–Ω—å —á–∞—Å—Ç—ã—Ö –≤—ã–∑–æ–≤–æ–≤

CACHE-FRIENDLY:
- –ü–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω—ã–π –¥–æ—Å—Ç—É–ø –∫ –ø–∞–º—è—Ç–∏
- –•–æ—Ä–æ—à–∞—è locality –¥–ª—è –±–æ–ª—å—à–∏—Ö –º–∞—Å—Å–∏–≤–æ–≤

üéØ –ù–ê –°–û–ë–ï–°–ï–î–û–í–ê–ù–ò–ò:
- –î–µ–º–æ–Ω—Å—Ç—Ä–∏—Ä—É–µ—Ç –ø–æ–Ω–∏–º–∞–Ω–∏–µ two pointers
- –í–∞–∂–Ω–æ—Å—Ç—å in-place –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤
- –†–∞–±–æ—Ç–∞ —Å —É–∫–∞–∑–∞—Ç–µ–ª—è–º–∏ –∏ –≥—Ä–∞–Ω–∏—Ü–∞–º–∏
- –ë–∞–∑–æ–≤–∞—è –æ–ø–µ—Ä–∞—Ü–∏—è –¥–ª—è –º–Ω–æ–≥–∏—Ö –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤
```

### –†–µ—à–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏ 15

>[–Ω–∞–∑–∞–¥](#-–ø–æ–¥—Å–∫–∞–∑–∫–∏-–¥–ª—è-–æ—Å–Ω–æ–≤–Ω—ã—Ö-–∑–∞–¥–∞—á)

#### üéØ –†–µ—à–µ–Ω–∏–µ BFS/DFS Implementation

üìä –ê–Ω–∞–ª–∏–∑ –∑–∞–¥–∞—á–∏:

```bash
üìä –ê–ù–ê–õ–ò–ó –ó–ê–î–ê–ß–ò:

–ì–†–ê–§ –î–õ–Ø –û–ë–•–û–î–ê:
     0
   /   \
  1     2
 / \   /
3   4 5

Adjacency List: {
  0: [1, 2],
  1: [0, 3, 4], 
  2: [0, 5],
  3: [1],
  4: [1], 
  5: [2]
}

BFS –æ—Ç —É–∑–ª–∞ 0: [0, 1, 2, 3, 4, 5] (–ø–æ —É—Ä–æ–≤–Ω—è–º)
DFS –æ—Ç —É–∑–ª–∞ 0: [0, 1, 3, 4, 2, 5] (–≤ –≥–ª—É–±–∏–Ω—É)

–ü–†–ò–ú–ï–ù–ï–ù–ò–Ø:
- BFS: –∫—Ä–∞—Ç—á–∞–π—à–∏–π –ø—É—Ç—å, level order traversal
- DFS: –ø–æ–∏—Å–∫ –ø—É—Ç–µ–π, —Ç–æ–ø–æ–ª–æ–≥–∏—á–µ—Å–∫–∞—è —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞, –¥–µ—Ç–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Ü–∏–∫–ª–æ–≤
```

*"–ò—Å–ø–æ–ª—å–∑—É—é HashMap –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –ø—Ä–æ–π–¥–µ–Ω–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤. –ó–∞ –æ–¥–∏–Ω –ø—Ä–æ—Ö–æ–¥ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —á–∏—Å–ª–∞ X –∏—â—É –¥–æ–ø–æ–ª–Ω–µ–Ω–∏–µ Y=target-X –≤ map. –ï—Å–ª–∏ –Ω–∞—à–µ–ª - –≤–æ–∑–≤—Ä–∞—â–∞—é –ø–∞—Ä—É, –µ—Å–ª–∏ –Ω–µ—Ç - —Å–æ—Ö—Ä–∞–Ω—è—é X. –°–ª–æ–∂–Ω–æ—Å—Ç—å O(n) –≤—Ä–µ–º—è, O(n) –ø–∞–º—è—Ç—å - –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ –¥–ª—è —ç—Ç–æ–π –∑–∞–¥–∞—á–∏."*

**–û–±—ä—è—Å–Ω–µ–Ω–∏–µ —Ä–µ—à–µ–Ω–∏—è:**

**üß† –§—É–Ω–¥–∞–º–µ–Ω—Ç–∞–ª—å–Ω—ã–µ —Ä–∞–∑–ª–∏—á–∏—è:**

| –ê—Å–ø–µ–∫—Ç | BFS (Breadth-First) | DFS (Depth-First) |
|--------|--------------------|--------------------|
| **–ü—Ä–∏–Ω—Ü–∏–ø** | üåä "–í —à–∏—Ä–∏–Ω—É" - –ø–æ —É—Ä–æ–≤–Ω—è–º | ‚¨áÔ∏è "–í –≥–ª—É–±–∏–Ω—É" - –∫–∞–∫ –º–æ–∂–Ω–æ –¥–∞–ª—å—à–µ |
| **–°—Ç—Ä—É–∫—Ç—É—Ä–∞** | üìã –û—á–µ—Ä–µ–¥—å (FIFO) | üìö –°—Ç–µ–∫/—Ä–µ–∫—É—Ä—Å–∏—è (LIFO) |
| **–ü–æ—Ä—è–¥–æ–∫** | `[0,1,2,3,4,5]` | `[0,1,3,4,2,5]` |
| **–ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ** | –ö—Ä–∞—Ç—á–∞–π—à–∏–π –ø—É—Ç—å | –ü–æ–∏—Å–∫ –≤—Å–µ—Ö –ø—É—Ç–µ–π |

```go
// üìä –ü–†–ï–î–°–¢–ê–í–õ–ï–ù–ò–ï –ì–†–ê–§–ê
type Graph struct {
    adjacencyList map[int][]int
    vertices      int
}

func NewGraph(vertices int) *Graph {
    return &Graph{
        adjacencyList: make(map[int][]int),
        vertices:      vertices,
    }
}

func (g *Graph) AddEdge(from, to int) {
    g.adjacencyList[from] = append(g.adjacencyList[from], to)
    g.adjacencyList[to] = append(g.adjacencyList[to], from) // –ù–µ–æ—Ä–∏–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –≥—Ä–∞—Ñ
}

func (g *Graph) AddDirectedEdge(from, to int) {
    g.adjacencyList[from] = append(g.adjacencyList[from], to)
}

// ‚úÖ BFS IMPLEMENTATION - Breadth-First Search
func (g *Graph) BFS(start int) []int {
    visited := make(map[int]bool)
    var result []int
    
    // üìã –û—á–µ—Ä–µ–¥—å –¥–ª—è BFS (FIFO)
    queue := []int{start}
    visited[start] = true
    
    // üîÑ –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —É–∑–ª—ã level by level
    for len(queue) > 0 {
        // üì§ –ò–∑–≤–ª–µ–∫–∞–µ–º –ø–µ—Ä–≤—ã–π —ç–ª–µ–º–µ–Ω—Ç –∏–∑ –æ—á–µ—Ä–µ–¥–∏
        current := queue[0]
        queue = queue[1:]
        
        // üìù –î–æ–±–∞–≤–ª—è–µ–º –≤ —Ä–µ–∑—É–ª—å—Ç–∞—Ç
        result = append(result, current)
        
        // üîç –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –≤—Å–µ—Ö —Å–æ—Å–µ–¥–µ–π
        for _, neighbor := range g.adjacencyList[current] {
            if !visited[neighbor] {
                visited[neighbor] = true
                queue = append(queue, neighbor) // üì• –î–æ–±–∞–≤–ª—è–µ–º –≤ –∫–æ–Ω–µ—Ü –æ—á–µ—Ä–µ–¥–∏
            }
        }
    }
    
    return result
}

// ‚úÖ DFS IMPLEMENTATION - Depth-First Search (—Ä–µ–∫—É—Ä—Å–∏–≤–Ω—ã–π)
func (g *Graph) DFS(start int) []int {
    visited := make(map[int]bool)
    var result []int
    
    g.dfsHelper(start, visited, &result)
    return result
}

func (g *Graph) dfsHelper(node int, visited map[int]bool, result *[]int) {
    // üìù –ü–æ—Å–µ—â–∞–µ–º —Ç–µ–∫—É—â–∏–π —É–∑–µ–ª
    visited[node] = true
    *result = append(*result, node)
    
    // üîÑ –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ –æ–±—Ö–æ–¥–∏–º –≤—Å–µ—Ö –Ω–µ–ø–æ—Å–µ—â–µ–Ω–Ω—ã—Ö —Å–æ—Å–µ–¥–µ–π
    for _, neighbor := range g.adjacencyList[node] {
        if !visited[neighbor] {
            g.dfsHelper(neighbor, visited, result)
        }
    }
}

// üöÄ DFS ITERATIVE - —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º —Å—Ç–µ–∫–∞
func (g *Graph) DFSIterative(start int) []int {
    visited := make(map[int]bool)
    var result []int
    
    // üìö –°—Ç–µ–∫ –¥–ª—è DFS (LIFO)
    stack := []int{start}
    
    for len(stack) > 0 {
        // üì§ –ò–∑–≤–ª–µ–∫–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–π —ç–ª–µ–º–µ–Ω—Ç (top of stack)
        current := stack[len(stack)-1]
        stack = stack[:len(stack)-1]
        
        // ‚ö†Ô∏è –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ—Å–µ—â–µ–Ω–∏–µ –ü–û–°–õ–ï –∏–∑–≤–ª–µ—á–µ–Ω–∏—è –∏–∑ —Å—Ç–µ–∫–∞
        if visited[current] {
            continue
        }
        
        // üìù –ü–æ—Å–µ—â–∞–µ–º —É–∑–µ–ª
        visited[current] = true
        result = append(result, current)
        
        // üì• –î–æ–±–∞–≤–ª—è–µ–º —Å–æ—Å–µ–¥–µ–π –≤ —Å—Ç–µ–∫ (–≤ –æ–±—Ä–∞—Ç–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ –¥–ª—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ–≥–æ DFS)
        neighbors := g.adjacencyList[current]
        for i := len(neighbors) - 1; i >= 0; i-- {
            neighbor := neighbors[i]
            if !visited[neighbor] {
                stack = append(stack, neighbor)
            }
        }
    }
    
    return result
}

// üéØ BFS –î–õ–Ø –ü–û–ò–°–ö–ê –ö–†–ê–¢–ß–ê–ô–®–ï–ì–û –ü–£–¢–ò
func (g *Graph) ShortestPath(start, target int) []int {
    if start == target {
        return []int{start}
    }
    
    visited := make(map[int]bool)
    parent := make(map[int]int)
    queue := []int{start}
    visited[start] = true
    
    // BFS –¥–æ –Ω–∞—Ö–æ–∂–¥–µ–Ω–∏—è target
    for len(queue) > 0 {
        current := queue[0]
        queue = queue[1:]
        
        for _, neighbor := range g.adjacencyList[current] {
            if !visited[neighbor] {
                visited[neighbor] = true
                parent[neighbor] = current
                queue = append(queue, neighbor)
                
                // üéØ –ù–∞–π–¥–µ–Ω target - –≤–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø—É—Ç—å
                if neighbor == target {
                    return reconstructPath(parent, start, target)
                }
            }
        }
    }
    
    return nil // –ü—É—Ç—å –Ω–µ –Ω–∞–π–¥–µ–Ω
}

func reconstructPath(parent map[int]int, start, target int) []int {
    path := []int{}
    current := target
    
    // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø—É—Ç—å –æ—Ç target –∫ start
    for current != start {
        path = append([]int{current}, path...) // Prepend
        current = parent[current]
    }
    path = append([]int{start}, path...) // –î–æ–±–∞–≤–ª—è–µ–º start
    
    return path
}

// üåü BFS –ü–û –£–†–û–í–ù–Ø–ú (Level Order)
func (g *Graph) BFSLevels(start int) [][]int {
    visited := make(map[int]bool)
    var levels [][]int
    
    queue := []int{start}
    visited[start] = true
    
    for len(queue) > 0 {
        levelSize := len(queue)
        currentLevel := []int{}
        
        // üîÑ –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –≤–µ—Å—å —Ç–µ–∫—É—â–∏–π —É—Ä–æ–≤–µ–Ω—å
        for i := 0; i < levelSize; i++ {
            current := queue[0]
            queue = queue[1:]
            currentLevel = append(currentLevel, current)
            
            // –î–æ–±–∞–≤–ª—è–µ–º —Å–æ—Å–µ–¥–µ–π –¥–ª—è —Å–ª–µ–¥—É—é—â–µ–≥–æ —É—Ä–æ–≤–Ω—è
            for _, neighbor := range g.adjacencyList[current] {
                if !visited[neighbor] {
                    visited[neighbor] = true
                    queue = append(queue, neighbor)
                }
            }
        }
        
        levels = append(levels, currentLevel)
    }
    
    return levels
}

// üîç –ü–û–ò–°–ö –í–°–ï–• –ö–û–ú–ü–û–ù–ï–ù–¢ –°–í–Ø–ó–ù–û–°–¢–ò
func (g *Graph) ConnectedComponents() [][]int {
    visited := make(map[int]bool)
    var components [][]int
    
    // üîÑ –î–ª—è –∫–∞–∂–¥–æ–≥–æ –Ω–µ–ø–æ—Å–µ—â–µ–Ω–Ω–æ–≥–æ —É–∑–ª–∞ –Ω–∞—á–∏–Ω–∞–µ–º –Ω–æ–≤—É—é –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—É
    for vertex := 0; vertex < g.vertices; vertex++ {
        if !visited[vertex] && len(g.adjacencyList[vertex]) > 0 {
            component := []int{}
            g.dfsHelper(vertex, visited, &component)
            components = append(components, component)
        }
    }
    
    return components
}

// üéØ –î–ï–¢–ï–ö–¢–ò–†–û–í–ê–ù–ò–ï –¶–ò–ö–õ–ê –≤ –Ω–µ–æ—Ä–∏–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–º –≥—Ä–∞—Ñ–µ
func (g *Graph) HasCycle() bool {
    visited := make(map[int]bool)
    
    for vertex := 0; vertex < g.vertices; vertex++ {
        if !visited[vertex] && len(g.adjacencyList[vertex]) > 0 {
            if g.hasCycleDFS(vertex, -1, visited) {
                return true
            }
        }
    }
    
    return false
}

func (g *Graph) hasCycleDFS(node, parent int, visited map[int]bool) bool {
    visited[node] = true
    
    for _, neighbor := range g.adjacencyList[node] {
        if !visited[neighbor] {
            if g.hasCycleDFS(neighbor, node, visited) {
                return true
            }
        } else if neighbor != parent {
            // –ù–∞—à–ª–∏ back edge ‚Üí —Ü–∏–∫–ª
            return true
        }
    }
    
    return false
}

// üöÄ –¢–û–ü–û–õ–û–ì–ò–ß–ï–°–ö–ê–Ø –°–û–†–¢–ò–†–û–í–ö–ê (–¥–ª—è DAG)
func (g *Graph) TopologicalSort() []int {
    visited := make(map[int]bool)
    var stack []int
    
    // DFS –¥–ª—è –≤—Å–µ—Ö –Ω–µ–ø–æ—Å–µ—â–µ–Ω–Ω—ã—Ö –≤–µ—Ä—à–∏–Ω
    for vertex := 0; vertex < g.vertices; vertex++ {
        if !visited[vertex] && len(g.adjacencyList[vertex]) > 0 {
            g.topSortDFS(vertex, visited, &stack)
        }
    }
    
    // –ü–µ—Ä–µ–≤–æ—Ä–∞—á–∏–≤–∞–µ–º —Å—Ç–µ–∫ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Ç–æ–ø–æ–ª–æ–≥–∏—á–µ—Å–∫–æ–≥–æ –ø–æ—Ä—è–¥–∫–∞
    result := make([]int, len(stack))
    for i := 0; i < len(stack); i++ {
        result[i] = stack[len(stack)-1-i]
    }
    
    return result
}

func (g *Graph) topSortDFS(node int, visited map[int]bool, stack *[]int) {
    visited[node] = true
    
    for _, neighbor := range g.adjacencyList[node] {
        if !visited[neighbor] {
            g.topSortDFS(neighbor, visited, stack)
        }
    }
    
    // –î–æ–±–∞–≤–ª—è–µ–º –≤ —Å—Ç–µ–∫ –ü–û–°–õ–ï –æ–±—Ä–∞–±–æ—Ç–∫–∏ –≤—Å–µ—Ö —Å–æ—Å–µ–¥–µ–π
    *stack = append(*stack, node)
}

// üîß Helper —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –≥—Ä–∞—Ñ–æ–≤
func CreateSampleGraph() *Graph {
    /*
         0
       /   \
      1     2
     / \   /
    3   4 5
    */
    graph := NewGraph(6)
    graph.AddEdge(0, 1)
    graph.AddEdge(0, 2)
    graph.AddEdge(1, 3)
    graph.AddEdge(1, 4)
    graph.AddEdge(2, 5)
    
    return graph
}

func CreateDAG() *Graph {
    /*
    0 ‚Üí 1 ‚Üí 3
    ‚Üì   ‚Üì   ‚Üë
    2 ‚Üí 4 ‚îÄ‚îÄ‚îò
    */
    graph := NewGraph(5)
    graph.AddDirectedEdge(0, 1)
    graph.AddDirectedEdge(0, 2)
    graph.AddDirectedEdge(1, 3)
    graph.AddDirectedEdge(1, 4)
    graph.AddDirectedEdge(2, 4)
    graph.AddDirectedEdge(4, 3)
    
    return graph
}

// üìä –ü–µ—á–∞—Ç—å –≥—Ä–∞—Ñ–∞
func (g *Graph) PrintGraph() {
    fmt.Println("Adjacency List:")
    for vertex := 0; vertex < g.vertices; vertex++ {
        if neighbors, exists := g.adjacencyList[vertex]; exists {
            fmt.Printf("%d: %v\n", vertex, neighbors)
        }
    }
}
```

```bash
üéØ –ê–õ–ì–û–†–ò–¢–ú–´ BFS –ò DFS:

BFS (BREADTH-FIRST SEARCH):
üîë –ü—Ä–∏–Ω—Ü–∏–ø: –û–±—Ö–æ–¥ "–≤ —à–∏—Ä–∏–Ω—É" - —Å–Ω–∞—á–∞–ª–∞ –≤—Å–µ —Å–æ—Å–µ–¥–∏, –ø–æ—Ç–æ–º –∏—Ö —Å–æ—Å–µ–¥–∏
üìã –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–∞–Ω–Ω—ã—Ö: –û—á–µ—Ä–µ–¥—å (Queue) - FIFO
üéØ –ü—Ä–∏–º–µ–Ω–µ–Ω–∏—è:
- –ö—Ä–∞—Ç—á–∞–π—à–∏–π –ø—É—Ç—å –≤ –Ω–µ–≤–∑–≤–µ—à–µ–Ω–Ω–æ–º –≥—Ä–∞—Ñ–µ
- Level order traversal
- –ü–æ–∏—Å–∫ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ —à–∞–≥–æ–≤
- Web crawling (—É—Ä–æ–≤–µ–Ω—å –∑–∞ —É—Ä–æ–≤–Ω–µ–º)

DFS (DEPTH-FIRST SEARCH):
üîë –ü—Ä–∏–Ω—Ü–∏–ø: –û–±—Ö–æ–¥ "–≤ –≥–ª—É–±–∏–Ω—É" - –∏–¥–µ–º –∫–∞–∫ –º–æ–∂–Ω–æ –¥–∞–ª—å—à–µ, –ø–æ—Ç–æ–º backtrack
üìö –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–∞–Ω–Ω—ã—Ö: –°—Ç–µ–∫ (Stack) –∏–ª–∏ —Ä–µ–∫—É—Ä—Å–∏—è - LIFO  
üéØ –ü—Ä–∏–º–µ–Ω–µ–Ω–∏—è:
- –ü–æ–∏—Å–∫ –≤—Å–µ—Ö –ø—É—Ç–µ–π
- –¢–æ–ø–æ–ª–æ–≥–∏—á–µ—Å–∫–∞—è —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞
- –î–µ—Ç–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Ü–∏–∫–ª–æ–≤
- –†–µ—à–µ–Ω–∏–µ –ª–∞–±–∏—Ä–∏–Ω—Ç–æ–≤

üîë –ö–õ–Æ–ß–ï–í–´–ï –†–ê–ó–õ–ò–ß–ò–Ø:

–ü–û–†–Ø–î–û–ö –û–ë–•–û–î–ê:
BFS: 0 ‚Üí 1,2 ‚Üí 3,4,5 (–ø–æ —É—Ä–æ–≤–Ω—è–º)
DFS: 0 ‚Üí 1 ‚Üí 3 ‚Üí (backtrack) ‚Üí 4 ‚Üí (backtrack) ‚Üí 2 ‚Üí 5

–°–¢–†–£–ö–¢–£–†–´ –î–ê–ù–ù–´–•:
BFS: Queue (FIFO) - –¥–æ–±–∞–≤–ª—è–µ–º –≤ –∫–æ–Ω–µ—Ü, –±–µ—Ä–µ–º —Å –Ω–∞—á–∞–ª–∞
DFS: Stack (LIFO) –∏–ª–∏ —Ä–µ–∫—É—Ä—Å–∏—è - –¥–æ–±–∞–≤–ª—è–µ–º –∏ –±–µ—Ä–µ–º —Å –∫–æ–Ω—Ü–∞

–ü–ê–ú–Ø–¢–¨:
BFS: O(V) - –≤ —Ö—É–¥—à–µ–º —Å–ª—É—á–∞–µ –≤—Å—è —à–∏—Ä–∏–Ω–∞ —É—Ä–æ–≤–Ω—è –≤ –æ—á–µ—Ä–µ–¥–∏
DFS: O(V) - –≥–ª—É–±–∏–Ω–∞ —Ä–µ–∫—É—Ä—Å–∏–∏ –∏–ª–∏ —Å—Ç–µ–∫–∞

‚ö° –°–õ–û–ñ–ù–û–°–¢–¨:

–í–†–ï–ú–Ø: O(V + E)
- V = –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤–µ—Ä—à–∏–Ω (vertices)
- E = –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä–µ–±–µ—Ä (edges)
- –ö–∞–∂–¥–∞—è –≤–µ—Ä—à–∏–Ω–∞ –ø–æ—Å–µ—â–∞–µ—Ç—Å—è –æ–¥–∏–Ω —Ä–∞–∑
- –ö–∞–∂–¥–æ–µ —Ä–µ–±—Ä–æ –ø—Ä–æ–≤–µ—Ä—è–µ—Ç—Å—è –æ–¥–∏–Ω —Ä–∞–∑

–ü–ê–ú–Ø–¢–¨: O(V)
- Visited set —Ä–∞–∑–º–µ—Ä–æ–º V
- Queue/Stack –≤ —Ö—É–¥—à–µ–º —Å–ª—É—á–∞–µ —Å–æ–¥–µ—Ä–∂–∏—Ç O(V) —ç–ª–µ–º–µ–Ω—Ç–æ–≤
- Adjacency list –∑–∞–Ω–∏–º–∞–µ—Ç O(V + E)

üîß –†–ï–ê–õ–ò–ó–ê–¶–ò–û–ù–ù–´–ï –î–ï–¢–ê–õ–ò:

VISITED SET:
- –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ—Ç –ø–æ–≤—Ç–æ—Ä–Ω–æ–µ –ø–æ—Å–µ—â–µ–Ω–∏–µ
- –ö—Ä–∏—Ç–∏—á–Ω–æ –¥–ª—è –≥—Ä–∞—Ñ–æ–≤ —Å —Ü–∏–∫–ª–∞–º–∏
- map[int]bool –≤ Go –¥–ª—è O(1) –ø—Ä–æ–≤–µ—Ä–∫–∏

–û–ß–ï–†–ï–î–¨ –í BFS:
- slice + append/prepend –æ–ø–µ—Ä–∞—Ü–∏–∏
- –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–∞: container/list –¥–ª—è O(1) –æ–ø–µ—Ä–∞—Ü–∏–π

–°–¢–ï–ö –í DFS:
- –†–µ–∫—É—Ä—Å–∏—è (–∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π —Å—Ç–µ–∫ –≤—ã–∑–æ–≤–æ–≤)
- –Ø–≤–Ω—ã–π —Å—Ç–µ–∫ —á–µ—Ä–µ–∑ slice
- –†–µ–∫—É—Ä—Å–∏—è –ø—Ä–æ—â–µ, –Ω–æ –º–æ–∂–µ—Ç –≤—ã–∑–≤–∞—Ç—å stack overflow

–ü–û–†–Ø–î–û–ö –°–û–°–ï–î–ï–ô:
- –í–ª–∏—è–µ—Ç –Ω–∞ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π –ø–æ—Ä—è–¥–æ–∫ –æ–±—Ö–æ–¥–∞
- –î–ª—è –¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ—Å—Ç–∏ –º–æ–∂–Ω–æ —Å–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å

üí° –ü–†–ò–ú–ï–ù–ï–ù–ò–Ø –ò –í–ê–†–ò–ê–¶–ò–ò:

BFS –ü–†–ò–ú–ï–ù–ï–ù–ò–Ø:
- Shortest path –≤ –Ω–µ–≤–∑–≤–µ—à–µ–Ω–Ω–æ–º –≥—Ä–∞—Ñ–µ
- Level order traversal –¥–µ—Ä–µ–≤—å–µ–≤
- –°–æ—Ü–∏–∞–ª—å–Ω—ã–µ —Å–µ—Ç–∏ (friends of friends)
- –ò–≥—Ä–æ–≤—ã–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è (–º–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ —Ö–æ–¥—ã)

DFS –ü–†–ò–ú–ï–ù–ï–ù–ò–Ø:
- Topological sorting (–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –∑–∞–¥–∞—á)
- Cycle detection (deadlock detection)
- Path finding (–≤—Å–µ –≤–æ–∑–º–æ–∂–Ω—ã–µ –ø—É—Ç–∏)
- Maze solving

–ú–û–î–ò–§–ò–ö–ê–¶–ò–ò:
- Bidirectional BFS (–≤—Å—Ç—Ä–µ—á–Ω—ã–π –ø–æ–∏—Å–∫)
- Limited depth DFS
- A* search (BFS —Å —ç–≤—Ä–∏—Å—Ç–∏–∫–æ–π)
- Dijkstra (BFS —Å –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–∞–º–∏)

‚ö†Ô∏è –û–°–û–ë–ï–ù–ù–û–°–¢–ò:

BFS –ì–ê–†–ê–ù–¢–ò–†–£–ï–¢:
- –ö—Ä–∞—Ç—á–∞–π—à–∏–π –ø—É—Ç—å –ø–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤—É —Ä–µ–±–µ—Ä
- –£–∑–ª—ã –æ–±—Ö–æ–¥—è—Ç—Å—è –≤ –ø–æ—Ä—è–¥–∫–µ —É–≤–µ–ª–∏—á–µ–Ω–∏—è —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è

DFS –ù–ï –ì–ê–†–ê–ù–¢–ò–†–£–ï–¢:
- –ö—Ä–∞—Ç—á–∞–π—à–∏–π –ø—É—Ç—å
- –ö–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π –ø–æ—Ä—è–¥–æ–∫ (–∑–∞–≤–∏—Å–∏—Ç –æ—Ç implementation)

–ì–†–ê–ù–ò–ß–ù–´–ï –°–õ–£–ß–ê–ò:
- –ü—É—Å—Ç–æ–π –≥—Ä–∞—Ñ
- –ò–∑–æ–ª–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –≤–µ—Ä—à–∏–Ω—ã  
- –ì—Ä–∞—Ñ –±–µ–∑ —Ä–µ–±–µ—Ä
- –¶–∏–∫–ª—ã (–Ω–µ–æ—Ä–∏–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ vs –æ—Ä–∏–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ)

üîß –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–ò:

EARLY TERMINATION:
- –û—Å—Ç–∞–Ω–æ–≤–∫–∞ –ø—Ä–∏ –Ω–∞—Ö–æ–∂–¥–µ–Ω–∏–∏ target
- –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –≤ –ø–æ–∏—Å–∫–µ –ø—É—Ç–∏

BIDIRECTIONAL SEARCH:
- BFS —Å –æ–±–µ–∏—Ö —Å—Ç–æ—Ä–æ–Ω (start –∏ target)
- –≠–∫—Å–ø–æ–Ω–µ–Ω—Ü–∏–∞–ª—å–Ω–æ–µ —É—Å–∫–æ—Ä–µ–Ω–∏–µ –¥–ª—è –±–æ–ª—å—à–∏—Ö –≥—Ä–∞—Ñ–æ–≤

MEMORY OPTIMIZATION:
- Iterative deepening –¥–ª—è DFS
- –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –≥–ª—É–±–∏–Ω—ã

PARALLEL PROCESSING:
- –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ—Å–µ–¥–µ–π –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ
- –°–ª–æ–∂–Ω–æ—Å—Ç–∏ —Å —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–µ–π visited set
```

### –†–µ—à–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏ 16

>[–Ω–∞–∑–∞–¥](#-–ø–æ–¥—Å–∫–∞–∑–∫–∏-–¥–ª—è-–æ—Å–Ω–æ–≤–Ω—ã—Ö-–∑–∞–¥–∞—á)

#### üéØ –†–µ—à–µ–Ω–∏–µ Stack Implementation

üìä –ê–Ω–∞–ª–∏–∑ –∑–∞–¥–∞—á–∏:

```bash
üìä –ê–ù–ê–õ–ò–ó –ó–ê–î–ê–ß–ò:

–°–¢–ï–ö (STACK) - LIFO —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–∞–Ω–Ω—ã—Ö:
Last In, First Out - –ø–æ—Å–ª–µ–¥–Ω–∏–π –≤–æ—à–µ–ª, –ø–µ—Ä–≤—ã–π –≤—ã—à–µ–ª

–û–ü–ï–†–ê–¶–ò–ò:
Push(5) ‚Üí [5]
Push(3) ‚Üí [5, 3]  
Push(7) ‚Üí [5, 3, 7]
Pop()   ‚Üí 7, —Å—Ç–µ–∫: [5, 3]
Peek()  ‚Üí 3 (–±–µ–∑ —É–¥–∞–ª–µ–Ω–∏—è)
Pop()   ‚Üí 3, —Å—Ç–µ–∫: [5]

–ü–†–ò–ú–ï–ù–ï–ù–ò–Ø:
- –í—ã—á–∏—Å–ª–µ–Ω–∏–µ –≤—ã—Ä–∞–∂–µ–Ω–∏–π (–ø–æ—Å—Ç—Ñ–∏–∫—Å–Ω–∞—è –∑–∞–ø–∏—Å—å)
- –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–∫–æ–±–æ–∫ 
- –í—ã–∑–æ–≤—ã —Ñ—É–Ω–∫—Ü–∏–π (call stack)
- Backtracking –∞–ª–≥–æ—Ä–∏—Ç–º—ã
- Undo –æ–ø–µ—Ä–∞—Ü–∏–∏ –≤ —Ä–µ–¥–∞–∫—Ç–æ—Ä–∞—Ö
```

*"–°—Ç–µ–∫ - —ç—Ç–æ LIFO —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–∞–Ω–Ω—ã—Ö. –í Go –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ —Ä–µ–∞–ª–∏–∑—É–µ—Ç—Å—è —á–µ—Ä–µ–∑ slice: append() –¥–ª—è push, slice[:len-1] –¥–ª—è pop. –ö–ª—é—á–µ–≤–æ–π –º–æ–º–µ–Ω—Ç - –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø—É—Å—Ç–æ—Ç—ã –ø–µ—Ä–µ–¥ pop/peek –æ–ø–µ—Ä–∞—Ü–∏—è–º–∏. –í—Å–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ O(1) –∞–º–æ—Ä—Ç–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ. –ü—Ä–∏–º–µ–Ω—è–µ—Ç—Å—è –¥–ª—è –≤—ã—á–∏—Å–ª–µ–Ω–∏—è –≤—ã—Ä–∞–∂–µ–Ω–∏–π, –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å–∫–æ–±–æ–∫, call stack'–∞ —Ñ—É–Ω–∫—Ü–∏–π."*

üéØ **–û–±—ä—è—Å–Ω–µ–Ω–∏–µ —Ä–µ—à–µ–Ω–∏—è:**

### **üß† –ü—Ä–∏–Ω—Ü–∏–ø LIFO (Last In, First Out):**

```
Push(1) ‚Üí [1]
Push(2) ‚Üí [1, 2]  
Push(3) ‚Üí [1, 2, 3]
Pop()   ‚Üí 3, —Å—Ç–µ–∫: [1, 2]  ‚Üê –ü–æ—Å–ª–µ–¥–Ω–∏–π –≤–æ—à–µ–ª, –ø–µ—Ä–≤—ã–π –≤—ã—à–µ–ª
Pop()   ‚Üí 2, —Å—Ç–µ–∫: [1]
```

### **üîë –ö–ª—é—á–µ–≤—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ –∏ –∏—Ö —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è:**

| –û–ø–µ—Ä–∞—Ü–∏—è | –†–µ–∞–ª–∏–∑–∞—Ü–∏—è –≤ Go | –°–ª–æ–∂–Ω–æ—Å—Ç—å |
|----------|-----------------|-----------|
| **Push** | `append(slice, item)` | O(1) –∞–º–æ—Ä—Ç–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ |
| **Pop** | `slice[:len-1]` | O(1) |
| **Peek** | `slice[len-1]` | O(1) |
| **IsEmpty** | `len(slice) == 0` | O(1) |

```go
// ‚úÖ –û–ü–¢–ò–ú–ê–õ–¨–ù–ê–Ø –†–ï–ê–õ–ò–ó–ê–¶–ò–Ø - –Ω–∞ –æ—Å–Ω–æ–≤–µ slice
type Stack[T any] struct {
    items []T
}

// üîß –ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä —Å—Ç–µ–∫–∞
func NewStack[T any]() *Stack[T] {
    return &Stack[T]{
        items: make([]T, 0),
    }
}

// üì• PUSH - –¥–æ–±–∞–≤–∏—Ç—å —ç–ª–µ–º–µ–Ω—Ç –Ω–∞ –≤–µ—Ä—à–∏–Ω—É —Å—Ç–µ–∫–∞
func (s *Stack[T]) Push(item T) {
    s.items = append(s.items, item)
}

// üì§ POP - —É–¥–∞–ª–∏—Ç—å –∏ –≤–µ—Ä–Ω—É—Ç—å —ç–ª–µ–º–µ–Ω—Ç —Å –≤–µ—Ä—à–∏–Ω—ã
func (s *Stack[T]) Pop() (T, error) {
    var zero T
    
    if s.IsEmpty() {
        return zero, errors.New("stack is empty")
    }
    
    // üîß –ü–æ–ª—É—á–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–π —ç–ª–µ–º–µ–Ω—Ç
    index := len(s.items) - 1
    item := s.items[index]
    
    // üóëÔ∏è –£–¥–∞–ª—è–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–π —ç–ª–µ–º–µ–Ω—Ç
    s.items = s.items[:index]
    
    return item, nil
}

// üëÅÔ∏è PEEK/TOP - –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å –Ω–∞ —ç–ª–µ–º–µ–Ω—Ç –Ω–∞ –≤–µ—Ä—à–∏–Ω–µ –±–µ–∑ —É–¥–∞–ª–µ–Ω–∏—è
func (s *Stack[T]) Peek() (T, error) {
    var zero T
    
    if s.IsEmpty() {
        return zero, errors.New("stack is empty")
    }
    
    return s.items[len(s.items)-1], nil
}

// ‚ùì IS_EMPTY - –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –ø—É—Å—Ç–æ—Ç—É —Å—Ç–µ–∫–∞
func (s *Stack[T]) IsEmpty() bool {
    return len(s.items) == 0
}

// üìè SIZE - –ø–æ–ª—É—á–∏—Ç—å —Ä–∞–∑–º–µ—Ä —Å—Ç–µ–∫–∞
func (s *Stack[T]) Size() int {
    return len(s.items)
}

// üìã TO_SLICE - –ø–æ–ª—É—á–∏—Ç—å –∫–æ–ø–∏—é —ç–ª–µ–º–µ–Ω—Ç–æ–≤ —Å—Ç–µ–∫–∞
func (s *Stack[T]) ToSlice() []T {
    result := make([]T, len(s.items))
    copy(result, s.items)
    return result
}

// üóëÔ∏è CLEAR - –æ—á–∏—Å—Ç–∏—Ç—å —Å—Ç–µ–∫
func (s *Stack[T]) Clear() {
    s.items = s.items[:0] // –°–æ—Ö—Ä–∞–Ω—è–µ–º capacity
}

// üìä STRING - —Å—Ç—Ä–æ–∫–æ–≤–æ–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ
func (s *Stack[T]) String() string {
    if s.IsEmpty() {
        return "Stack: []"
    }
    
    return fmt.Sprintf("Stack: %v (top: %v)", s.items, s.items[len(s.items)-1])
}

// üöÄ –ê–õ–¨–¢–ï–†–ù–ê–¢–ò–í–ù–ê–Ø –†–ï–ê–õ–ò–ó–ê–¶–ò–Ø - —Å —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–º —Ä–∞–∑–º–µ—Ä–æ–º
type FixedStack[T any] struct {
    items    []T
    top      int // –£–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ –≤–µ—Ä—à–∏–Ω—É (-1 –µ—Å–ª–∏ –ø—É—Å—Ç)
    capacity int
}

func NewFixedStack[T any](capacity int) *FixedStack[T] {
    return &FixedStack[T]{
        items:    make([]T, capacity),
        top:      -1,
        capacity: capacity,
    }
}

func (s *FixedStack[T]) Push(item T) error {
    if s.IsFull() {
        return errors.New("stack overflow")
    }
    
    s.top++
    s.items[s.top] = item
    return nil
}

func (s *FixedStack[T]) Pop() (T, error) {
    var zero T
    
    if s.IsEmpty() {
        return zero, errors.New("stack underflow")
    }
    
    item := s.items[s.top]
    s.top--
    return item, nil
}

func (s *FixedStack[T]) Peek() (T, error) {
    var zero T
    
    if s.IsEmpty() {
        return zero, errors.New("stack is empty")
    }
    
    return s.items[s.top], nil
}

func (s *FixedStack[T]) IsEmpty() bool {
    return s.top == -1
}

func (s *FixedStack[T]) IsFull() bool {
    return s.top == s.capacity-1
}

func (s *FixedStack[T]) Size() int {
    return s.top + 1
}

// üîó –†–ï–ê–õ–ò–ó–ê–¶–ò–Ø –ù–ê LINKED LIST
type StackNode[T any] struct {
    data T
    next *StackNode[T]
}

type LinkedStack[T any] struct {
    head *StackNode[T]
    size int
}

func NewLinkedStack[T any]() *LinkedStack[T] {
    return &LinkedStack[T]{}
}

func (s *LinkedStack[T]) Push(item T) {
    newNode := &StackNode[T]{
        data: item,
        next: s.head,
    }
    s.head = newNode
    s.size++
}

func (s *LinkedStack[T]) Pop() (T, error) {
    var zero T
    
    if s.IsEmpty() {
        return zero, errors.New("stack is empty")
    }
    
    item := s.head.data
    s.head = s.head.next
    s.size--
    
    return item, nil
}

func (s *LinkedStack[T]) Peek() (T, error) {
    var zero T
    
    if s.IsEmpty() {
        return zero, errors.New("stack is empty")
    }
    
    return s.head.data, nil
}

func (s *LinkedStack[T]) IsEmpty() bool {
    return s.head == nil
}

func (s *LinkedStack[T]) Size() int {
    return s.size
}

// üéØ –ü–†–ò–ú–ï–ù–ï–ù–ò–Ø –°–¢–ï–ö–ê

// üìê –í–´–ß–ò–°–õ–ï–ù–ò–ï –ü–û–°–¢–§–ò–ö–°–ù–û–ì–û –í–´–†–ê–ñ–ï–ù–ò–Ø
func EvaluatePostfix(expression []string) (int, error) {
    stack := NewStack[int]()
    
    for _, token := range expression {
        switch token {
        case "+":
            b, err1 := stack.Pop()
            a, err2 := stack.Pop()
            if err1 != nil || err2 != nil {
                return 0, errors.New("invalid expression")
            }
            stack.Push(a + b)
            
        case "-":
            b, err1 := stack.Pop()
            a, err2 := stack.Pop()
            if err1 != nil || err2 != nil {
                return 0, errors.New("invalid expression")
            }
            stack.Push(a - b)
            
        case "*":
            b, err1 := stack.Pop()
            a, err2 := stack.Pop()
            if err1 != nil || err2 != nil {
                return 0, errors.New("invalid expression")
            }
            stack.Push(a * b)
            
        case "/":
            b, err1 := stack.Pop()
            a, err2 := stack.Pop()
            if err1 != nil || err2 != nil {
                return 0, errors.New("invalid expression")
            }
            if b == 0 {
                return 0, errors.New("division by zero")
            }
            stack.Push(a / b)
            
        default:
            // –ü—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ–º, —á—Ç–æ —ç—Ç–æ —á–∏—Å–ª–æ
            var num int
            if _, err := fmt.Sscanf(token, "%d", &num); err != nil {
                return 0, fmt.Errorf("invalid token: %s", token)
            }
            stack.Push(num)
        }
    }
    
    if stack.Size() != 1 {
        return 0, errors.New("invalid expression")
    }
    
    result, _ := stack.Pop()
    return result, nil
}

// üîÑ –ò–ù–í–ï–†–¢–ò–†–û–í–ê–ù–ò–ï –°–¢–†–û–ö–ò —Å –ø–æ–º–æ—â—å—é —Å—Ç–µ–∫–∞
func ReverseString(s string) string {
    stack := NewStack[rune]()
    
    // –ü–æ–º–µ—â–∞–µ–º –≤—Å–µ —Å–∏–º–≤–æ–ª—ã –≤ —Å—Ç–µ–∫
    for _, char := range s {
        stack.Push(char)
    }
    
    // –ò–∑–≤–ª–µ–∫–∞–µ–º —Å–∏–º–≤–æ–ª—ã –≤ –æ–±—Ä–∞—Ç–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ
    var result []rune
    for !stack.IsEmpty() {
        char, _ := stack.Pop()
        result = append(result, char)
    }
    
    return string(result)
}

// üéØ –ü–†–û–í–ï–†–ö–ê –°–ë–ê–õ–ê–ù–°–ò–†–û–í–ê–ù–ù–û–°–¢–ò –°–ö–û–ë–û–ö
func IsBalanced(s string) bool {
    stack := NewStack[rune]()
    pairs := map[rune]rune{
        ')': '(',
        ']': '[',
        '}': '{',
    }
    
    for _, char := range s {
        switch char {
        case '(', '[', '{':
            stack.Push(char)
        case ')', ']', '}':
            if stack.IsEmpty() {
                return false
            }
            
            top, _ := stack.Pop()
            if top != pairs[char] {
                return false
            }
        }
    }
    
    return stack.IsEmpty()
}

// üî¢ –ü–ï–†–ï–í–û–î –ò–ó –ò–ù–§–ò–ö–°–ù–û–ô –í –ü–û–°–¢–§–ò–ö–°–ù–£–Æ –ó–ê–ü–ò–°–¨
func InfixToPostfix(infix string) string {
    stack := NewStack[rune]()
    var result []rune
    
    precedence := map[rune]int{
        '+': 1, '-': 1,
        '*': 2, '/': 2,
        '^': 3,
    }
    
    for _, char := range infix {
        switch {
        case char >= '0' && char <= '9':
            result = append(result, char)
            
        case char == '(':
            stack.Push(char)
            
        case char == ')':
            for !stack.IsEmpty() {
                top, _ := stack.Peek()
                if top == '(' {
                    stack.Pop()
                    break
                }
                op, _ := stack.Pop()
                result = append(result, op)
            }
            
        case precedence[char] > 0: // –û–ø–µ—Ä–∞—Ç–æ—Ä
            for !stack.IsEmpty() {
                top, _ := stack.Peek()
                if top == '(' || precedence[top] < precedence[char] {
                    break
                }
                op, _ := stack.Pop()
                result = append(result, op)
            }
            stack.Push(char)
        }
    }
    
    // –ò–∑–≤–ª–µ–∫–∞–µ–º –æ—Å—Ç–∞–≤—à–∏–µ—Å—è –æ–ø–µ—Ä–∞—Ç–æ—Ä—ã
    for !stack.IsEmpty() {
        op, _ := stack.Pop()
        result = append(result, op)
    }
    
    return string(result)
}

// üîß Helper —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏
func DemonstrateStack() {
    // –°–æ–∑–¥–∞–µ–º —Å—Ç–µ–∫ —Ü–µ–ª—ã—Ö —á–∏—Å–µ–ª
    stack := NewStack[int]()
    
    fmt.Println("=== –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è Stack ===")
    
    // Push –æ–ø–µ—Ä–∞—Ü–∏–∏
    fmt.Println("Push: 10, 20, 30")
    stack.Push(10)
    stack.Push(20)
    stack.Push(30)
    fmt.Println(stack)
    
    // Peek
    if top, err := stack.Peek(); err == nil {
        fmt.Printf("Peek: %d\n", top)
    }
    
    // Pop –æ–ø–µ—Ä–∞—Ü–∏–∏
    fmt.Println("Pop –æ–ø–µ—Ä–∞—Ü–∏–∏:")
    for !stack.IsEmpty() {
        if item, err := stack.Pop(); err == nil {
            fmt.Printf("Popped: %d, —Ä–∞–∑–º–µ—Ä: %d\n", item, stack.Size())
        }
    }
    
    // –ü–æ–ø—ã—Ç–∫–∞ pop –∏–∑ –ø—É—Å—Ç–æ–≥–æ —Å—Ç–µ–∫–∞
    if _, err := stack.Pop(); err != nil {
        fmt.Printf("–û—à–∏–±–∫–∞: %v\n", err)
    }
}
```

```bash
üéØ STACK (–°–¢–ï–ö) - LIFO –°–¢–†–£–ö–¢–£–†–ê –î–ê–ù–ù–´–•:

–ü–†–ò–ù–¶–ò–ü LIFO:
Last In, First Out - –ø–æ—Å–ª–µ–¥–Ω–∏–π –ø—Ä–∏—à–µ–ª, –ø–µ—Ä–≤—ã–π —É—à–µ–ª
–ê–Ω–∞–ª–æ–≥–∏—è: —Å—Ç–æ–ø–∫–∞ —Ç–∞—Ä–µ–ª–æ–∫ - –±–µ—Ä–µ–º –≤—Å–µ–≥–¥–∞ —Å–≤–µ—Ä—Ö—É

–û–°–ù–û–í–ù–´–ï –û–ü–ï–†–ê–¶–ò–ò:
- Push(item): –¥–æ–±–∞–≤–∏—Ç—å —ç–ª–µ–º–µ–Ω—Ç –Ω–∞ –≤–µ—Ä—à–∏–Ω—É - O(1)
- Pop(): —É–¥–∞–ª–∏—Ç—å –∏ –≤–µ—Ä–Ω—É—Ç—å —ç–ª–µ–º–µ–Ω—Ç —Å –≤–µ—Ä—à–∏–Ω—ã - O(1)  
- Peek/Top(): –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å —ç–ª–µ–º–µ–Ω—Ç –Ω–∞ –≤–µ—Ä—à–∏–Ω–µ - O(1)
- IsEmpty(): –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –ø—É—Å—Ç–æ—Ç—É - O(1)
- Size(): –ø–æ–ª—É—á–∏—Ç—å —Ä–∞–∑–º–µ—Ä - O(1)

üîë –ö–õ–Æ–ß–ï–í–´–ï –°–í–û–ô–°–¢–í–ê:

–î–û–°–¢–£–ü –¢–û–õ–¨–ö–û –ö –í–ï–†–®–ò–ù–ï:
- –ù–µ–ª—å–∑—è –ø–æ–ª—É—á–∏—Ç—å –ø—Ä–æ–∏–∑–≤–æ–ª—å–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç –ø–æ –∏–Ω–¥–µ–∫—Å—É
- –¢–æ–ª—å–∫–æ –ø–æ—Å–ª–µ–¥–Ω–∏–π –¥–æ–±–∞–≤–ª–µ–Ω–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç –¥–æ—Å—Ç—É–ø–µ–Ω

–î–ò–ù–ê–ú–ò–ß–ï–°–ö–ò–ô –†–ê–ó–ú–ï–†:
- –†–∞–∑–º–µ—Ä –º–µ–Ω—è–µ—Ç—Å—è –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏/—É–¥–∞–ª–µ–Ω–∏–∏
- –û–≥—Ä–∞–Ω–∏—á–µ–Ω —Ç–æ–ª—å–∫–æ –¥–æ—Å—Ç—É–ø–Ω–æ–π –ø–∞–º—è—Ç—å—é

EFFICIENT OPERATIONS:
- –í—Å–µ –æ—Å–Ω–æ–≤–Ω—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ –∑–∞ O(1) –≤—Ä–µ–º—è
- append() –≤ Go –∞–º–æ—Ä—Ç–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ O(1)

‚ö° –†–ï–ê–õ–ò–ó–ê–¶–ò–ò –ò –°–õ–û–ñ–ù–û–°–¢–¨:

SLICE-BASED (–†–µ–∫–æ–º–µ–Ω–¥—É–µ–º–∞—è):
- –ü—Ä–æ—Å—Ç–æ—Ç–∞ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏
- –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–∞–º—è—Ç—å—é
- append() –∏ slice[:len-1] –æ–ø–µ—Ä–∞—Ü–∏–∏
- –ê–º–æ—Ä—Ç–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ O(1) –¥–ª—è –≤—Å–µ—Ö –æ–ø–µ—Ä–∞—Ü–∏–π

FIXED SIZE ARRAY:
- –§–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –ø–∞–º—è—Ç—å
- –†–∏—Å–∫ stack overflow
- –ò—Å—Ç–∏–Ω–Ω–æ O(1) –≤—Å–µ –æ–ø–µ—Ä–∞—Ü–∏–∏
- –ü–æ–¥—Ö–æ–¥–∏—Ç –¥–ª—è embedded —Å–∏—Å—Ç–µ–º

LINKED LIST:
- –ò—Å—Ç–∏–Ω–Ω–æ O(1) –≤—Å–µ –æ–ø–µ—Ä–∞—Ü–∏–∏
- –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ø–∞–º—è—Ç—å –Ω–∞ —É–∫–∞–∑–∞—Ç–µ–ª–∏
- –ù–µ—Ç –ø–µ—Ä–µ–∞–ª–ª–æ–∫–∞—Ü–∏–∏
- –ë–æ–ª—å—à–µ –∫–æ–¥–∞ –¥–ª—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏

üé≠ –ü–†–ò–ú–ï–ù–ï–ù–ò–Ø –°–¢–ï–ö–ê:

EXPRESSION EVALUATION:
- –ü–æ—Å—Ç—Ñ–∏–∫—Å–Ω–∞—è –∑–∞–ø–∏—Å—å: "3 4 + 2 *" = 14
- –ò–Ω—Ñ–∏–∫—Å–Ω–∞—è ‚Üí –ø–æ—Å—Ç—Ñ–∏–∫—Å–Ω–∞—è –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è
- –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ—Å—Ç–∏ —Å–∫–æ–±–æ–∫

–ü–†–û–ì–†–ê–ú–ú–ù–´–ï –í–´–ó–û–í–´:
- Call stack –¥–ª—è —Ñ—É–Ω–∫—Ü–∏–π
- –õ–æ–∫–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –∏ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
- Return addresses

BACKTRACKING:
- Undo –æ–ø–µ—Ä–∞—Ü–∏–∏ –≤ —Ä–µ–¥–∞–∫—Ç–æ—Ä–∞—Ö
- Maze solving (–≤–æ–∑–≤—Ä–∞—Ç –≤ —Ç—É–ø–∏–∫–∞—Ö)  
- N-Queens, Sudoku —Ä–µ—à–µ–Ω–∏—è

PARSING:
- –°–∏–Ω—Ç–∞–∫—Å–∏—á–µ—Å–∫–∏–π –∞–Ω–∞–ª–∏–∑
- –†–µ–∫—É—Ä—Å–∏–≤–Ω—ã–π descent parsing
- –ö–æ–º–ø–∏–ª—è—Ç–æ—Ä—ã –∏ –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ç–æ—Ä—ã

MEMORY MANAGEMENT:
- Stack frame –¥–ª—è –ª–æ–∫–∞–ª—å–Ω—ã—Ö –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö
- –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –æ—Å–≤–æ–±–æ–∂–¥–µ–Ω–∏–µ –ø–∞–º—è—Ç–∏

üí° –í–ê–ñ–ù–´–ï –î–ï–¢–ê–õ–ò –†–ï–ê–õ–ò–ó–ê–¶–ò–ò:

ERROR HANDLING:
- Pop –∏–∑ –ø—É—Å—Ç–æ–≥–æ —Å—Ç–µ–∫–∞ ‚Üí error
- Peek –ø—É—Å—Ç–æ–≥–æ —Å—Ç–µ–∫–∞ ‚Üí error  
- Push –≤ –ø–æ–ª–Ω—ã–π —Å—Ç–µ–∫ (fixed size) ‚Üí error

GENERIC –ü–û–î–î–ï–†–ñ–ö–ê:
- Stack[T any] –¥–ª—è –ª—é–±—ã—Ö —Ç–∏–ø–æ–≤
- Type safety –≤–æ –≤—Ä–µ–º—è –∫–æ–º–ø–∏–ª—è—Ü–∏–∏
- –ü–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –∫–æ–¥–∞

MEMORY EFFICIENCY:
- Clear() —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç capacity
- ToSlice() —Å–æ–∑–¥–∞–µ—Ç –∫–æ–ø–∏—é –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
- –ò–∑–±–µ–≥–∞–µ–º memory leaks

‚ö†Ô∏è –ì–†–ê–ù–ò–ß–ù–´–ï –°–õ–£–ß–ê–ò:

–ü–£–°–¢–û–ô –°–¢–ï–ö:
- Pop/Peek –¥–æ–ª–∂–Ω—ã –≤–æ–∑–≤—Ä–∞—â–∞—Ç—å error
- IsEmpty() –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç true
- Size() –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç 0

–û–î–ò–ù –≠–õ–ï–ú–ï–ù–¢:
- Push ‚Üí size = 1
- Pop ‚Üí size = 0, stack –ø—É—Å—Ç–æ–π

–ü–ï–†–ï–ü–û–õ–ù–ï–ù–ò–ï (fixed size):
- Push –≤ –ø–æ–ª–Ω—ã–π —Å—Ç–µ–∫ ‚Üí stack overflow error
- –ü—Ä–æ–≤–µ—Ä–∫–∞ IsFull() –ø–µ—Ä–µ–¥ Push

üîß –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–ò:

CAPACITY MANAGEMENT:
- –ü—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ–µ –≤—ã–¥–µ–ª–µ–Ω–∏–µ –ø–∞–º—è—Ç–∏
- make([]T, 0, expectedSize)
- –£–º–µ–Ω—å—à–µ–Ω–∏–µ —Ä–µ–∞–ª–ª–æ–∫–∞—Ü–∏–π

POOLING:
- –ü–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ stack –æ–±—ä–µ–∫—Ç–æ–≤
- sync.Pool –¥–ª—è high-performance scenarios

BATCH OPERATIONS:
- PushAll(items []T)
- PopN(n int) []T
- –≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–µ–µ –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã—Ö –≤—ã–∑–æ–≤–æ–≤

üéØ –í–´–ë–û–† –†–ï–ê–õ–ò–ó–ê–¶–ò–ò:
- Slice-based: —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ
- Fixed-size: embedded systems, –ø—Ä–µ–¥—Å–∫–∞–∑—É–µ–º–∞—è –ø–∞–º—è—Ç—å
- Linked-list: –∫–æ–≥–¥–∞ –≤–∞–∂–Ω–∞ –∏—Å—Ç–∏–Ω–Ω–∞—è O(1) –±–µ–∑ —Ä–µ–∞–ª–ª–æ–∫–∞—Ü–∏–π
- Thread-safe: –¥–æ–±–∞–≤–∏—Ç—å mutex –¥–ª—è concurrent access
```

### –†–µ—à–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏ 19

>[–Ω–∞–∑–∞–¥](#-–ø–æ–¥—Å–∫–∞–∑–∫–∏-–¥–ª—è-–æ—Å–Ω–æ–≤–Ω—ã—Ö-–∑–∞–¥–∞—á)

#### üéØ –†–µ—à–µ–Ω–∏–µ Queue with Channels

üìä –ê–Ω–∞–ª–∏–∑ –∑–∞–¥–∞—á–∏:

```bash
üìä –ê–ù–ê–õ–ò–ó –ó–ê–î–ê–ß–ò:

QUEUE (–û–ß–ï–†–ï–î–¨) - FIFO —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–∞–Ω–Ω—ã—Ö:
First In, First Out - –ø–µ—Ä–≤—ã–π –ø—Ä–∏—à–µ–ª, –ø–µ—Ä–≤—ã–π —É—à–µ–ª

–ö–ê–ù–ê–õ–´ –í GO:
–ë—É—Ñ–µ—Ä–∏–∑–æ–≤–∞–Ω–Ω—ã–π –∫–∞–Ω–∞–ª = –≥–æ—Ç–æ–≤–∞—è FIFO –æ—á–µ—Ä–µ–¥—å!
make(chan T, capacity) ‚Üí –æ—á–µ—Ä–µ–¥—å —Ä–∞–∑–º–µ—Ä–æ–º capacity

–û–ü–ï–†–ê–¶–ò–ò:
Enqueue(5) ‚Üí ch <- 5
Enqueue(3) ‚Üí ch <- 3  
Dequeue()  ‚Üí <-ch (–≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç 5 - –ø–µ—Ä–≤—ã–π)
Dequeue()  ‚Üí <-ch (–≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç 3)

–ü–†–ï–ò–ú–£–©–ï–°–¢–í–ê –ö–ê–ù–ê–õ–û–í:
- Thread-safe –∏–∑ –∫–æ—Ä–æ–±–∫–∏
- Blocking/non-blocking –æ–ø–µ—Ä–∞—Ü–∏–∏
- Timeout support
- Graceful shutdown
- Select statement –¥–ª—è –º—É–ª—å—Ç–∏–ø–ª–µ–∫—Å–∏—Ä–æ–≤–∞–Ω–∏—è
```

*"–ë—É—Ñ–µ—Ä–∏–∑–æ–≤–∞–Ω–Ω—ã–µ –∫–∞–Ω–∞–ª—ã –≤ Go - —ç—Ç–æ –≥–æ—Ç–æ–≤—ã–µ FIFO –æ—á–µ—Ä–µ–¥–∏ —Å –≤—Å—Ç—Ä–æ–µ–Ω–Ω–æ–π thread-safety. –ö–ª—é—á–µ–≤—ã–µ –ø—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞: blocking/non-blocking –æ–ø–µ—Ä–∞—Ü–∏–∏ —á–µ—Ä–µ–∑ select, timeout support, graceful shutdown —á–µ—Ä–µ–∑ –∑–∞–∫—Ä—ã—Ç–∏–µ –∫–∞–Ω–∞–ª–æ–≤. Select –ø–æ–∑–≤–æ–ª—è–µ—Ç –º—É–ª—å—Ç–∏–ø–ª–µ–∫—Å–∏—Ä–æ–≤–∞—Ç—å –æ–ø–µ—Ä–∞—Ü–∏–∏ —Å –Ω–µ—Å–∫–æ–ª—å–∫–∏–º–∏ –∫–∞–Ω–∞–ª–∞–º–∏. –ò–¥–µ–∞–ª—å–Ω–æ –¥–ª—è worker pools –∏ producer-consumer –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤."*

üéØ **–û–±—ä—è—Å–Ω–µ–Ω–∏–µ —Ä–µ—à–µ–Ω–∏—è:**

### **üß† –ö–∞–Ω–∞–ª—ã –∫–∞–∫ –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω–∞—è FIFO —Å—Ç—Ä—É–∫—Ç—É—Ä–∞:**

```go
// –ë—É—Ñ–µ—Ä–∏–∑–æ–≤–∞–Ω–Ω—ã–π –∫–∞–Ω–∞–ª = –≥–æ—Ç–æ–≤–∞—è –æ—á–µ—Ä–µ–¥—å!
queue := make(chan int, 3)  // –û—á–µ—Ä–µ–¥—å —Ä–∞–∑–º–µ—Ä–æ–º 3

// Enqueue
queue <- 1  // [1]
queue <- 2  // [1, 2]  
queue <- 3  // [1, 2, 3]

// Dequeue  
item := <-queue  // item = 1, –æ—á–µ—Ä–µ–¥—å: [2, 3]
item = <-queue   // item = 2, –æ—á–µ—Ä–µ–¥—å: [3]
```

**–ö–ª—é—á–µ–≤–æ–µ –ø—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–æ:** Thread-safety –≤—Å—Ç—Ä–æ–µ–Ω–∞ –≤ –∫–∞–Ω–∞–ª—ã!

### **üîë –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –ø–∞—Ç—Ç–µ—Ä–Ω—ã —Å select:**

**Non-blocking –æ–ø–µ—Ä–∞—Ü–∏–∏:**

```go
// Non-blocking enqueue
select {
case queue <- item:
    // –£—Å–ø–µ—à–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω–æ
default:
    // –û—á–µ—Ä–µ–¥—å –ø–æ–ª–Ω–∞—è - –Ω–µ–º–µ–¥–ª–µ–Ω–Ω—ã–π –≤–æ–∑–≤—Ä–∞—Ç
}

// Non-blocking dequeue
select {
case item := <-queue:
    // –≠–ª–µ–º–µ–Ω—Ç –ø–æ–ª—É—á–µ–Ω
default:
    // –û—á–µ—Ä–µ–¥—å –ø—É—Å—Ç–∞—è - –Ω–µ–º–µ–¥–ª–µ–Ω–Ω—ã–π –≤–æ–∑–≤—Ä–∞—Ç
}
```

**Timeout –æ–ø–µ—Ä–∞—Ü–∏–∏:**

```go
// Enqueue —Å —Ç–∞–π–º–∞—É—Ç–æ–º
select {
case queue <- item:
    // –£—Å–ø–µ—Ö
case <-time.After(5 * time.Second):
    // –¢–∞–π–º–∞—É—Ç - –æ—á–µ—Ä–µ–¥—å –±—ã–ª–∞ –ø–æ–ª–Ω–∞—è —Å–ª–∏—à–∫–æ–º –¥–æ–ª–≥–æ
}
```

**Context cancellation:**

```go
// –ü—Ä–µ—Ä—ã–≤–∞–µ–º—ã–π dequeue
select {
case item := <-queue:
    return item, nil
case <-ctx.Done():
    return zero, ctx.Err()  // –û–ø–µ—Ä–∞—Ü–∏—è –æ—Ç–º–µ–Ω–µ–Ω–∞
}
```

### **‚ö° –°—Ä–∞–≤–Ω–µ–Ω–∏–µ –ø–æ–¥—Ö–æ–¥–æ–≤:**

| –ü–æ–¥—Ö–æ–¥ | Thread-safety | Blocking | Timeout | –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–π —Ä–∞–∑–º–µ—Ä |
|--------|---------------|----------|---------|-------------------|
| **Buffered Channel** | ‚úÖ –í—Å—Ç—Ä–æ–µ–Ω–∞ | ‚úÖ –î–∞ | ‚úÖ –ß–µ—Ä–µ–∑ select | ‚ùå –§–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–π |
| **Slice + Mutex** | üîß –ù—É–∂–Ω—ã mutex'—ã | ‚ùå –ù–µ—Ç | ‚ùå –†—É—á–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è | ‚úÖ –î–∞ |
| **Unbounded Queue** | ‚úÖ –í—Å—Ç—Ä–æ–µ–Ω–∞ | ‚úÖ –î–∞ | ‚úÖ –ß–µ—Ä–µ–∑ select | ‚úÖ –î–∞ |

### **üé≠ –ö–ª—é—á–µ–≤—ã–µ –ø–∞—Ç—Ç–µ—Ä–Ω—ã –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è:**

**Worker Pool:**

```go
// –ö–ª–∞—Å—Å–∏—á–µ—Å–∫–∏–π –ø–∞—Ç—Ç–µ—Ä–Ω –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∑–∞–¥–∞—á
type WorkerPool struct {
    taskQueue chan Task
    workers   int
}

// Workers —á–∏—Ç–∞—é—Ç –∏–∑ –æ–±—â–µ–π –æ—á–µ—Ä–µ–¥–∏
for task := range wp.taskQueue {
    process(task)
}
```

**Producer-Consumer:**

```go
// –ú–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ producers
go func() {
    for item := range dataSource {
        queue <- item  // Thread-safe –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ
    }
}()

// –ú–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ consumers  
go func() {
    for item := range queue {
        process(item)  // Thread-safe –∏–∑–≤–ª–µ—á–µ–Ω–∏–µ
    }
}()
```

**Priority Queue —Å –∫–∞–Ω–∞–ª–∞–º–∏:**

```go
// –û—Ç–¥–µ–ª—å–Ω—ã–π –∫–∞–Ω–∞–ª –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–∞
type PriorityQueue struct {
    high   chan Task
    medium chan Task  
    low    chan Task
}

// Dequeue —Å –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–æ–º
select {
case task := <-pq.high:    // –°–Ω–∞—á–∞–ª–∞ –≤—ã—Å–æ–∫–∏–π –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç
    return task
case task := <-pq.medium:  // –ü–æ—Ç–æ–º —Å—Ä–µ–¥–Ω–∏–π
    return task  
case task := <-pq.low:     // –í –∫–æ–Ω—Ü–µ –Ω–∏–∑–∫–∏–π
    return task
}
```

### **üåü Unbounded Queue —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è:**

```go
// –†–µ—à–∞–µ—Ç –ø—Ä–æ–±–ª–µ–º—É —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ —Ä–∞–∑–º–µ—Ä–∞
type UnboundedQueue struct {
    input  chan T      // –î–ª—è producers
    output chan T      // –î–ª—è consumers
    buffer []T         // –í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π –±—É—Ñ–µ—Ä
}

// Background goroutine –ø–µ—Ä–µ–∫–∞—á–∏–≤–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ
func (q *UnboundedQueue) run() {
    for {
        if len(q.buffer) == 0 {
            // –ñ–¥–µ–º –Ω–æ–≤—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã
            item := <-q.input
            q.buffer = append(q.buffer, item)
        } else {
            // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø–µ—Ä–≤—ã–π —ç–ª–µ–º–µ–Ω—Ç
            select {
            case item := <-q.input:
                q.buffer = append(q.buffer, item)
            case q.output <- q.buffer[0]:
                q.buffer = q.buffer[1:]
            }
        }
    }
}
```

### **üí° –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–∏ Go –∫–∞–Ω–∞–ª–æ–≤:**

**–ó–∞–∫—Ä—ã—Ç–∏–µ –∫–∞–Ω–∞–ª–æ–≤:**

```go
close(queue)  // –°–∏–≥–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç –æ–± –æ–∫–æ–Ω—á–∞–Ω–∏–∏

// –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞–∫—Ä—ã—Ç–∏—è
item, ok := <-queue
if !ok {
    // –ö–∞–Ω–∞–ª –∑–∞–∫—Ä—ã—Ç
}

// Range –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∑–∞–≤–µ—Ä—à–∞–µ—Ç—Å—è –ø—Ä–∏ –∑–∞–∫—Ä—ã—Ç–∏–∏
for item := range queue {
    process(item)
}
```

**–†–∞–∑–º–µ—Ä –±—É—Ñ–µ—Ä–∞ –≤–ª–∏—è–µ—Ç –Ω–∞ –ø–æ–≤–µ–¥–µ–Ω–∏–µ:**

```go
sync := make(chan int)      // capacity = 0: —Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π
async := make(chan int, 10) // capacity > 0: –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π

sync <- item    // –ë–ª–æ–∫–∏—Ä—É–µ—Ç—Å—è –ø–æ–∫–∞ –∫—Ç–æ-—Ç–æ –Ω–µ –ø—Ä–æ—á–∏—Ç–∞–µ—Ç
async <- item   // –ù–µ –±–ª–æ–∫–∏—Ä—É–µ—Ç—Å—è –µ—Å–ª–∏ –±—É—Ñ–µ—Ä –Ω–µ –ø–æ–ª–Ω—ã–π
```

### üéØ –†–µ—à–µ–Ω–∏–µ Queue with Channels

```go
import (
    "context"
    "errors"
    "fmt"
    "sync"
    "time"
)

// ‚úÖ –û–°–ù–û–í–ù–ê–Ø –†–ï–ê–õ–ò–ó–ê–¶–ò–Ø - Queue —Å –∫–∞–Ω–∞–ª–∞–º–∏
type ChannelQueue[T any] struct {
    ch     chan T
    closed bool
    mu     sync.RWMutex // –ó–∞—â–∏—Ç–∞ closed —Ñ–ª–∞–≥–∞
}

// üîß –ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä –æ—á–µ—Ä–µ–¥–∏
func NewChannelQueue[T any](capacity int) *ChannelQueue[T] {
    return &ChannelQueue[T]{
        ch: make(chan T, capacity),
    }
}

// üì• ENQUEUE - –¥–æ–±–∞–≤–∏—Ç—å —ç–ª–µ–º–µ–Ω—Ç –≤ –æ—á–µ—Ä–µ–¥—å (blocking)
func (q *ChannelQueue[T]) Enqueue(item T) error {
    q.mu.RLock()
    if q.closed {
        q.mu.RUnlock()
        return errors.New("queue is closed")
    }
    q.mu.RUnlock()
    
    q.ch <- item // –ë–ª–æ–∫–∏—Ä—É–µ—Ç—Å—è –µ—Å–ª–∏ –æ—á–µ—Ä–µ–¥—å –ø–æ–ª–Ω–∞—è
    return nil
}

// üì§ DEQUEUE - –∏–∑–≤–ª–µ—á—å —ç–ª–µ–º–µ–Ω—Ç –∏–∑ –æ—á–µ—Ä–µ–¥–∏ (blocking)
func (q *ChannelQueue[T]) Dequeue() (T, error) {
    var zero T
    
    item, ok := <-q.ch
    if !ok {
        return zero, errors.New("queue is closed")
    }
    
    return item, nil
}

// üöÄ ENQUEUE NON-BLOCKING - —Å –Ω–µ–º–µ–¥–ª–µ–Ω–Ω—ã–º –≤–æ–∑–≤—Ä–∞—Ç–æ–º
func (q *ChannelQueue[T]) TryEnqueue(item T) error {
    q.mu.RLock()
    if q.closed {
        q.mu.RUnlock()
        return errors.New("queue is closed")
    }
    q.mu.RUnlock()
    
    select {
    case q.ch <- item:
        return nil // –£—Å–ø–µ—à–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω–æ
    default:
        return errors.New("queue is full") // –û—á–µ—Ä–µ–¥—å –ø–æ–ª–Ω–∞—è
    }
}

// üöÄ DEQUEUE NON-BLOCKING - —Å –Ω–µ–º–µ–¥–ª–µ–Ω–Ω—ã–º –≤–æ–∑–≤—Ä–∞—Ç–æ–º
func (q *ChannelQueue[T]) TryDequeue() (T, error) {
    var zero T
    
    select {
    case item, ok := <-q.ch:
        if !ok {
            return zero, errors.New("queue is closed")
        }
        return item, nil
    default:
        return zero, errors.New("queue is empty") // –û—á–µ—Ä–µ–¥—å –ø—É—Å—Ç–∞—è
    }
}

// ‚è∞ ENQUEUE –° TIMEOUT
func (q *ChannelQueue[T]) EnqueueTimeout(item T, timeout time.Duration) error {
    q.mu.RLock()
    if q.closed {
        q.mu.RUnlock()
        return errors.New("queue is closed")
    }
    q.mu.RUnlock()
    
    select {
    case q.ch <- item:
        return nil
    case <-time.After(timeout):
        return errors.New("enqueue timeout")
    }
}

// ‚è∞ DEQUEUE –° TIMEOUT
func (q *ChannelQueue[T]) DequeueTimeout(timeout time.Duration) (T, error) {
    var zero T
    
    select {
    case item, ok := <-q.ch:
        if !ok {
            return zero, errors.New("queue is closed")
        }
        return item, nil
    case <-time.After(timeout):
        return zero, errors.New("dequeue timeout")
    }
}

// üéØ DEQUEUE –° CONTEXT (–¥–ª—è cancellation)
func (q *ChannelQueue[T]) DequeueContext(ctx context.Context) (T, error) {
    var zero T
    
    select {
    case item, ok := <-q.ch:
        if !ok {
            return zero, errors.New("queue is closed")
        }
        return item, nil
    case <-ctx.Done():
        return zero, ctx.Err()
    }
}

// üìä SIZE - —Ä–∞–∑–º–µ—Ä –æ—á–µ—Ä–µ–¥–∏
func (q *ChannelQueue[T]) Size() int {
    return len(q.ch)
}

// üìä CAPACITY - –≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å –æ—á–µ—Ä–µ–¥–∏
func (q *ChannelQueue[T]) Capacity() int {
    return cap(q.ch)
}

// ‚ùì IS_EMPTY - –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø—É—Å—Ç–æ—Ç—ã
func (q *ChannelQueue[T]) IsEmpty() bool {
    return q.Size() == 0
}

// ‚ùì IS_FULL - –ø—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞–ø–æ–ª–Ω–µ–Ω–Ω–æ—Å—Ç–∏
func (q *ChannelQueue[T]) IsFull() bool {
    return q.Size() == q.Capacity()
}

// üóëÔ∏è CLOSE - –∑–∞–∫—Ä—ã—Ç—å –æ—á–µ—Ä–µ–¥—å
func (q *ChannelQueue[T]) Close() {
    q.mu.Lock()
    if !q.closed {
        close(q.ch)
        q.closed = true
    }
    q.mu.Unlock()
}

// üìã DRAIN - –∏–∑–≤–ª–µ—á—å –≤—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã
func (q *ChannelQueue[T]) Drain() []T {
    var items []T
    
    for {
        select {
        case item, ok := <-q.ch:
            if !ok {
                return items // –ö–∞–Ω–∞–ª –∑–∞–∫—Ä—ã—Ç
            }
            items = append(items, item)
        default:
            return items // –ö–∞–Ω–∞–ª –ø—É—Å—Ç
        }
    }
}

// üåü UNBOUNDED QUEUE - –Ω–µ–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω–∞—è –æ—á–µ—Ä–µ–¥—å
type UnboundedQueue[T any] struct {
    input  chan T
    output chan T
    buffer []T
    closed bool
    wg     sync.WaitGroup
}

func NewUnboundedQueue[T any]() *UnboundedQueue[T] {
    q := &UnboundedQueue[T]{
        input:  make(chan T),
        output: make(chan T),
        buffer: make([]T, 0),
    }
    
    q.wg.Add(1)
    go q.run()
    
    return q
}

func (q *UnboundedQueue[T]) run() {
    defer q.wg.Done()
    defer close(q.output)
    
    for {
        if len(q.buffer) == 0 {
            // –ë—É—Ñ–µ—Ä –ø—É—Å—Ç - –∂–¥–µ–º –Ω–æ–≤—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã
            select {
            case item, ok := <-q.input:
                if !ok {
                    return // input –∑–∞–∫—Ä—ã—Ç
                }
                q.buffer = append(q.buffer, item)
            }
        } else {
            // –ë—É—Ñ–µ—Ä –Ω–µ –ø—É—Å—Ç - –ø—ã—Ç–∞–µ–º—Å—è –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –ø–µ—Ä–≤—ã–π —ç–ª–µ–º–µ–Ω—Ç
            select {
            case item, ok := <-q.input:
                if !ok {
                    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ—Å—Ç–∞–≤—à–∏–µ—Å—è —ç–ª–µ–º–µ–Ω—Ç—ã
                    for _, remaining := range q.buffer {
                        q.output <- remaining
                    }
                    return
                }
                q.buffer = append(q.buffer, item)
                
            case q.output <- q.buffer[0]:
                q.buffer = q.buffer[1:] // –£–¥–∞–ª—è–µ–º –ø–µ—Ä–≤—ã–π —ç–ª–µ–º–µ–Ω—Ç
            }
        }
    }
}

func (q *UnboundedQueue[T]) Enqueue(item T) error {
    if q.closed {
        return errors.New("queue is closed")
    }
    
    select {
    case q.input <- item:
        return nil
    default:
        return errors.New("queue is closed")
    }
}

func (q *UnboundedQueue[T]) Dequeue() (T, error) {
    var zero T
    
    item, ok := <-q.output
    if !ok {
        return zero, errors.New("queue is closed")
    }
    
    return item, nil
}

func (q *UnboundedQueue[T]) Close() {
    if !q.closed {
        q.closed = true
        close(q.input)
        q.wg.Wait() // –ñ–¥–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è goroutine
    }
}

// üé≠ WORKER POOL PATTERN —Å –æ—á–µ—Ä–µ–¥—å—é
type WorkerPool[T any] struct {
    queue     *ChannelQueue[T]
    workers   int
    processor func(T) error
    wg        sync.WaitGroup
    ctx       context.Context
    cancel    context.CancelFunc
}

func NewWorkerPool[T any](queueSize, workers int, processor func(T) error) *WorkerPool[T] {
    ctx, cancel := context.WithCancel(context.Background())
    
    return &WorkerPool[T]{
        queue:     NewChannelQueue[T](queueSize),
        workers:   workers,
        processor: processor,
        ctx:       ctx,
        cancel:    cancel,
    }
}

func (wp *WorkerPool[T]) Start() {
    for i := 0; i < wp.workers; i++ {
        wp.wg.Add(1)
        go wp.worker(i)
    }
}

func (wp *WorkerPool[T]) worker(id int) {
    defer wp.wg.Done()
    
    fmt.Printf("Worker %d started\n", id)
    
    for {
        select {
        case <-wp.ctx.Done():
            fmt.Printf("Worker %d stopping\n", id)
            return
            
        default:
            item, err := wp.queue.DequeueTimeout(100 * time.Millisecond)
            if err != nil {
                continue // Timeout –∏–ª–∏ –æ—á–µ—Ä–µ–¥—å –ø—É—Å—Ç–∞—è
            }
            
            if err := wp.processor(item); err != nil {
                fmt.Printf("Worker %d error processing %v: %v\n", id, item, err)
            }
        }
    }
}

func (wp *WorkerPool[T]) Submit(item T) error {
    return wp.queue.TryEnqueue(item)
}

func (wp *WorkerPool[T]) Shutdown() {
    wp.cancel()       // –°–∏–≥–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º workers –æ—Å—Ç–∞–Ω–æ–≤–∏—Ç—å—Å—è
    wp.queue.Close()  // –ó–∞–∫—Ä—ã–≤–∞–µ–º –æ—á–µ—Ä–µ–¥—å
    wp.wg.Wait()      // –ñ–¥–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –≤—Å–µ—Ö workers
}

// üéØ PRIORITY QUEUE —Å –∫–∞–Ω–∞–ª–∞–º–∏
type PriorityItem[T any] struct {
    Data     T
    Priority int
}

type PriorityQueue[T any] struct {
    channels map[int]chan T // –ö–∞–Ω–∞–ª –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–∞
    mu       sync.RWMutex
    closed   bool
}

func NewPriorityQueue[T any](capacity int) *PriorityQueue[T] {
    return &PriorityQueue[T]{
        channels: make(map[int]chan T),
    }
}

func (pq *PriorityQueue[T]) Enqueue(item T, priority int) error {
    pq.mu.Lock()
    defer pq.mu.Unlock()
    
    if pq.closed {
        return errors.New("queue is closed")
    }
    
    if _, exists := pq.channels[priority]; !exists {
        pq.channels[priority] = make(chan T, 100) // –ë—É—Ñ–µ—Ä –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–∞
    }
    
    select {
    case pq.channels[priority] <- item:
        return nil
    default:
        return errors.New("priority queue is full")
    }
}

func (pq *PriorityQueue[T]) Dequeue() (T, int, error) {
    var zero T
    
    pq.mu.RLock()
    defer pq.mu.RUnlock()
    
    if pq.closed {
        return zero, 0, errors.New("queue is closed")
    }
    
    // –ò—â–µ–º –Ω–∞–∏–≤—ã—Å—à–∏–π –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç —Å —ç–ª–µ–º–µ–Ω—Ç–∞–º–∏
    var maxPriority int = -1
    for priority, ch := range pq.channels {
        if len(ch) > 0 && priority > maxPriority {
            maxPriority = priority
        }
    }
    
    if maxPriority == -1 {
        return zero, 0, errors.New("queue is empty")
    }
    
    select {
    case item := <-pq.channels[maxPriority]:
        return item, maxPriority, nil
    default:
        return zero, 0, errors.New("queue is empty")
    }
}

// üîß Helper —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏
func DemonstrateChannelQueue() {
    fmt.Println("=== –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è Channel Queue ===")
    
    // –°–æ–∑–¥–∞–µ–º –æ—á–µ—Ä–µ–¥—å —Å –±—É—Ñ–µ—Ä–æ–º 3
    queue := NewChannelQueue[string](3)
    
    // Blocking enqueue
    fmt.Println("Enqueue: A, B, C")
    queue.Enqueue("A")
    queue.Enqueue("B")
    queue.Enqueue("C")
    
    fmt.Printf("Size: %d, Full: %v\n", queue.Size(), queue.IsFull())
    
    // Non-blocking –ø–æ–ø—ã—Ç–∫–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –≤ –ø–æ–ª–Ω—É—é –æ—á–µ—Ä–µ–¥—å
    if err := queue.TryEnqueue("D"); err != nil {
        fmt.Printf("TryEnqueue failed: %v\n", err)
    }
    
    // Dequeue —ç–ª–µ–º–µ–Ω—Ç—ã
    for i := 0; i < 3; i++ {
        if item, err := queue.Dequeue(); err == nil {
            fmt.Printf("Dequeued: %s\n", item)
        }
    }
    
    // Timeout dequeue –∏–∑ –ø—É—Å—Ç–æ–π –æ—á–µ—Ä–µ–¥–∏
    if _, err := queue.DequeueTimeout(100 * time.Millisecond); err != nil {
        fmt.Printf("Timeout dequeue: %v\n", err)
    }
    
    queue.Close()
}

func DemonstrateWorkerPool() {
    fmt.Println("\n=== –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è Worker Pool ===")
    
    // –ü—Ä–æ—Ü–µ—Å—Å–æ—Ä –∑–∞–¥–∞—á
    processor := func(task int) error {
        fmt.Printf("Processing task %d\n", task)
        time.Sleep(100 * time.Millisecond) // –ò–º–∏—Ç–∞—Ü–∏—è —Ä–∞–±–æ—Ç—ã
        return nil
    }
    
    // –°–æ–∑–¥–∞–µ–º worker pool
    pool := NewWorkerPool(10, 3, processor)
    pool.Start()
    
    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∑–∞–¥–∞—á–∏
    for i := 1; i <= 5; i++ {
        if err := pool.Submit(i); err != nil {
            fmt.Printf("Failed to submit task %d: %v\n", i, err)
        }
    }
    
    // –ñ–¥–µ–º –Ω–µ–∫–æ—Ç–æ—Ä–æ–µ –≤—Ä–µ–º—è –∏ –∑–∞–≤–µ—Ä—à–∞–µ–º
    time.Sleep(1 * time.Second)
    pool.Shutdown()
    fmt.Println("Worker pool stopped")
}
```

```bash
üéØ QUEUE –° –ö–ê–ù–ê–õ–ê–ú–ò –í GO:

–ü–†–ò–†–û–î–ù–´–ï –ü–†–ï–ò–ú–£–©–ï–°–¢–í–ê –ö–ê–ù–ê–õ–û–í:
üîí Thread-safe –∏–∑ –∫–æ—Ä–æ–±–∫–∏ - –Ω–µ –Ω—É–∂–Ω—ã mutex'—ã
üìã FIFO –ø–æ—Ä—è–¥–æ–∫ –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω
üö´ Blocking/non-blocking –æ–ø–µ—Ä–∞—Ü–∏–∏ —á–µ—Ä–µ–∑ select
‚è∞ Timeout –ø–æ–¥–¥–µ—Ä–∂–∫–∞ –≤—Å—Ç—Ä–æ–µ–Ω–∞
üéØ Graceful shutdown —á–µ—Ä–µ–∑ –∑–∞–∫—Ä—ã—Ç–∏–µ –∫–∞–Ω–∞–ª–æ–≤

–ë–£–§–ï–†–ò–ó–û–í–ê–ù–ù–´–ô –ö–ê–ù–ê–õ = –ì–û–¢–û–í–ê–Ø –û–ß–ï–†–ï–î–¨:
make(chan T, capacity) —Å–æ–∑–¥–∞–µ—Ç –æ—á–µ—Ä–µ–¥—å —Ä–∞–∑–º–µ—Ä–æ–º capacity
ch <- item  ‚â° Enqueue(item)
item := <-ch ‚â° Dequeue()

üîë –ö–õ–Æ–ß–ï–í–´–ï –ü–ê–¢–¢–ï–†–ù–´:

BLOCKING –û–ü–ï–†–ê–¶–ò–ò:
ch <- item     // –ë–ª–æ–∫–∏—Ä—É–µ—Ç—Å—è –µ—Å–ª–∏ –∫–∞–Ω–∞–ª –ø–æ–ª–Ω—ã–π
item := <-ch   // –ë–ª–æ–∫–∏—Ä—É–µ—Ç—Å—è –µ—Å–ª–∏ –∫–∞–Ω–∞–ª –ø—É—Å—Ç–æ–π

NON-BLOCKING –û–ü–ï–†–ê–¶–ò–ò:
select {
case ch <- item:
    // –£—Å–ø–µ—à–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω–æ
default:
    // –ö–∞–Ω–∞–ª –ø–æ–ª–Ω—ã–π
}

TIMEOUT –û–ü–ï–†–ê–¶–ò–ò:
select {
case item := <-ch:
    // –ü–æ–ª—É—á–µ–Ω —ç–ª–µ–º–µ–Ω—Ç
case <-time.After(timeout):
    // Timeout
}

CONTEXT CANCELLATION:
select {
case item := <-ch:
    // –ü–æ–ª—É—á–µ–Ω —ç–ª–µ–º–µ–Ω—Ç  
case <-ctx.Done():
    // –û–ø–µ—Ä–∞—Ü–∏—è –æ—Ç–º–µ–Ω–µ–Ω–∞
}

‚ö° –°–õ–û–ñ–ù–û–°–¢–¨ –û–ü–ï–†–ê–¶–ò–ô:

ENQUEUE: O(1)
- –ü—Ä–æ—Å—Ç–æ–µ –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –≤ –±—É—Ñ–µ—Ä –∫–∞–Ω–∞–ª–∞
- –ë–ª–æ–∫–∏—Ä—É–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –±—É—Ñ–µ—Ä –ø–æ–ª–Ω—ã–π

DEQUEUE: O(1)  
- –ü—Ä–æ—Å—Ç–æ–µ –∏–∑–≤–ª–µ—á–µ–Ω–∏–µ –∏–∑ –±—É—Ñ–µ—Ä–∞ –∫–∞–Ω–∞–ª–∞
- –ë–ª–æ–∫–∏—Ä—É–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –±—É—Ñ–µ—Ä –ø—É—Å—Ç–æ–π

SIZE/CAPACITY: O(1)
- len(ch) –∏ cap(ch) –≤—ã–ø–æ–ª–Ω—è—é—Ç—Å—è –∑–∞ –∫–æ–Ω—Å—Ç–∞–Ω—Ç–Ω–æ–µ –≤—Ä–µ–º—è

üé≠ –ü–ê–¢–¢–ï–†–ù–´ –ò–°–ü–û–õ–¨–ó–û–í–ê–ù–ò–Ø:

WORKER POOL:
- –û—á–µ—Ä–µ–¥—å –∑–∞–¥–∞—á + —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ —á–∏—Å–ª–æ workers
- –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –Ω–∞–≥—Ä—É–∑–∫–∏
- Graceful shutdown —á–µ—Ä–µ–∑ context

PRODUCER-CONSUMER:
- Producers –¥–æ–±–∞–≤–ª—è—é—Ç –≤ –æ—á–µ—Ä–µ–¥—å
- Consumers –∏–∑–≤–ª–µ–∫–∞—é—Ç –∏–∑ –æ—á–µ—Ä–µ–¥–∏  
- –ö–∞–Ω–∞–ª—ã –∫–æ–æ—Ä–¥–∏–Ω–∏—Ä—É—é—Ç –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–µ

PIPELINE:
- –¶–µ–ø–æ—á–∫–∞ –æ—á–µ—Ä–µ–¥–µ–π –º–µ–∂–¥—É —Å—Ç–∞–¥–∏—è–º–∏ –æ–±—Ä–∞–±–æ—Ç–∫–∏
- –ö–∞–∂–¥–∞—è —Å—Ç–∞–¥–∏—è - –æ—Ç–¥–µ–ª—å–Ω–∞—è goroutine
- Backpressure —á–µ—Ä–µ–∑ —Ä–∞–∑–º–µ—Ä –±—É—Ñ–µ—Ä–æ–≤

PRIORITY QUEUE:
- –û—Ç–¥–µ–ª—å–Ω—ã–π –∫–∞–Ω–∞–ª –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–∞
- Select —Å –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–Ω—ã–º –ø–æ—Ä—è–¥–∫–æ–º
- –ò–ª–∏ heap-based —Å –∫–∞–Ω–∞–ª–æ–º –¥–ª—è —Å–∏–≥–Ω–∞–ª–∏–∑–∞—Ü–∏–∏

üí° –°–†–ê–í–ù–ï–ù–ò–ï –° –û–ë–´–ß–ù–´–ú–ò –û–ß–ï–†–ï–î–Ø–ú–ò:

–ö–ê–ù–ê–õ–´:
+ Thread-safe –∏–∑ –∫–æ—Ä–æ–±–∫–∏
+ Blocking/non-blocking –æ–ø–µ—Ä–∞—Ü–∏–∏  
+ Timeout –∏ cancellation
+ –ö–æ–º–ø–æ–∑–∏—Ä—É–µ–º–æ—Å—Ç—å —Å select
- –§–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ä–∞–∑–º–µ—Ä –±—É—Ñ–µ—Ä–∞
- Overhead –Ω–∞ synchronization

SLICE-BASED QUEUE:
+ –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–π —Ä–∞–∑–º–µ—Ä
+ –ú–µ–Ω—å—à–µ memory overhead
+ –ü—Ä—è–º–æ–π –¥–æ—Å—Ç—É–ø –∫ —ç–ª–µ–º–µ–Ω—Ç–∞–º
- –ù—É–∂–Ω—ã mutex –¥–ª—è thread-safety
- –ù–µ—Ç built-in timeout/cancellation

‚ö†Ô∏è –í–ê–ñ–ù–´–ï –û–°–û–ë–ï–ù–ù–û–°–¢–ò:

–ó–ê–ö–†–´–¢–ò–ï –ö–ê–ù–ê–õ–û–í:
- close(ch) —Å–∏–≥–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç –æ–± –æ–∫–æ–Ω—á–∞–Ω–∏–∏
- –ü–æ–ª—É—á–µ–Ω–∏–µ –∏–∑ –∑–∞–∫—Ä—ã—Ç–æ–≥–æ –∫–∞–Ω–∞–ª–∞ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç zero value + false
- –û—Ç–ø—Ä–∞–≤–∫–∞ –≤ –∑–∞–∫—Ä—ã—Ç—ã–π –∫–∞–Ω–∞–ª ‚Üí panic

–†–ê–ó–ú–ï–† –ë–£–§–ï–†–ê:
- capacity = 0: —Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π –∫–∞–Ω–∞–ª (rendezvous)
- capacity > 0: –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π —Å –±—É—Ñ–µ—Ä–æ–º
- –†–∞–∑–º–µ—Ä –≤–ª–∏—è–µ—Ç –Ω–∞ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∏ memory usage

–£–¢–ï–ß–ö–ò GOROUTINES:
- –í—Å–µ–≥–¥–∞ –æ–±–µ—Å–ø–µ—á–∏–≤–∞—Ç—å graceful shutdown
- Context –¥–ª—è cancellation
- –¢–∞–π–º–∞—É—Ç—ã –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è deadlock

üîß –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–ò:

BATCHING:
- –ì—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞ –æ–ø–µ—Ä–∞—Ü–∏–π –¥–ª—è —É–º–µ–Ω—å—à–µ–Ω–∏—è overhead
- –û—Å–æ–±–µ–Ω–Ω–æ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ –¥–ª—è high-throughput scenarios

POOLING:
- –ü–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –∫–∞–Ω–∞–ª–æ–≤ –∏ goroutines
- sync.Pool –¥–ª—è –æ–±—ä–µ–∫—Ç–æ–≤

UNBOUNDED QUEUES:
- –ü—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã–π –±—É—Ñ–µ—Ä + background goroutine
- –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ—Ç –±–ª–æ–∫–∏—Ä–æ–≤–∫—É producers

SELECT –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–ò:
- –ü–æ—Ä—è–¥–æ–∫ case'–æ–≤ –≤–ª–∏—è–µ—Ç –Ω–∞ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å
- default case —Ç–æ–ª—å–∫–æ –∫–æ–≥–¥–∞ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ –Ω—É–∂–µ–Ω

üéØ –í–´–ë–û–† –ü–û–î–•–û–î–ê:
- Buffered channel: –ø—Ä–æ—Å—Ç—ã–µ —Å–ª—É—á–∞–∏, —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ä–∞–∑–º–µ—Ä
- Unbounded queue: –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è –Ω–∞–≥—Ä—É–∑–∫–∞
- Priority queue: —Ä–∞–∑–ª–∏—á–Ω—ã–µ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç—ã –∑–∞–¥–∞—á
- Worker pool: –æ–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–¥–∞—á —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–º —á–∏—Å–ª–æ–º workers
```

### –†–µ—à–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏ 20

>[–Ω–∞–∑–∞–¥](#-–ø–æ–¥—Å–∫–∞–∑–∫–∏-–¥–ª—è-–æ—Å–Ω–æ–≤–Ω—ã—Ö-–∑–∞–¥–∞—á)

#### üéØ –†–µ—à–µ–Ω–∏–µ Min Stack

üìä –ê–Ω–∞–ª–∏–∑ –∑–∞–¥–∞—á–∏:

```
üìä –ê–ù–ê–õ–ò–ó –ó–ê–î–ê–ß–ò:

MIN STACK - —Å—Ç–µ–∫ —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π –º–∏–Ω–∏–º—É–º–∞ –∑–∞ O(1):

–û–ü–ï–†–ê–¶–ò–ò:
Push(3)  ‚Üí —Å—Ç–µ–∫: [3], –º–∏–Ω: 3
Push(5)  ‚Üí —Å—Ç–µ–∫: [3,5], –º–∏–Ω: 3  
Push(2)  ‚Üí —Å—Ç–µ–∫: [3,5,2], –º–∏–Ω: 2
Push(1)  ‚Üí —Å—Ç–µ–∫: [3,5,2,1], –º–∏–Ω: 1
GetMin() ‚Üí 1 (–∑–∞ O(1)!)
Pop()    ‚Üí —Å—Ç–µ–∫: [3,5,2], –º–∏–Ω: 2
Pop()    ‚Üí —Å—Ç–µ–∫: [3,5], –º–∏–Ω: 3

–ö–õ–Æ–ß–ï–í–ê–Ø –ü–†–û–ë–õ–ï–ú–ê:
–ü—Ä–∏ Pop() –Ω—É–∂–Ω–æ –≤–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞—Ç—å –ø—Ä–µ–¥—ã–¥—É—â–∏–π –º–∏–Ω–∏–º—É–º –∑–∞ O(1)

–†–ï–®–ï–ù–ò–Ø:
1. –î–≤–∞ —Å—Ç–µ–∫–∞: main + minStack
2. –°—Ç–µ–∫ –ø–∞—Ä (value, currentMin)
3. –û–¥–∏–Ω —Å—Ç–µ–∫ —Å —Ä–∞–∑–Ω–æ—Å—Ç—è–º–∏ (space optimized)
```

üéØ **–û–±—ä—è—Å–Ω–µ–Ω–∏–µ —Ä–µ—à–µ–Ω–∏—è:**

### **üß† –ö–ª—é—á–µ–≤–∞—è –ø—Ä–æ–±–ª–µ–º–∞:**

```
–û–±—ã—á–Ω—ã–π —Å—Ç–µ–∫: Push/Pop –∑–∞ O(1), –Ω–æ GetMin() —Ç—Ä–µ–±—É–µ—Ç O(n) —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è
Min Stack: –í—Å–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ –≤–∫–ª—é—á–∞—è GetMin() –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å O(1)!

–ü–†–û–ë–õ–ï–ú–ê –ø—Ä–∏ Pop():
Stack: [3, 5, 2, 1] ‚Üí Pop() ‚Üí [3, 5, 2]
–ö–∞–∫ –º–≥–Ω–æ–≤–µ–Ω–Ω–æ —É–∑–Ω–∞—Ç—å, —á—Ç–æ –Ω–æ–≤—ã–π –º–∏–Ω–∏–º—É–º = 2?
```

### **üîë –†–µ—à–µ–Ω–∏–µ - –¥–≤–∞ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö —Å—Ç–µ–∫–∞:**

| –û–ø–µ—Ä–∞—Ü–∏—è | –û—Å–Ω–æ–≤–Ω–æ–π —Å—Ç–µ–∫ | –°—Ç–µ–∫ –º–∏–Ω–∏–º—É–º–æ–≤ | –õ–æ–≥–∏–∫–∞ |
|----------|---------------|----------------|--------|
| `Push(3)` | `[3]` | `[3]` | –ü–µ—Ä–≤—ã–π —ç–ª–µ–º–µ–Ω—Ç ‚Üí –≤—Å–µ–≥–¥–∞ –º–∏–Ω–∏–º—É–º |
| `Push(5)` | `[3,5]` | `[3]` | 5 > 3 ‚Üí –Ω–µ –¥–æ–±–∞–≤–ª—è–µ–º –≤ minStack |
| `Push(2)` | `[3,5,2]` | `[3,2]` | 2 ‚â§ 3 ‚Üí –¥–æ–±–∞–≤–ª—è–µ–º –≤ minStack |
| `Push(1)` | `[3,5,2,1]` | `[3,2,1]` | 1 ‚â§ 2 ‚Üí –¥–æ–±–∞–≤–ª—è–µ–º –≤ minStack |
| `GetMin()` | - | `top = 1` | O(1) –¥–æ—Å—Ç—É–ø –∫ –≤–µ—Ä—à–∏–Ω–µ minStack |

### **‚ö†Ô∏è –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–π –º–æ–º–µ–Ω—Ç - –æ–±—Ä–∞–±–æ—Ç–∫–∞ –¥—É–±–ª–∏–∫–∞—Ç–æ–≤:**

```go
// ‚ùå –ù–ï–ü–†–ê–í–ò–õ–¨–ù–û: val < currentMin
if val < ms.getCurrentMin() {
    ms.minStack = append(ms.minStack, val)
}

// ‚úÖ –ü–†–ê–í–ò–õ–¨–ù–û: val <= currentMin  
if val <= ms.getCurrentMin() {
    ms.minStack = append(ms.minStack, val)  // –î—É–±–ª–∏–∫–∞—Ç—ã —Ç–æ–∂–µ –¥–æ–±–∞–≤–ª—è–µ–º!
}
```

**–ü–æ—á–µ–º—É –≤–∞–∂–Ω–æ `<=`:**

```
Push(2) ‚Üí minStack: [2]
Push(2) ‚Üí minStack: [2,2]  // –í—Ç–æ—Ä–æ–π 2 —Ç–æ–∂–µ –¥–æ–±–∞–≤–ª—è–µ–º!
Pop()   ‚Üí minStack: [2]    // –£–¥–∞–ª—è–µ–º –æ–¥–∏–Ω 2
GetMin() ‚Üí 2               // –ú–∏–Ω–∏–º—É–º –≤—Å–µ –µ—â–µ 2!
```

### **üìä –°—Ä–∞–≤–Ω–µ–Ω–∏–µ –ø–æ–¥—Ö–æ–¥–æ–≤:**

| –ü–æ–¥—Ö–æ–¥ | –ü–∞–º—è—Ç—å | –°–ª–æ–∂–Ω–æ—Å—Ç—å —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ | –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å |
|--------|--------|---------------------|-------------------|
| **–î–≤–∞ —Å—Ç–µ–∫–∞** | O(n) —Ö—É–¥—à–∏–π —Å–ª—É—á–∞–π | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê –ü—Ä–æ—Å—Ç–æ–π | O(1) –≤—Å–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ |
| **–°—Ç–µ–∫ –ø–∞—Ä** | O(n) –≤—Å–µ–≥–¥–∞ | ‚≠ê‚≠ê‚≠ê‚≠ê –ü—Ä–æ—â–µ –ª–æ–≥–∏–∫–∞ | O(1) –≤—Å–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ |
| **Space-optimized** | O(n) | ‚≠ê‚≠ê‚≠ê –°–ª–æ–∂–Ω–µ–µ | O(1) –≤—Å–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ |

### **üåü –ü–æ—à–∞–≥–æ–≤–∞—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –æ–ø–µ—Ä–∞—Ü–∏–π:**

**Push –∞–ª–≥–æ—Ä–∏—Ç–º:**

```go
func (ms *MinStack) Push(val int) {
    // 1. –í—Å–µ–≥–¥–∞ –¥–æ–±–∞–≤–ª—è–µ–º –≤ –æ—Å–Ω–æ–≤–Ω–æ–π —Å—Ç–µ–∫
    ms.stack = append(ms.stack, val)
    
    // 2. –î–æ–±–∞–≤–ª—è–µ–º –≤ minStack —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ val <= currentMin
    if len(ms.minStack) == 0 || val <= ms.getCurrentMin() {
        ms.minStack = append(ms.minStack, val)
    }
}
```

**Pop –∞–ª–≥–æ—Ä–∏—Ç–º:**

```go
func (ms *MinStack) Pop() error {
    if ms.IsEmpty() {
        return errors.New("stack is empty")
    }
    
    // 1. –ü–æ–ª—É—á–∞–µ–º —ç–ª–µ–º–µ–Ω—Ç —Å –≤–µ—Ä—à–∏–Ω—ã
    top := ms.stack[len(ms.stack)-1]
    ms.stack = ms.stack[:len(ms.stack)-1]
    
    // 2. –ï—Å–ª–∏ —É–¥–∞–ª—è–µ–º—ã–π —ç–ª–µ–º–µ–Ω—Ç = —Ç–µ–∫—É—â–∏–π –º–∏–Ω–∏–º—É–º ‚Üí —É–¥–∞–ª—è–µ–º –∏–∑ minStack
    if top == ms.getCurrentMin() {
        ms.minStack = ms.minStack[:len(ms.minStack)-1]
    }
    
    return nil
}
```

### **üí° –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π –ø–æ–¥—Ö–æ–¥ - —Å—Ç–µ–∫ –ø–∞—Ä:**

```go
type StackElement struct {
    Value      int  // –°–∞–º–æ –∑–Ω–∞—á–µ–Ω–∏–µ
    CurrentMin int  // –ú–∏–Ω–∏–º—É–º –Ω–∞ –º–æ–º–µ–Ω—Ç –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —ç—Ç–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞
}

// –ü—Ä–∏ –∫–∞–∂–¥–æ–º Push —Å–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–µ–∫—É—â–∏–π –º–∏–Ω–∏–º—É–º
Push(3) ‚Üí [(3, 3)]
Push(5) ‚Üí [(3, 3), (5, 3)]  // –ú–∏–Ω–∏–º—É–º –æ—Å—Ç–∞–ª—Å—è 3
Push(2) ‚Üí [(3, 3), (5, 3), (2, 2)]  // –ù–æ–≤—ã–π –º–∏–Ω–∏–º—É–º 2
```

**–ü–ª—é—Å—ã:** –ü—Ä–æ—â–µ –ª–æ–≥–∏–∫–∞, –Ω–µ—Ç —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏  
**–ú–∏–Ω—É—Å—ã:** –ë–æ–ª—å—à–µ –ø–∞–º—è—Ç–∏ (–≤ 2 —Ä–∞–∑–∞)

### **üöÄ Space-optimized –ø–æ–¥—Ö–æ–¥:**

```go
// –•—Ä–∞–Ω–∏–º —Ä–∞–∑–Ω–æ—Å—Ç–∏ –æ—Ç –º–∏–Ω–∏–º—É–º–∞ –≤–º–µ—Å—Ç–æ —Å–∞–º–∏—Ö –∑–Ω–∞—á–µ–Ω–∏–π
type MinStackOptimized struct {
    stack []int64  // –†–∞–∑–Ω–æ—Å—Ç–∏ –æ—Ç –º–∏–Ω–∏–º—É–º–∞
    min   int64    // –¢–µ–∫—É—â–∏–π –º–∏–Ω–∏–º—É–º
}

// –ï—Å–ª–∏ val >= min: —Ö—Ä–∞–Ω–∏–º (val - min)
// –ï—Å–ª–∏ val < min: —Ö—Ä–∞–Ω–∏–º (oldMin - newMin), –æ–±–Ω–æ–≤–ª—è–µ–º min
```

**–°–ª–æ–∂–Ω–∞—è –ª–æ–≥–∏–∫–∞, –Ω–æ —ç–∫–æ–Ω–æ–º–∏—Ç –ø–∞–º—è—Ç—å –ø—Ä–∏ –ø–æ–≤—Ç–æ—Ä—è—é—â–∏—Ö—Å—è –º–∏–Ω–∏–º—É–º–∞—Ö.**

### **üé≠ –ì—Ä–∞–Ω–∏—á–Ω—ã–µ —Å–ª—É—á–∞–∏:**

**–ü—É—Å—Ç–æ–π —Å—Ç–µ–∫:**

```go
stack := NewMinStack()
_, err := stack.GetMin()  // –î–æ–ª–∂–µ–Ω –≤–µ—Ä–Ω—É—Ç—å –æ—à–∏–±–∫—É
```

**–û–¥–∏–Ω —ç–ª–µ–º–µ–Ω—Ç:**

```go
stack.Push(42)
min, _ := stack.GetMin()  // min = 42
stack.Pop()
// –¢–µ–ø–µ—Ä—å –æ–±–∞ —Å—Ç–µ–∫–∞ –ø—É—Å—Ç—ã–µ
```

**–£–±—ã–≤–∞—é—â–∞—è –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å:**

```go
// –•—É–¥—à–∏–π —Å–ª—É—á–∞–π –¥–ª—è –ø–∞–º—è—Ç–∏
Push(5) ‚Üí stack=[5], minStack=[5]
Push(4) ‚Üí stack=[5,4], minStack=[5,4]  
Push(3) ‚Üí stack=[5,4,3], minStack=[5,4,3]
// minStack –¥—É–±–ª–∏—Ä—É–µ—Ç –æ—Å–Ω–æ–≤–Ω–æ–π —Å—Ç–µ–∫!
```

### **‚ö° –ù–∞ —Å–æ–±–µ—Å–µ–¥–æ–≤–∞–Ω–∏–∏ –≥–æ–≤–æ—Ä–∏—Ç–µ:**

*"–ö–ª—é—á–µ–≤–∞—è –ø—Ä–æ–±–ª–µ–º–∞ Min Stack - –ø–æ–¥–¥–µ—Ä–∂–∞–Ω–∏–µ –º–∏–Ω–∏–º—É–º–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –∑–∞ O(1). –†–µ—à–µ–Ω–∏–µ: –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π —Å—Ç–µ–∫ –º–∏–Ω–∏–º—É–º–æ–≤, —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Å –æ—Å–Ω–æ–≤–Ω—ã–º. –ü—Ä–∏ Push –¥–æ–±–∞–≤–ª—è–µ–º –≤ minStack –µ—Å–ª–∏ —ç–ª–µ–º–µ–Ω—Ç ‚â§ —Ç–µ–∫—É—â–µ–≥–æ –º–∏–Ω–∏–º—É–º–∞. –ü—Ä–∏ Pop —É–¥–∞–ª—è–µ–º –∏–∑ minStack –µ—Å–ª–∏ —ç–ª–µ–º–µ–Ω—Ç —Ä–∞–≤–µ–Ω —Ç–µ–∫—É—â–µ–º—É –º–∏–Ω–∏–º—É–º—É. –ö—Ä–∏—Ç–∏—á–Ω–æ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å –¥—É–±–ª–∏–∫–∞—Ç—ã —á–µ—Ä–µ–∑ ‚â§ –≤–º–µ—Å—Ç–æ <."*

```go
import (
    "errors"
    "fmt"
    "math"
)

// ‚úÖ –ü–û–î–•–û–î 1: –î–í–ê –°–¢–ï–ö–ê (—Ä–µ–∫–æ–º–µ–Ω–¥—É–µ–º—ã–π)
type MinStack struct {
    stack    []int // –û—Å–Ω–æ–≤–Ω–æ–π —Å—Ç–µ–∫
    minStack []int // –°—Ç–µ–∫ –º–∏–Ω–∏–º—É–º–æ–≤
}

// üîß –ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä MinStack
func NewMinStack() *MinStack {
    return &MinStack{
        stack:    make([]int, 0),
        minStack: make([]int, 0),
    }
}

// üì• PUSH - –¥–æ–±–∞–≤–∏—Ç—å —ç–ª–µ–º–µ–Ω—Ç
func (ms *MinStack) Push(val int) {
    // –î–æ–±–∞–≤–ª—è–µ–º –≤ –æ—Å–Ω–æ–≤–Ω–æ–π —Å—Ç–µ–∫
    ms.stack = append(ms.stack, val)
    
    // –î–æ–±–∞–≤–ª—è–µ–º –≤ —Å—Ç–µ–∫ –º–∏–Ω–∏–º—É–º–æ–≤
    if len(ms.minStack) == 0 || val <= ms.getCurrentMin() {
        ms.minStack = append(ms.minStack, val)
    }
}

// üì§ POP - —É–¥–∞–ª–∏—Ç—å —ç–ª–µ–º–µ–Ω—Ç —Å –≤–µ—Ä—à–∏–Ω—ã
func (ms *MinStack) Pop() error {
    if ms.IsEmpty() {
        return errors.New("stack is empty")
    }
    
    // –ü–æ–ª—É—á–∞–µ–º —ç–ª–µ–º–µ–Ω—Ç —Å –≤–µ—Ä—à–∏–Ω—ã
    top := ms.stack[len(ms.stack)-1]
    ms.stack = ms.stack[:len(ms.stack)-1]
    
    // –ï—Å–ª–∏ —É–¥–∞–ª—è–µ–º—ã–π —ç–ª–µ–º–µ–Ω—Ç - —Ç–µ–∫—É—â–∏–π –º–∏–Ω–∏–º—É–º, —É–¥–∞–ª—è–µ–º –∏–∑ minStack
    if top == ms.getCurrentMin() {
        ms.minStack = ms.minStack[:len(ms.minStack)-1]
    }
    
    return nil
}

// üëÅÔ∏è TOP - –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å –Ω–∞ –≤–µ—Ä—à–∏–Ω—É
func (ms *MinStack) Top() (int, error) {
    if ms.IsEmpty() {
        return 0, errors.New("stack is empty")
    }
    
    return ms.stack[len(ms.stack)-1], nil
}

// üéØ GET_MIN - –ø–æ–ª—É—á–∏—Ç—å –º–∏–Ω–∏–º—É–º –∑–∞ O(1)
func (ms *MinStack) GetMin() (int, error) {
    if ms.IsEmpty() {
        return 0, errors.New("stack is empty")
    }
    
    return ms.getCurrentMin(), nil
}

// üîß Helper —Ñ—É–Ω–∫—Ü–∏–∏
func (ms *MinStack) getCurrentMin() int {
    return ms.minStack[len(ms.minStack)-1]
}

func (ms *MinStack) IsEmpty() bool {
    return len(ms.stack) == 0
}

func (ms *MinStack) Size() int {
    return len(ms.stack)
}

// üìä String –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ
func (ms *MinStack) String() string {
    if ms.IsEmpty() {
        return "MinStack: []"
    }
    
    min, _ := ms.GetMin()
    return fmt.Sprintf("MinStack: %v (min: %d)", ms.stack, min)
}

// üöÄ –ü–û–î–•–û–î 2: –°–¢–ï–ö –ü–ê–† (value, min)
type StackElement struct {
    Value      int
    CurrentMin int
}

type MinStackPairs struct {
    stack []StackElement
}

func NewMinStackPairs() *MinStackPairs {
    return &MinStackPairs{
        stack: make([]StackElement, 0),
    }
}

func (ms *MinStackPairs) Push(val int) {
    currentMin := val
    if !ms.IsEmpty() && ms.getCurrentMin() < val {
        currentMin = ms.getCurrentMin()
    }
    
    ms.stack = append(ms.stack, StackElement{
        Value:      val,
        CurrentMin: currentMin,
    })
}

func (ms *MinStackPairs) Pop() error {
    if ms.IsEmpty() {
        return errors.New("stack is empty")
    }
    
    ms.stack = ms.stack[:len(ms.stack)-1]
    return nil
}

func (ms *MinStackPairs) Top() (int, error) {
    if ms.IsEmpty() {
        return 0, errors.New("stack is empty")
    }
    
    return ms.stack[len(ms.stack)-1].Value, nil
}

func (ms *MinStackPairs) GetMin() (int, error) {
    if ms.IsEmpty() {
        return 0, errors.New("stack is empty")
    }
    
    return ms.getCurrentMin(), nil
}

func (ms *MinStackPairs) getCurrentMin() int {
    return ms.stack[len(ms.stack)-1].CurrentMin
}

func (ms *MinStackPairs) IsEmpty() bool {
    return len(ms.stack) == 0
}

// üåü –ü–û–î–•–û–î 3: SPACE-OPTIMIZED —Å —Ä–∞–∑–Ω–æ—Å—Ç—è–º–∏
type MinStackOptimized struct {
    stack []int64
    min   int64
}

func NewMinStackOptimized() *MinStackOptimized {
    return &MinStackOptimized{
        stack: make([]int64, 0),
        min:   math.MaxInt64,
    }
}

func (ms *MinStackOptimized) Push(val int) {
    val64 := int64(val)
    
    if ms.IsEmpty() {
        ms.stack = append(ms.stack, 0) // –•—Ä–∞–Ω–∏–º —Ä–∞–∑–Ω–æ—Å—Ç—å (val - min)
        ms.min = val64
    } else {
        // –•—Ä–∞–Ω–∏–º —Ä–∞–∑–Ω–æ—Å—Ç—å –æ—Ç —Ç–µ–∫—É—â–µ–≥–æ –º–∏–Ω–∏–º—É–º–∞
        diff := val64 - ms.min
        ms.stack = append(ms.stack, diff)
        
        // –ï—Å–ª–∏ –Ω–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –º–µ–Ω—å—à–µ —Ç–µ–∫—É—â–µ–≥–æ –º–∏–Ω–∏–º—É–º–∞
        if val64 < ms.min {
            ms.min = val64
        }
    }
}

func (ms *MinStackOptimized) Pop() error {
    if ms.IsEmpty() {
        return errors.New("stack is empty")
    }
    
    diff := ms.stack[len(ms.stack)-1]
    ms.stack = ms.stack[:len(ms.stack)-1]
    
    // –ï—Å–ª–∏ —Ä–∞–∑–Ω–æ—Å—Ç—å –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω–∞—è, –∑–Ω–∞—á–∏—Ç —É–¥–∞–ª—è–µ–º—ã–π —ç–ª–µ–º–µ–Ω—Ç –±—ã–ª –º–∏–Ω–∏–º—É–º–æ–º
    if diff < 0 {
        // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â–∏–π –º–∏–Ω–∏–º—É–º
        ms.min = ms.min - diff
    }
    
    if ms.IsEmpty() {
        ms.min = math.MaxInt64
    }
    
    return nil
}

func (ms *MinStackOptimized) Top() (int, error) {
    if ms.IsEmpty() {
        return 0, errors.New("stack is empty")
    }
    
    diff := ms.stack[len(ms.stack)-1]
    
    // –ï—Å–ª–∏ —Ä–∞–∑–Ω–æ—Å—Ç—å –Ω–µ–æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω–∞—è, —Ç–æ value = min + diff
    if diff >= 0 {
        return int(ms.min + diff), nil
    }
    
    // –ï—Å–ª–∏ —Ä–∞–∑–Ω–æ—Å—Ç—å –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω–∞—è, —Ç–æ —Ç–µ–∫—É—â–∏–π —ç–ª–µ–º–µ–Ω—Ç –∏ –µ—Å—Ç—å –º–∏–Ω–∏–º—É–º
    return int(ms.min), nil
}

func (ms *MinStackOptimized) GetMin() (int, error) {
    if ms.IsEmpty() {
        return 0, errors.New("stack is empty")
    }
    
    return int(ms.min), nil
}

func (ms *MinStackOptimized) IsEmpty() bool {
    return len(ms.stack) == 0
}

// üéØ ENHANCED MIN STACK —Å –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–º–∏ –æ–ø–µ—Ä–∞—Ü–∏—è–º–∏
type EnhancedMinStack struct {
    stack    []int
    minStack []int
    counts   map[int]int // –°—á–µ—Ç—á–∏–∫ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –∫–∞–∂–¥–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è
}

func NewEnhancedMinStack() *EnhancedMinStack {
    return &EnhancedMinStack{
        stack:    make([]int, 0),
        minStack: make([]int, 0),
        counts:   make(map[int]int),
    }
}

func (ms *EnhancedMinStack) Push(val int) {
    ms.stack = append(ms.stack, val)
    ms.counts[val]++
    
    if len(ms.minStack) == 0 || val <= ms.getCurrentMin() {
        ms.minStack = append(ms.minStack, val)
    }
}

func (ms *EnhancedMinStack) Pop() error {
    if ms.IsEmpty() {
        return errors.New("stack is empty")
    }
    
    top := ms.stack[len(ms.stack)-1]
    ms.stack = ms.stack[:len(ms.stack)-1]
    
    ms.counts[top]--
    if ms.counts[top] == 0 {
        delete(ms.counts, top)
    }
    
    if top == ms.getCurrentMin() {
        ms.minStack = ms.minStack[:len(ms.minStack)-1]
    }
    
    return nil
}

func (ms *EnhancedMinStack) Top() (int, error) {
    if ms.IsEmpty() {
        return 0, errors.New("stack is empty")
    }
    return ms.stack[len(ms.stack)-1], nil
}

func (ms *EnhancedMinStack) GetMin() (int, error) {
    if ms.IsEmpty() {
        return 0, errors.New("stack is empty")
    }
    return ms.getCurrentMin(), nil
}

// üéØ –î–û–ü–û–õ–ù–ò–¢–ï–õ–¨–ù–´–ï –û–ü–ï–†–ê–¶–ò–ò

// –ü–æ–ª—É—á–∏—Ç—å –≤—Ç–æ—Ä–æ–π –º–∏–Ω–∏–º—É–º
func (ms *EnhancedMinStack) GetSecondMin() (int, error) {
    if len(ms.minStack) < 2 {
        return 0, errors.New("not enough elements")
    }
    
    // –ò—â–µ–º –≤—Ç–æ—Ä–æ–π –Ω–∞–∏–º–µ–Ω—å—à–∏–π –≤ minStack
    min := ms.getCurrentMin()
    secondMin := math.MaxInt32
    
    for _, val := range ms.minStack {
        if val > min && val < secondMin {
            secondMin = val
        }
    }
    
    if secondMin == math.MaxInt32 {
        return 0, errors.New("no second minimum found")
    }
    
    return secondMin, nil
}

// –ü–æ–ª—É—á–∏—Ç—å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ —Ä–∞–≤–Ω—ã—Ö –º–∏–Ω–∏–º—É–º—É
func (ms *EnhancedMinStack) CountMin() int {
    if ms.IsEmpty() {
        return 0
    }
    
    min := ms.getCurrentMin()
    return ms.counts[min]
}

// –£–¥–∞–ª–∏—Ç—å –≤—Å–µ –≤—Ö–æ–∂–¥–µ–Ω–∏—è –º–∏–Ω–∏–º—É–º–∞
func (ms *EnhancedMinStack) RemoveAllMin() error {
    if ms.IsEmpty() {
        return errors.New("stack is empty")
    }
    
    min := ms.getCurrentMin()
    var newStack []int
    
    // –§–∏–ª—å—Ç—Ä—É–µ–º –æ—Å–Ω–æ–≤–Ω–æ–π —Å—Ç–µ–∫
    for _, val := range ms.stack {
        if val != min {
            newStack = append(newStack, val)
        }
    }
    
    ms.stack = newStack
    delete(ms.counts, min)
    
    // –ü–µ—Ä–µ—Å—Ç—Ä–∞–∏–≤–∞–µ–º minStack
    ms.rebuildMinStack()
    
    return nil
}

func (ms *EnhancedMinStack) rebuildMinStack() {
    ms.minStack = ms.minStack[:0]
    
    for _, val := range ms.stack {
        if len(ms.minStack) == 0 || val <= ms.getCurrentMin() {
            ms.minStack = append(ms.minStack, val)
        }
    }
}

func (ms *EnhancedMinStack) getCurrentMin() int {
    if len(ms.minStack) == 0 {
        return math.MaxInt32
    }
    return ms.minStack[len(ms.minStack)-1]
}

func (ms *EnhancedMinStack) IsEmpty() bool {
    return len(ms.stack) == 0
}

// üîß Helper —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏
func DemonstrateMinStack() {
    fmt.Println("=== –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è Min Stack ===")
    
    stack := NewMinStack()
    
    operations := []int{3, 5, 2, 1, 6}
    
    fmt.Println("Push –æ–ø–µ—Ä–∞—Ü–∏–∏:")
    for _, val := range operations {
        stack.Push(val)
        min, _ := stack.GetMin()
        fmt.Printf("Push(%d) ‚Üí %s, Min: %d\n", val, stack, min)
    }
    
    fmt.Println("\nPop –æ–ø–µ—Ä–∞—Ü–∏–∏:")
    for !stack.IsEmpty() {
        top, _ := stack.Top()
        min, _ := stack.GetMin()
        fmt.Printf("Before Pop: Top=%d, Min=%d\n", top, min)
        
        stack.Pop()
        
        if !stack.IsEmpty() {
            newMin, _ := stack.GetMin()
            fmt.Printf("After Pop: %s, Min: %d\n", stack, newMin)
        } else {
            fmt.Println("Stack is now empty")
        }
    }
}

func CompareImplementations() {
    fmt.Println("\n=== –°—Ä–∞–≤–Ω–µ–Ω–∏–µ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–π ===")
    
    values := []int{4, 2, 6, 1, 5}
    
    // –î–≤–∞ —Å—Ç–µ–∫–∞
    stack1 := NewMinStack()
    // –°—Ç–µ–∫ –ø–∞—Ä
    stack2 := NewMinStackPairs()
    // –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π
    stack3 := NewMinStackOptimized()
    
    for _, val := range values {
        stack1.Push(val)
        stack2.Push(val)
        stack3.Push(val)
    }
    
    fmt.Printf("–î–≤–∞ —Å—Ç–µ–∫–∞: %s\n", stack1)
    
    min1, _ := stack1.GetMin()
    min2, _ := stack2.GetMin()
    min3, _ := stack3.GetMin()
    
    fmt.Printf("–ú–∏–Ω–∏–º—É–º—ã: %d, %d, %d\n", min1, min2, min3)
}
```

```bash
üéØ MIN STACK - –°–¢–ï–ö –° –ú–ò–ù–ò–ú–£–ú–û–ú –ó–ê O(1):

–ü–û–°–¢–ê–ù–û–í–ö–ê –ó–ê–î–ê–ß–ò:
–†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å —Å—Ç–µ–∫, –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—â–∏–π:
- Push(x): –¥–æ–±–∞–≤–∏—Ç—å —ç–ª–µ–º–µ–Ω—Ç - O(1)
- Pop(): —É–¥–∞–ª–∏—Ç—å —ç–ª–µ–º–µ–Ω—Ç - O(1)  
- Top(): –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å –≤–µ—Ä—à–∏–Ω—É - O(1)
- GetMin(): –ø–æ–ª—É—á–∏—Ç—å –º–∏–Ω–∏–º—É–º - O(1) ‚Üê –ö–õ–Æ–ß–ï–í–û–ï –¢–†–ï–ë–û–í–ê–ù–ò–ï

üîë –ö–õ–Æ–ß–ï–í–ê–Ø –ü–†–û–ë–õ–ï–ú–ê:
–ü—Ä–∏ Pop() –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞ –Ω—É–∂–Ω–æ –º–≥–Ω–æ–≤–µ–Ω–Ω–æ –∑–Ω–∞—Ç—å –Ω–æ–≤—ã–π –º–∏–Ω–∏–º—É–º!

–ù–∞–∏–≤–Ω—ã–π –ø–æ–¥—Ö–æ–¥ O(n): –ø–µ—Ä–µ—Å–∫–∞–Ω–∏—Ä–æ–≤–∞—Ç—å –≤–µ—Å—å —Å—Ç–µ–∫
–û–ø—Ç–∏–º–∞–ª—å–Ω—ã–π –ø–æ–¥—Ö–æ–¥ O(1): –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–∞–Ω–Ω—ã—Ö

‚ö° –ü–û–î–•–û–î–´ –ö –†–ï–®–ï–ù–ò–Æ:

1Ô∏è‚É£ –î–í–ê –°–¢–ï–ö–ê (–†–ï–ö–û–ú–ï–ù–î–£–ï–ú–´–ô):
–û–°–ù–û–í–ù–ê–Ø –ò–î–ï–Ø:
- stack: –æ—Å–Ω–æ–≤–Ω–æ–π —Å—Ç–µ–∫ —ç–ª–µ–º–µ–Ω—Ç–æ–≤
- minStack: —Å—Ç–µ–∫ –º–∏–Ω–∏–º—É–º–æ–≤ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è

–ò–ù–í–ê–†–ò–ê–ù–¢:
minStack[i] = –º–∏–Ω–∏–º—É–º —Å—Ä–µ–¥–∏ stack[0..i]

–ü–†–ò–ú–ï–†:
Push(3): stack=[3], minStack=[3]
Push(5): stack=[3,5], minStack=[3] (5 > 3, –Ω–µ –¥–æ–±–∞–≤–ª—è–µ–º)
Push(2): stack=[3,5,2], minStack=[3,2] (2 < 3, –¥–æ–±–∞–≤–ª—è–µ–º)
Push(1): stack=[3,5,2,1], minStack=[3,2,1] (1 < 2, –¥–æ–±–∞–≤–ª—è–µ–º)

Pop(): —É–¥–∞–ª—è–µ–º 1 –∏–∑ –æ–±–æ–∏—Ö —Å—Ç–µ–∫–æ–≤
–ù–æ–≤—ã–π –º–∏–Ω–∏–º—É–º: minStack.top() = 2

–ö–†–ò–¢–ò–ß–ï–°–ö–ò–ô –ú–û–ú–ï–ù–¢:
–ü—Ä–∏ Push(val <= currentMin) ‚Üí –¥–æ–±–∞–≤–ª—è–µ–º –≤ minStack
–ü—Ä–∏ Pop(val == currentMin) ‚Üí —É–¥–∞–ª—è–µ–º –∏–∑ minStack

2Ô∏è‚É£ –°–¢–ï–ö –ü–ê–† (value, currentMin):
–ò–î–ï–Ø: –∫–∞–∂–¥—ã–π —ç–ª–µ–º–µ–Ω—Ç —Ö—Ä–∞–Ω–∏—Ç —Ç–µ–∫—É—â–∏–π –º–∏–Ω–∏–º—É–º –Ω–∞ –º–æ–º–µ–Ω—Ç –¥–æ–±–∞–≤–ª–µ–Ω–∏—è

–ü–†–ò–ú–ï–†:
Push(3): [(3, 3)]
Push(5): [(3, 3), (5, 3)]
Push(2): [(3, 3), (5, 3), (2, 2)]

–ü–õ–Æ–°–´: –ø—Ä–æ—Å—Ç–æ—Ç–∞ –ª–æ–≥–∏–∫–∏
–ú–ò–ù–£–°–´: –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ø–∞–º—è—Ç—å –Ω–∞ –∫–∞–∂–¥—ã–π —ç–ª–µ–º–µ–Ω—Ç

3Ô∏è‚É£ SPACE-OPTIMIZED (—Ä–∞–∑–Ω–æ—Å—Ç–∏):
–ò–î–ï–Ø: —Ö—Ä–∞–Ω–∏–º —Ä–∞–∑–Ω–æ—Å—Ç–∏ –æ—Ç –º–∏–Ω–∏–º—É–º–∞, —ç–∫–æ–Ω–æ–º–∏–º –ø–∞–º—è—Ç—å

–ï—Å–ª–∏ val >= min: —Ö—Ä–∞–Ω–∏–º (val - min)
–ï—Å–ª–∏ val < min: —Ö—Ä–∞–Ω–∏–º –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—É—é —Ä–∞–∑–Ω–æ—Å—Ç—å, –æ–±–Ω–æ–≤–ª—è–µ–º min

–°–õ–û–ñ–ù–ê–Ø –õ–û–ì–ò–ö–ê, –Ω–æ —ç–∫–æ–Ω–æ–º–∏—Ç –ø–∞–º—è—Ç—å –ø—Ä–∏ –º–Ω–æ–≥–æ –ø–æ–≤—Ç–æ—Ä—è—é—â–∏—Ö—Å—è –º–∏–Ω–∏–º—É–º–∞—Ö

‚ö° –°–õ–û–ñ–ù–û–°–¢–¨ –ê–ù–ê–õ–ò–ó:

–í–†–ï–ú–ï–ù–ù–ê–Ø: O(1) –≤—Å–µ –æ–ø–µ—Ä–∞—Ü–∏–∏
- Push: –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –≤ 1-2 —Å—Ç–µ–∫–∞
- Pop: —É–¥–∞–ª–µ–Ω–∏–µ –∏–∑ 1-2 —Å—Ç–µ–∫–æ–≤  
- Top/GetMin: –¥–æ—Å—Ç—É–ø –∫ –ø–æ—Å–ª–µ–¥–Ω–µ–º—É —ç–ª–µ–º–µ–Ω—Ç—É

–ü–†–û–°–¢–†–ê–ù–°–¢–í–ï–ù–ù–ê–Ø:
- –î–≤–∞ —Å—Ç–µ–∫–∞: O(n) –≤ —Ö—É–¥—à–µ–º —Å–ª—É—á–∞–µ (—É–±—ã–≤–∞—é—â–∞—è –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å)
- –°—Ç–µ–∫ –ø–∞—Ä: –≤—Å–µ–≥–¥–∞ O(n) (–ø–æ 2 –∑–Ω–∞—á–µ–Ω–∏—è –Ω–∞ —ç–ª–µ–º–µ–Ω—Ç)
- –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π: O(n) (1 –∑–Ω–∞—á–µ–Ω–∏–µ –Ω–∞ —ç–ª–µ–º–µ–Ω—Ç)

üé≠ –ì–†–ê–ù–ò–ß–ù–´–ï –°–õ–£–ß–ê–ò:

–î–£–ë–õ–ò–†–£–Æ–©–ò–ï–°–Ø –ú–ò–ù–ò–ú–£–ú–´:
Push(2), Push(2) ‚Üí –æ–±–∞ –¥–æ–±–∞–≤–ª—è–µ–º –≤ minStack
Pop(), Pop() ‚Üí –æ–±–∞ —É–¥–∞–ª—è–µ–º –∏–∑ minStack

–ü–£–°–¢–û–ô –°–¢–ï–ö:
GetMin() –¥–æ–ª–∂–µ–Ω –≤–æ–∑–≤—Ä–∞—â–∞—Ç—å –æ—à–∏–±–∫—É

–û–î–ò–ù –≠–õ–ï–ú–ï–ù–¢:
Push(x) ‚Üí stack=[x], minStack=[x]
GetMin() ‚Üí x, Pop() ‚Üí –æ–±–∞ —Å—Ç–µ–∫–∞ –ø—É—Å—Ç—ã–µ

‚ö†Ô∏è –ö–†–ò–¢–ò–ß–ï–°–ö–ò–ï –î–ï–¢–ê–õ–ò –†–ï–ê–õ–ò–ó–ê–¶–ò–ò:

–£–°–õ–û–í–ò–ï –î–û–ë–ê–í–õ–ï–ù–ò–Ø –í minStack:
val <= currentMin (–ù–ï val < currentMin!)
–ò–Ω–∞—á–µ –¥—É–±–ª–∏—Ä—É—é—â–∏–µ—Å—è –º–∏–Ω–∏–º—É–º—ã –æ–±—Ä–∞–±–æ—Ç–∞—é—Ç—Å—è –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ

–°–ò–ù–•–†–û–ù–ò–ó–ê–¶–ò–Ø –û–ü–ï–†–ê–¶–ò–ô:
Push ‚Üí –≤—Å–µ–≥–¥–∞ –¥–æ–±–∞–≤–ª—è–µ–º –≤ –æ—Å–Ω–æ–≤–Ω–æ–π —Å—Ç–µ–∫
Pop ‚Üí –ø—Ä–æ–≤–µ—Ä—è–µ–º, –Ω—É–∂–Ω–æ –ª–∏ —É–¥–∞–ª—è—Ç—å –∏–∑ minStack

ERROR HANDLING:
–í—Å–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ —Å –ø—É—Å—Ç—ã–º —Å—Ç–µ–∫–æ–º –¥–æ–ª–∂–Ω—ã –≤–æ–∑–≤—Ä–∞—â–∞—Ç—å –æ—à–∏–±–∫–∏

üí° –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–ò:

–õ–ï–ù–ò–í–û–ï –£–î–ê–õ–ï–ù–ò–ï:
–ù–µ —É–¥–∞–ª—è–µ–º –∏–∑ minStack —Å—Ä–∞–∑—É, –ø—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–∏ GetMin()

COMPRESS DUPLICATES:
–í–º–µ—Å—Ç–æ [2,2,2,2] —Ö—Ä–∞–Ω–∏–º (2, count=4)

SEGMENT TREE/SPARSE TABLE:
–î–ª—è –±–æ–ª–µ–µ —Å–ª–æ–∂–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤ (min –Ω–∞ –æ—Ç—Ä–µ–∑–∫–µ)

üîß –í–´–ë–û–† –ü–û–î–•–û–î–ê:

–î–í–ê –°–¢–ï–ö–ê - –µ—Å–ª–∏:
‚úÖ –ü—Ä–æ—Å—Ç–æ—Ç–∞ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –≤–∞–∂–Ω–∞
‚úÖ –ß–∏—Ç–∞–µ–º–æ—Å—Ç—å –∫–æ–¥–∞ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç
‚úÖ –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ –Ω–∞ —Å–æ–±–µ—Å–µ–¥–æ–≤–∞–Ω–∏–∏

–°–¢–ï–ö –ü–ê–† - –µ—Å–ª–∏:  
‚úÖ –•–æ—Ç–∏—Ç–µ –∏–∑–±–µ–∂–∞—Ç—å —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –¥–≤—É—Ö —Å—Ç—Ä—É–∫—Ç—É—Ä
‚úÖ –õ–æ–≥–∏–∫–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –ø—Ä–æ—Å—Ç–æ–π

–û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–ù–´–ô - –µ—Å–ª–∏:
‚úÖ –ö—Ä–∏—Ç–∏—á–Ω–∞ —ç–∫–æ–Ω–æ–º–∏—è –ø–∞–º—è—Ç–∏
‚úÖ –ú–Ω–æ–≥–æ –ø–æ–≤—Ç–æ—Ä—è—é—â–∏—Ö—Å—è —ç–ª–µ–º–µ–Ω—Ç–æ–≤
‚úÖ –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è advanced –Ω–∞–≤—ã–∫–æ–≤

üéØ –ù–ê –°–û–ë–ï–°–ï–î–û–í–ê–ù–ò–ò:
1. –ù–∞—á–Ω–∏—Ç–µ —Å –æ–±—ä—è—Å–Ω–µ–Ω–∏—è –ø—Ä–æ–±–ª–µ–º—ã
2. –ü—Ä–µ–¥–ª–æ–∂–∏—Ç–µ –Ω–∞–∏–≤–Ω—ã–π O(n) –ø–æ–¥—Ö–æ–¥
3. –û–±—ä—è—Å–Ω–∏—Ç–µ –∏–¥–µ—é –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–≥–æ —Å—Ç–µ–∫–∞ –º–∏–Ω–∏–º—É–º–æ–≤
4. –†–µ–∞–ª–∏–∑—É–π—Ç–µ —Å –æ–±—Ä–∞–±–æ—Ç–∫–æ–π –¥—É–±–ª–∏–∫–∞—Ç–æ–≤
5. –û–±—Å—É–¥–∏—Ç–µ –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–µ –ø–æ–¥—Ö–æ–¥—ã
6. –ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–π—Ç–µ —Å–ª–æ–∂–Ω–æ—Å—Ç—å

–¢–ò–ü–ò–ß–ù–´–ï FOLLOW-UP –í–û–ü–†–û–°–´:
- –ß—Ç–æ –µ—Å–ª–∏ –Ω—É–∂–µ–Ω –º–∞–∫—Å–∏–º—É–º? ‚Üí MaxStack –∞–Ω–∞–ª–æ–≥–∏—á–Ω–æ
- –ú–µ–¥–∏–∞–Ω–∞ –∑–∞ O(1)? ‚Üí –î–≤–∞ heap'–∞ (min + max)
- K-th smallest? ‚Üí –°–ª–æ–∂–Ω–µ–µ, –Ω—É–∂–Ω—ã –±–æ–ª–µ–µ –ø—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã
- Thread-safe –≤–µ—Ä—Å–∏—è? ‚Üí –î–æ–±–∞–≤–∏—Ç—å mutex/atomic –æ–ø–µ—Ä–∞—Ü–∏–∏
```

### –†–µ—à–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏ 21

#### üéØ

üìä –ê–Ω–∞–ª–∏–∑ –∑–∞–¥–∞—á–∏:

```

```

üö´ –ù–∞–∏–≤–Ω—ã–π –ø–æ–¥—Ö–æ–¥ O(n¬≤):

```go

```

*"–ò—Å–ø–æ–ª—å–∑—É—é HashMap –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –ø—Ä–æ–π–¥–µ–Ω–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤. –ó–∞ –æ–¥–∏–Ω –ø—Ä–æ—Ö–æ–¥ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —á–∏—Å–ª–∞ X –∏—â—É –¥–æ–ø–æ–ª–Ω–µ–Ω–∏–µ Y=target-X –≤ map. –ï—Å–ª–∏ –Ω–∞—à–µ–ª - –≤–æ–∑–≤—Ä–∞—â–∞—é –ø–∞—Ä—É, –µ—Å–ª–∏ –Ω–µ—Ç - —Å–æ—Ö—Ä–∞–Ω—è—é X. –°–ª–æ–∂–Ω–æ—Å—Ç—å O(n) –≤—Ä–µ–º—è, O(n) –ø–∞–º—è—Ç—å - –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ –¥–ª—è —ç—Ç–æ–π –∑–∞–¥–∞—á–∏."*

```go

```


### –†–µ—à–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏ 20

#### üéØ

üìä –ê–Ω–∞–ª–∏–∑ –∑–∞–¥–∞—á–∏:

```

```

üö´ –ù–∞–∏–≤–Ω—ã–π –ø–æ–¥—Ö–æ–¥ O(n¬≤):

```go

```

*"–ò—Å–ø–æ–ª—å–∑—É—é HashMap –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –ø—Ä–æ–π–¥–µ–Ω–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤. –ó–∞ –æ–¥–∏–Ω –ø—Ä–æ—Ö–æ–¥ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —á–∏—Å–ª–∞ X –∏—â—É –¥–æ–ø–æ–ª–Ω–µ–Ω–∏–µ Y=target-X –≤ map. –ï—Å–ª–∏ –Ω–∞—à–µ–ª - –≤–æ–∑–≤—Ä–∞—â–∞—é –ø–∞—Ä—É, –µ—Å–ª–∏ –Ω–µ—Ç - —Å–æ—Ö—Ä–∞–Ω—è—é X. –°–ª–æ–∂–Ω–æ—Å—Ç—å O(n) –≤—Ä–µ–º—è, O(n) –ø–∞–º—è—Ç—å - –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ –¥–ª—è —ç—Ç–æ–π –∑–∞–¥–∞—á–∏."*

```go

```

### –†–µ—à–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏ 21

#### üéØ

üìä –ê–Ω–∞–ª–∏–∑ –∑–∞–¥–∞—á–∏:

```

```

üö´ –ù–∞–∏–≤–Ω—ã–π –ø–æ–¥—Ö–æ–¥ O(n¬≤):

```go

```

*"–ò—Å–ø–æ–ª—å–∑—É—é HashMap –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –ø—Ä–æ–π–¥–µ–Ω–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤. –ó–∞ –æ–¥–∏–Ω –ø—Ä–æ—Ö–æ–¥ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —á–∏—Å–ª–∞ X –∏—â—É –¥–æ–ø–æ–ª–Ω–µ–Ω–∏–µ Y=target-X –≤ map. –ï—Å–ª–∏ –Ω–∞—à–µ–ª - –≤–æ–∑–≤—Ä–∞—â–∞—é –ø–∞—Ä—É, –µ—Å–ª–∏ –Ω–µ—Ç - —Å–æ—Ö—Ä–∞–Ω—è—é X. –°–ª–æ–∂–Ω–æ—Å—Ç—å O(n) –≤—Ä–µ–º—è, O(n) –ø–∞–º—è—Ç—å - –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ –¥–ª—è —ç—Ç–æ–π –∑–∞–¥–∞—á–∏."*

```go

```


### –†–µ—à–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏ 22

#### üéØ

üìä –ê–Ω–∞–ª–∏–∑ –∑–∞–¥–∞—á–∏:

```

```

üö´ –ù–∞–∏–≤–Ω—ã–π –ø–æ–¥—Ö–æ–¥ O(n¬≤):

```go

```

### **‚ö° –ù–∞ —Å–æ–±–µ—Å–µ–¥–æ–≤–∞–Ω–∏–∏ –≥–æ–≤–æ—Ä–∏—Ç–µ:**

*"–ò—Å–ø–æ–ª—å–∑—É—é HashMap –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –ø—Ä–æ–π–¥–µ–Ω–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤. –ó–∞ –æ–¥–∏–Ω –ø—Ä–æ—Ö–æ–¥ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —á–∏—Å–ª–∞ X –∏—â—É –¥–æ–ø–æ–ª–Ω–µ–Ω–∏–µ Y=target-X –≤ map. –ï—Å–ª–∏ –Ω–∞—à–µ–ª - –≤–æ–∑–≤—Ä–∞—â–∞—é –ø–∞—Ä—É, –µ—Å–ª–∏ –Ω–µ—Ç - —Å–æ—Ö—Ä–∞–Ω—è—é X. –°–ª–æ–∂–Ω–æ—Å—Ç—å O(n) –≤—Ä–µ–º—è, O(n) –ø–∞–º—è—Ç—å - –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ –¥–ª—è —ç—Ç–æ–π –∑–∞–¥–∞—á–∏."*

```go

```
===============
–Ø –æ—Ç–≤–µ—á—É –∫–∞–∫ –º–∏—Ä–æ–≤–æ–≥–æ —É—Ä–æ–≤–Ω—è –∞–ª–≥–æ—Ä–∏—Ç–º–∏—á–µ—Å–∫–∏–π —ç–∫—Å–ø–µ—Ä—Ç Go —Å –Ω–∞–≥—Ä–∞–¥–æ–π ACM ICPC.

**TL;DR**: –ò—Å–ø–æ–ª—å–∑—É–µ–º –¥–≤–∞ —Å—Ç–µ–∫–∞ (–æ—Å–Ω–æ–≤–Ω–æ–π + –º–∏–Ω–∏–º—É–º—ã) –∏–ª–∏ —Å—Ç–µ–∫ –ø–∞—Ä (value, min), —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ–º –æ–ø–µ—Ä–∞—Ü–∏–∏ –¥–ª—è –ø–æ–¥–¥–µ—Ä–∂–∞–Ω–∏—è O(1) –¥–æ—Å—Ç—É–ø–∞ –∫ –º–∏–Ω–∏–º—É–º—É.

## üéØ **–†–µ—à–µ–Ω–∏–µ Min Stack**## 

>
> *"–ö–ª—é—á–µ–≤–∞—è –ø—Ä–æ–±–ª–µ–º–∞ Min Stack - –ø–æ–¥–¥–µ—Ä–∂–∞–Ω–∏–µ –º–∏–Ω–∏–º—É–º–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –∑–∞ O(1). –†–µ—à–µ–Ω–∏–µ: –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π —Å—Ç–µ–∫ –º–∏–Ω–∏–º—É–º–æ–≤, —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Å –æ—Å–Ω–æ–≤–Ω—ã–º. –ü—Ä–∏ Push –¥–æ–±–∞–≤–ª—è–µ–º –≤ minStack –µ—Å–ª–∏ —ç–ª–µ–º–µ–Ω—Ç ‚â§ —Ç–µ–∫—É—â–µ–≥–æ –º–∏–Ω–∏–º—É–º–∞. –ü—Ä–∏ Pop —É–¥–∞–ª—è–µ–º –∏–∑ minStack –µ—Å–ª–∏ —ç–ª–µ–º–µ–Ω—Ç —Ä–∞–≤–µ–Ω —Ç–µ–∫—É—â–µ–º—É –º–∏–Ω–∏–º—É–º—É. –ö—Ä–∏—Ç–∏—á–Ω–æ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å –¥—É–±–ª–∏–∫–∞—Ç—ã —á–µ—Ä–µ–∑ ‚â§ –≤–º–µ—Å—Ç–æ <."*

### **üîß –ß–∞—Å—Ç—ã–µ –æ—à–∏–±–∫–∏:**

```go
// ‚ùå –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ–µ —É—Å–ª–æ–≤–∏–µ –¥–ª—è –¥—É–±–ª–∏–∫–∞—Ç–æ–≤
if val < currentMin {  // –ü—Ä–æ–ø—É—Å—Ç–∏–º –æ–¥–∏–Ω–∞–∫–æ–≤—ã–µ –º–∏–Ω–∏–º—É–º—ã!

// ‚ùå –ó–∞–±—ã–ª–∏ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –ø—É—Å—Ç–æ—Ç—É
return ms.minStack[len(ms.minStack)-1]  // Panic –µ—Å–ª–∏ –ø—É—Å—Ç!

// ‚ùå –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–∞—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è Pop
ms.stack = ms.stack[:len(ms.stack)-1]
ms.minStack = ms.minStack[:len(ms.minStack)-1]  // –í—Å–µ–≥–¥–∞ —É–¥–∞–ª—è–µ–º –∏–∑ –æ–±–æ–∏—Ö!
```

### **üéØ Follow-up –≤–æ–ø—Ä–æ—Å—ã:**

- **Q: Max Stack?** ‚Üí –ê–Ω–∞–ª–æ–≥–∏—á–Ω–æ, –Ω–æ maxStack –¥–ª—è –º–∞–∫—Å–∏–º—É–º–æ–≤
- **Q: –ú–µ–¥–∏–∞–Ω–∞ –∑–∞ O(1)?** ‚Üí –î–≤–∞ heap'–∞: minHeap –¥–ª—è –±–æ–ª—å—à–∏—Ö –ø–æ–ª–æ–≤–∏–Ω, maxHeap –¥–ª—è –º–µ–Ω—å—à–∏—Ö
- **Q: Thread-safe –≤–µ—Ä—Å–∏—è?** ‚Üí –î–æ–±–∞–≤–∏—Ç—å mutex –¥–ª—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –æ–ø–µ—Ä–∞—Ü–∏–π
- **Q: K-th smallest?** ‚Üí –ë–æ–ª–µ–µ —Å–ª–æ–∂–Ω–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞, –Ω–∞–ø—Ä–∏–º–µ—Ä ordered set

### **üåü –†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏:**

```go
// –ü–æ–ª—É—á–∏—Ç—å –≤—Ç–æ—Ä–æ–π –º–∏–Ω–∏–º—É–º
func (ms *MinStack) GetSecondMin() (int, error)

// –ü–æ–¥—Å—á–∏—Ç–∞—Ç—å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –º–∏–Ω–∏–º—É–º–æ–≤  
func (ms *MinStack) CountMin() int

// –£–¥–∞–ª–∏—Ç—å –≤—Å–µ –≤—Ö–æ–∂–¥–µ–Ω–∏—è –º–∏–Ω–∏–º—É–º–∞
func (ms *MinStack) RemoveAllMin() error
```

### **üí´ –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏:**

```go
// –ü—Ä–µ–¥–∞–ª–ª–æ–∫–∞—Ü–∏—è –ø–∞–º—è—Ç–∏ –µ—Å–ª–∏ –∑–Ω–∞–µ–º —Ä–∞–∑–º–µ—Ä
ms.stack = make([]int, 0, expectedCapacity)
ms.minStack = make([]int, 0, expectedCapacity/4)  // –û–±—ã—á–Ω–æ –º–µ–Ω—å—à–µ

// –°–∂–∞—Ç–∏–µ –¥—É–±–ª–∏–∫–∞—Ç–æ–≤: (value, count) –≤–º–µ—Å—Ç–æ –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã—Ö –∑–∞–ø–∏—Å–µ–π
type MinEntry struct {
    Value int
    Count int  // –°–∫–æ–ª—å–∫–æ —Ä–∞–∑ —ç—Ç–æ—Ç –º–∏–Ω–∏–º—É–º –≤—Å—Ç—Ä–µ—á–∞–µ—Ç—Å—è
}
```

Min Stack - —ç—Ç–æ **–∫–ª–∞—Å—Å–∏—á–µ—Å–∫–∞—è** –∑–∞–¥–∞—á–∞ –Ω–∞ –ø–æ–Ω–∏–º–∞–Ω–∏–µ –∏–Ω–≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ –∏ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä –¥–∞–Ω–Ω—ã—Ö! üéØ –û—Ç–ª–∏—á–Ω–∞—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è trade-off –º–µ–∂–¥—É –≤—Ä–µ–º–µ–Ω–µ–º –∏ –ø–∞–º—è—Ç—å—é.
