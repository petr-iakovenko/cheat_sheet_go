# Конспект по "GO_начало"

## **Навигация по темам**

1. [Популярные комманды в GO](#популярные-команды-go)
2. [Среда разработки - IDE](#среда-разработки---ide)
3. [HotKey VSCode](#hotkey-vscode)  
4. [Как открывать VSCode из папки](#как-открывать-vscode-из-папки)  
5. [Структура базовой программы](#структура-базовой-программы)  
6. [Логические операторы и сравнение](#логические-операторы-и-сравнения)  
7. [Переменные и константы](#переменные-и-константы)  
8. [Операторы ветлвения](#операторы-ветвления)  
9. [Виды циклов](#виды-циклов)  
10. [Функции](#функции)  
11. [Как функция обрабатывает разные типы данных](#как-функция-обрабатывает-разные-типы-данных)  
12. [Ссылки и указатели](#ссылки-и-указатели)  
13. [Массив](#массив)  
14. [Слайс](#слайс)  
15. [Мапа](#мапа---ассоциативный-массив)  
16. [Объявление пользовательских типов](#объявление-пользовательских-типов)  
17. [Структуры](#структуры)  
18. [ООП в GO](#summary---ооп-в-go)  
19. [ООП - объекты (Cтруктуры - struct)](#ооп---объекты---структуры)  
20. [ООП - полиморфизм (Интерфейсы - interface)](#ооп---полиморфизм---интерфейсы)  
21. [ООП - инкапсуляция (method - get/set)](#ооп---инкапсуляция)  
22. [Пакеты и модули](#пакеты-и-модули)  
23. [Горутины](#горутины)  
24. [Каналы](#каналы)  
    - [О конуркнтности и паралелизме - конспект](paral_concur_cs_GO.md)
25. [Cтек и Куча в Go](#стек-и-куча-в-go)

[Алгоритмы - конспект](algo_cs_go.md)

---

## Популярные команды GO

| **Команда**           | **Описание**                                                                                                                                                      |
|------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **Сборка**            |                                                                                                                                                                  |
| `go build`            | Скомпилировать код и получить бинарник                                                                                                                           |
| `go run`              | Сразу же скомпилировать и запустить код                                                                                                                          |
| `go generate`         | Запустить кодогенерацию                                                                                                                                          |
| `go install`          | Скачать утилиту, скомпилировать и установить бинарник в `$GOPATH/bin` (например, этой командой можно установить дебаггер: `go install github.com/go-delve/delve/cmd/dlv@latest`) |
| **Работа с зависимостями** |                                                                                                                                                                  |
| `go get`               | Скачать зависимость                                                                                                                                               |
| `go mod init`          | Создать файл со списком зависимостей                                                                                                                              |
| `go mod tidy`          | Актуализировать файл со списком зависимостей                                                                                                                      |
| `go mod vendor`        | Завендорить зависимости (весь исходный код зависимостей скопировать в каталог `vendor` вашего проекта)                                                             |
| **Тестирование и профилирование** |                                                                                                                                                             |
| `go test`              | Запустить юнит-тесты (или бенчмарки)                                                                                                                                 |
| `go tool cover`        | Собрать отчёт о покрытии кода после юнит-тестов                                                                                                                      |
| `go tool pprof`        | Профилировать программу                                                                                                                                             |
|                        |  |
| **Утилиты**            |                                                                                                                                                                  |
| `go fmt`              | Прогнать автоформатирование кода                                                                                                                                  |
| `go vet`              | Прогнать линтеры                                                                                                                                                  |
| `go env`              | Вывести список переменных окружения, используемых Go                                                                                                              |

---

## Среда разработки - IDE

[Плагин vim-go](https://github.com/fatih/vim-go) - Для редактора Vim.  
[PyCharm](https://www.jetbrains.com/go/) - paid  

---

## HotKey VSCode

`cmd + shift + home` - Terminal (changed)  

`cmd + shift + P` - Command line VSCode

---

## Как открывать VSCode из папки

**Установка возможности запуска VSCode из терминала:**

В VSCode вызываем Command line и выбираем:

> **Shell Command: Install 'code' command in PATH**

Для запуска VSCode в необходимой директории необходимо в нее войти в выполнить комманду:

```bash
code .
```

---

## Структура базовой программы

1) Объявляется пакет `packege <name>`
2) Объявляются импорты пакетов `import (<name>)`
    - встроенные пакеты в go [тут](https://pkg.go.dev/std)
3) Пишется логика программы

### Запуск программы (в лоб)

```bash
go run <name>.go
```

### Компиляция и запуск

Компиляция коммандой:

```bash
go build <name>.go
```

Запуск скомпилированного файла:

```bash
./<name>
```

---

## Логические операторы и сравнения

`>` — больше;  
`<` — меньше;  
`>=` — больше или равно;  
`<=` — меньше или равно;  
`==` — равно;  
`!=` — не равно.  

А также логические операторы:  

`&&` — логическое И;  
`||` — логическое ИЛИ;  
`!` — логическое НЕ.

---

## Переменные и константы

### Объявление константы

`const` - инициализируются со значениями, которые нельзя изменить.

```go
const message string = "some text"
```

### Объявление переменной

Как узнать тип переменной - `name`?

```go
fmt.Println(reflect.TypeOf(name))
```

#### Нотация по умолчанию

```go
var a, b int  // объявление переменных
a, b = 1, 2  // присваивание значения переменным 

var a string
a = "abc"
```

```go
var height int
var length int
var weight float64
var name   string
var unsignedInt uint // non-negative
var b bool 
var byteVar byte // uint8 [0 ... 255] size 1 byte ASCII
var runeVar rune // int32 [-2147483648 ... 2147483647] size 4 byte
var company = "Рога и копыта"

// эквивалентно

var (
    height, length int
    weight float64
    name   string
    usignedInt uint
    b bool
    byteVar byte
    runeVae rune
    company = "Рога и копыта"
)
```

#### Короткая нотация

```go
int64Var := int64(5)  # тип указан в лоб, исключая автоопределение
float32Var := float32(101.3)

// эквивалентно

var int64Var int64 = 5 
var floatVar float32 = 101.3 
```

#### Как поменять местами переменные

```go
a, b, c := 1, 2, 3 
a, b = b, a // 2, 1
a, _, c := 4, 5, 6 // пропуск записи в b
```

#### Локальная и глобальные переменные

Глобальная переменная объявляется вне функций и доступна во всей программе, а локальная — внутри функции и доступна только в ее пределах.  

Даже если локальные переменные назавны как глобальные и **проинициализированы** `:=` в теле функции, они все равно будут иметь "свои" значения так как хранятся в другой ячейки памяти. НО если будет использваться не инициализация, а **присваивание** `=`, то глобальные переменные будут перезаписаны.

---

## Операторы ветвления

> [*---> вернуться списку тем*](#навигация-по-темам)

### Условие `if — else`

````go
if a == 1 {
    // сценарий, если условие if выполнено
} else if a == 2 {
    // сценарий, если условие else if выполнено
} else {
    // сценарий, если условие else if не выполнено
}
````

### Условие `switch — case`

```go
var a int

switch a {
case 1:
    fmt.Println("1")
case 2:
    fmt.Println("2")
case 3, 4:
    fmt.Println("3 or 4")
default:
    fmt.Println("Default case")
}
```

```go
func days(day stirng) (string, err) {
    
  switch day {
  case "Monday":
    return "Start of the week!", nil
  case "Friday":
    return "Almost weekend!", nil
  default:
    "Just another day.", error.New("about error")
  }
}
```

Наличие блока `default` необязательно — его можно опустить, если не требуется описывать «стандартное» поведение. Этот блок выполнится, если ни одно из условий не отработало.

---

## Виды циклов

> [*---> вернуться списку тем*](#навигация-по-темам)

### Бесконечный цикл

```go
for {
    // код, выполняемый внутри бесконечного цикла
}
```

### Трёхкомпонентный цикл

```go
// создаём переменную
v := 0
// 
for i := 1; i < 10; i++ {
    // наращиваем переменную
    v++
}

fmt.Println(v)
```

**Классическая форма цикла состоит из трёх компонентов:**
  
`i := 1` — инициализация (pre-действие): выполняется единожды при входе в scope цикла;  
`i < 10` — основное условие: пока условие `true`, итерации будут продолжаться;  
`i++` — post-действие: выполняется по завершении каждой итерации цикла.  

Заполнять каждую компоненту необязательно — можно опускать.

#### Пример с сортировкой в обратном порядке

```go
arr := []int{1, 2, 3, 4, 5}

for i, j := 0, len(arr)-1; i < j; i, j = i+1, j-1 {
    arr[i], arr[j] = arr[j], arr[i]
}
```

**Формат цикла `for`:**

```go
for i, j := start, end; condition; post-statement {
// Тело цикла
}
```

- i, j := start, end — это начальная инициализация переменных.
- condition — условие, которое проверяется на каждой итерации цикла.
- post-statement — выражения, которые выполняются после каждой итерации (например, увеличение/уменьшение индексов).  

### Цикл с одним условием (аналог `while` из Python)

#### Цикл `for`

В цикле `for` можно указывать **только одно условие**. В этом случае необходимая начальная инициализация должна происходить перед циклом, а действия, влияющие на условие, — выполняться внутри цикла.

```go
for [инициализация счетчика]; [условие]; [изменение счетчика]{
    // действия
}
```

```go
package main

import "fmt"

func main() {
    // начальная инициализация
    i := 0
    for i < 5 {
        // выводим результат на экран
        fmt.Println(i)
        // наращиваем переменную
        i++
    }
}
```

##### Цикл `range`  

Используется для комплексных типов — слайса и мапы (map).  
(при работе с `map` будет выводить ключ и значение)

```go
fruits := []string{"apple", "banana", "cherry", "date"}

for index, fruit := range fruits {
    fmt.Printf("Index: %d, Fruit: %s\n", index, fruit)
}
// Index: 0, Fruit: apple
// Index: 1, Fruit: banana
// Index: 2, Fruit: cherry
// Index: 3, Fruit: date
```

`range fruits` — это конструкция, которая автоматически возвращает два значения для каждого элемента слайса:

- `index` — индекс текущего элемента в слайсе (целое число).
- `fruit` — значение элемента слайса на текущем индексе (строка).  

Eсли  не нужно использовать индекс, можно пропустить его, используя `_` -> `for _, fruit := range fruits { *** }`

#### Ключевые слова `break` и `continue`

```go
sum, limit := 0, 100
for i := 0; true; i++ {
    if i % 2 != 0 {
    continue // переход к следующему числу, так как i — нечётное
    }
    
    if sum + i > limit {
        break // выход из цикла, так как сумма превысит заданный предел
    }
    
    sum += i
}
fmt.Println(sum)
```

---

## Функции

> [*---> вернуться списку тем*](#навигация-по-темам)

**Printing witn - `%?`** -  [The verbs](https://pkg.go.dev/fmt)

**Объявление функции:**

```go
func name_func (params) (type1, type2 ...){
    body_func
    return some1, some2, ...
}
```

```go
func someFunc(n int) int { 
    // body
    return n
}
```

В случае множественного возращения значения функции есть тип `error`, то надо возвращать `nil` или саму ошибку и проверять ее через `if err != nil`.

```go
func main() {
    message, err := checkFunc(-1)
    if err != nil {                 // проверка ошибки
        log.Fatal(err)              // для примера (тут return не нужен)
        return fmt.Println("Error") // для примера
    }
    fmt.Println(message)
}

func checkFunc(n int) (int, error) { 
    if n > 0 {
        return n, nil
    } if else n == 0 {
        return n, errors.New("about error")
    }
    return n, err
}
```

### Предача в func n-переменных (Variadic functions)

**Variadic functions** - функции с переменным количеством переменных. Внутри функции этот параметр рассматривается как нумерованная последовательность аргументов `slice`

```go
func Sum(x ...int) (res int) {
    for _, v := range x {
        res += v
    }
    return
}

sum := Sum(2, 3, 5, 1, 2, 57)
```

```go
func findMin(numbers ... int) int {
    if len(numbers) == 0 {
        return 0
    }

    min := numbers[0]

    for _, i := range numbers {
        if i > max {
            max = i
        }
    return max
    }
}
```

### Рекурсивные функции

Рекурсивная функция вызывает сама себя.

```go
// хрестоматийный пример рекурсивного вычисления n!, факториала числа:

func fact(n int) int {
    if n == 0 {    // терминальная ветка — то есть условие выхода из рекурсии
        return 1
    } else {    // рекурсивная ветка 
        return n * fact(n-1)
    }
}
```

```go
// числа Фибоначчи

func Fib(n int) int {
    switch {
    case n <= 1:    // терминальная ветка 
        return n
    default:        // рекурсивная ветка
        return Fib(n-1) + Fib(n-2)
    }
}
```

### Функция первого класса и `lambda`

Функцию можно присвоить переменной, можно передать аргументом другой функции. Функция может возвращать в качестве значения другую функцию.  

Тип функции виден в её сигнатуре, то есть определяется как набор типов и количества аргументов, возвращаемых значений.

````go
func Say(animal string) (v string) {
    switch animal {
    default:
        v = "heh"
    case "dog":
        v = "gav"
    case "cat":
        v = "myau"
    case "cow":
        v = "mu"
    }
    return
}

// func Say имеет тип:
// func(string) string
````

**Можно присвоить её переменной такого типа:**

```go
var voice func(string) string
voice = Say
```

Это пример использования **функции как значения**.

Логика кода:

1. **`var voice func(string) string`**  
   - Объявляется переменная `voice`, которая имеет тип "функция".  
   - Функция должна принимать один аргумент типа `string` и возвращать `string`.

2. **`voice = Say`**  
   - Переменной `voice` присваивается ссылка на функцию `Say`.  
   - Это значит, что теперь `voice` можно использовать для вызова функции `Say`.

Итог:

Можно вызывать функцию `Say` через переменную `voice`, например:  

```go
result := voice("Hello")
```

**Можно написать функцию высшего порядка с параметром такого типа:**

Пример, как функция передаётся как аргумент в другую функцию, что позволяет динамически изменять её поведение в зависимости от переданного обработчика.

```go
func Print(who string, how func(string) string){
    fmt.Println(how(who))
}

// вызов функции с аргументом
Print("dog", Say)
```

Логика кода:

1. **`Print` — функция высшего порядка**  
   Это функция, которая принимает:
   - `who string`: строку.
   - `how func(string) string`: функцию, принимающую строку и возвращающую строку.

   Внутри `Print` вызывается функция `how(who)`, результат которой выводится с помощью `fmt.Println`.

2. **`Print("dog", Say)` — вызов функции с аргументами**  
   - `"dog"` передаётся как первый аргумент `who`.
   - `Say` — это функция, которая соответствует типу `func(string) string`, и она передаётся как второй аргумент `how`.

   Во время вызова `Print`, функция `Say` вызывается с аргументом `"dog"`, её результат передаётся в `fmt.Println`.

Пошаговый процесс:

1. **Передача аргументов:**
   - `who = "dog"`.
   - `how = Say`.

2. **Вызов внутри `Print`:**
   - `how(who)` становится `Say("dog")`.

3. **Результат:**
   - Результат вызова `Say("dog")` передаётся в `fmt.Println` и выводится.

### Замыкания (генераторы)

Лексическая область видимости (lexically scoped) - это значит, что переменные, определённые в окружающих блоках видимости (например, глобальные переменные), доступны функции всегда, а не только на время вызова. Можно считать, что функция их запоминает.

Лексическая область видимости и анонимные функции позволяют реализовать замыкания (closure).  

Такие функции иногда называют генераторами.

- Замыкание захватывает переменную в момент создания замыкания;
- Замыкание может изменять значение внешней переменной.

**Когда полезны замыкания?**

- Глобальные переменные:
  - Когда вам нужно, чтобы несколько функций в программе использовали общие данные.
- Локальные переменные:
  - Когда вам нужно инкапсулировать состояние внутри конкретной функции и позволить анонимной функции работать с этим состоянием.

#### Пример с разбором логики замыкания

```go
package main

import "fmt"

// Функция, которая возвращает самоссылочную функцию
func makeMultiplier(factor int) func(int) int {
    return func(x int) int {
        return x * factor
    }
}

func main() {
    multiplyBy2 := makeMultiplier(2)  //  переменная multiplyBy2 будет хранить функцию, которая умножает числа на 2
    multiplyBy3 := makeMultiplier(3)  // переменная multiplyBy2 будет хранить функцию, которая умножает числа на 3
    // Обе функции, возвращенные из makeMultiplier, ссылаются на свои собственные значения factor — 2 для multiplyBy2 и 3 для multiplyBy3. 
    // В этом и заключается принцип замыкания.

    fmt.Println(multiplyBy2(5)) // 10 
    fmt.Println(multiplyBy3(5)) // 15
}
```

Логика кода:

 1. `makeMultiplier(factor int)` — это функция, которая принимает один параметр `factor` (например, `2` или `3`) и возвращает другую функцию. Эта возвращаемая функция принимает параметр `x` и возвращает его умноженным на `factor`.

 2. Закрытие или замыкание (`closure`):

- Функция, которая возвращается из `makeMultiplier`, ссылается на переменную `factor`, даже если она была определена в родительской функции (`makeMultiplier`).
- Когда вызываем `makeMultiplier(2)`, она возвращает функцию, которая умножает число `x` на `2`.
- Когда вызываем `makeMultiplier(3)`, она возвращает функцию, которая умножает число `x` на `3`.

**“Замкнута” на `factor`:**

Функция замкнута на переменной `factor`, это означает, что возвращаемая функция запоминает значение `factor`, которое было передано при её создании, и использует это значение даже после того, как функция `makeMultiplier` уже завершила своё выполнение.

Это называется замыканием (`closure`), и его ключевая особенность заключается в том, что возвращаемая функция “запоминает” внешние переменные, к которым она имеет доступ. Эти переменные продолжают существовать в памяти и доступны даже после того, как внешний контекст (в котором они были определены) завершил выполнение.

Когда вызываем:

```go
multiplyBy2 := makeMultiplier(2)
multiplyBy3 := makeMultiplier(3)
```

- Переменная `multiplyBy2` будет хранить функцию, которая умножает числа на `2`.
- Переменная `multiplyBy3` будет хранить функцию, которая умножает числа на `3`.

Обе функции, возвращенные из makeMultiplier, ссылаются на свои собственные значения `factor` — `2` для `multiplyBy2` и `3` для `multiplyBy3`. В этом и заключается принцип замыкания.

**Почему это важно:**

 1. Гибкость:
    - Каждое замыкание (возвращенная функция) может “помнить” свое окружение, т.е. значение переменной `factor`, с которой оно было создано.
 2. Конфиденциальность:
    - Можно скрыть детали реализации внутри функции `makeMultiplier` и предоставить пользователю только нужный интерфейс — возвращаемую функцию, которая работает с заданным параметром.

#### Простой пример замыкания

```go
package main

import "fmt"

func main() {
    // Переменная, которая будет запомнена функцией
    counter := 0

    // Замыкание: анонимная функция, использующая переменную counter
    increment := func() int {
        counter++
        return counter
    }

    // Вызов функции, она продолжает использовать переменную counter
    fmt.Println(increment()) // 1
    fmt.Println(increment()) // 2
    fmt.Println(increment()) // 3
}
```

Логика кода:

 1. Функция `increment`:
    - Это анонимная функция (функция без имени), которая увеличивает значение переменной `counter` на `1` при каждом её вызове и возвращает новое значение переменной.
    - Функция `increment` замкнута на переменной `counter`, т.е. она “помнит” состояние этой переменной, даже после того, как её основная область видимости завершится.

 2. Использование замыкания:
    - При каждом вызове `increment()`, переменная `counter` увеличивается на `1`, и результат возвращается на экран.
    - Даже если переменная `counter` была объявлена в функции `main` (т.е. в другой области видимости), анонимная функция продолжает ссылаться на неё и модифицировать её значение.
    - Это и есть поведение замыкания: функция может захватывать (или “запоминать”) переменные из своей внешней области видимости и продолжать с ними работать даже после того, как эта область завершена.

 3. Результат выполнения программы:
    - При каждом вызове функции `increment()` значение переменной `counter` увеличивается на `1`

Объяснение:

- Создали переменную `counter` и анонимную функцию `increment`, которая увеличивает её значение на `1`.
- Каждое вызовы `increment()` увеличивает `counter` и возвращает его новое значение.
- Важно, что `counter` остаётся доступным для функции `increment`, даже если основная функция `main` завершила выполнение.

#### Пример работы замыкания с глобальной переменный и обычной функцией

```go
package main

import "fmt"

// Глобальная переменная
var a int

// Функция, изменяющая глобальную переменную
func updateA() {
    a = 5
}

// Замыкание, которое изменяет глобальную переменную
func closure() int {
    a++  // Увеличивает глобальную переменную a
    return a
}

func main() {
    fmt.Println(closure())  // 1 (a = 0 + 1)
    updateA()               // a = 5
    fmt.Println(closure())  // 6 (a = 5 + 1)
    updateA()               // a = 5 (функция не изменяет глобальную переменную)
    fmt.Println(closure())  // 6 (a не изменился, замыкание продолжает использовать a = 5)
}
```

#### Пример: Генерация уникальных ID

Есть сервер, который генерирует уникальные идентификаторы для пользователей. Можно использовать замыкания для создания счётчика уникальных ID, который будет увеличиваться при каждом запросе.

```go
package main

import (
    "fmt"
    "sync"
)

func main() {
    var mu sync.Mutex

    // Замыкание для генерации уникальных ID
    generateID := func() func() int {
        id := 0
        return func() int {
            mu.Lock()
            id++
            mu.Unlock()
            return id
        }
    }

    getNextID := generateID()

    // Генерация уникальных ID
    fmt.Println(getNextID()) // 1
    fmt.Println(getNextID()) // 2
    fmt.Println(getNextID()) // 3
}
```

Объяснение:

- `generateID` — это замыкание, которое создаёт функцию для генерации уникального `ID`. Эта функция будет увеличивать значение `id` каждый раз, когда она вызывается.
- Используем мьютекс `mu` для защиты от гонок (`concurrency`), чтобы несколько горутин не изменяли `id` одновременно.

#### Пример: Обработчик HTTP запросов

Нужно создать обработчик для разных типов API-запросов, и для каждого типа запроса нужно запомнить некоторое состояние (например, количество вызовов). Замыкание может быть полезно для хранения этого состояния.

```go
package main

import (
    "fmt"
    "net/http"
    "sync"
)

func main() {
    var mu sync.Mutex

    // Замыкание для подсчёта количества вызовов
    requestCounter := func() func() int {
        count := 0
        return func() int {
            mu.Lock()
            count++
            mu.Unlock()
            return count
        }
    }

    counter := requestCounter()

    http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
        fmt.Fprintf(w, "Request number: %d", counter()) // Выводит номер запроса
    })

    fmt.Println("Server started at http://localhost:8080")
    http.ListenAndServe(":8080", nil) // Запуск сервера
}
```

Объяснение:

- Cоздаtncz замыкание `requestCounter`, которое запоминает количество запросов. Каждый раз, когда сервер обрабатывает новый запрос, функция `counter()` увеличивает счётчик и возвращает его текущее значение.
- Замыкание позволяет сохранить состояние счётчика между вызовами обработчика, даже если сама функция обработчика выполняется несколько раз.

#### “Self-referential functions and the design of options” -  Роб Пайк

Допустим, есть функция, которая накапливает значение и может изменять это поведение через замыкание.

```go
package main

import "fmt"

func newCounter(start int) func(int) int {
    count := start
    return func(increment int) int {
        count += increment  // Здесь 'increment' является опцией, которая изменяет состояние
        return count
    }
}

func main() {
    counter := newCounter(10)  // Начальное значение 10

    fmt.Println(counter(5))  // 15 (прибавляем 5)
    fmt.Println(counter(3))  // 18 (прибавляем 3)
    fmt.Println(counter(10)) // 28 (прибавляем 10)
}
```

Когда вы вызываете `counter(5)`, параметр `5` можно рассматривать как опцию, которая влияет на состояние замыкания.

Логика работы замыкания:

 1. Создание замыкания:
     - Когда вы создаете замыкание с помощью `newCounter(10)`, функция `newCounter` возвращает анонимную функцию, которая увеличивает внутреннюю переменную `count`. Эта переменная сохраняет свое состояние между вызовами, потому что она находится внутри замыкания.
 2. Передача параметра в замыкание:
    - Когда вы вызываете `counter(5)`, вы передаете значение `5` в качестве параметра для этой анонимной функции. В этом контексте параметр `5` называется опцией, так как он передается функции для изменения поведения замыкания.

Например:

- В первый раз, когда вы вызываете `counter(5)`, внутренний счетчик увеличивается на `5`, и результат равен `15` (начальное значение было `10`).
- Во второй раз, вызывая `counter(3)`, вы передаете опцию `3`, и внутреннее состояние (переменная `count`) снова обновляется, увеличиваясь на `3`.

Что такое **“опция”** в данном контексте?

В данном контексте опция — это параметр, который вы передаете в замыкание при его вызове. Это значение влияет на логику работы замыкания, то есть, на то, как будет изменяться его внутреннее состояние (переменная `count`).

##### Пример с однотипным элементом и изменений параметров

Нам нужно инициализировать однотипные элементы значениями по умолчанию, но с возможностью задать некоторые параметры.

```go
// Cтруктура Item, которая используется для хранения данных.
type Item struct {
    NoOption string     // хранит информацию по умолчанию
    Parameter1 string
    Parameter2 int
}

// конструктор с опциями
func NewItem(opts ...option) *Item {
    // инициализируем типовыми значениями
    i := &Item{
        NoOption: "usual",
        Parameter1: "default",
        Parameter2: 42,
    }
    // применяем опции в том порядке, в котором они были заявлены
    for _, opt := range opts {
        opt(i)
    }
    return i
}

//опции — это функции, применяемые к объекту. За это подход получил название funcopts
type option func(*Item)

//чтобы устанавливать параметры, используются функции высшего порядка, возвращающие значениями функции option
func Option1(option1 string) option {
    return func(i *Item) {
        i.Parameter1 = option1
    }
}
func Option2(option2 int) option {
    return func(i *Item) {
        i.Parameter2 = option2
    }
}

// инициализация
func main() {
    // с параметрами по умолчанию, так как вызывется без опций
    item1 := NewItem()
    fmt.Printf("%+v\n", item1)
    // с применением одной опции
    // создается новый объект, а затем применяется опция Option2
    item2 := NewItem(Option2(70))
    fmt.Printf("%+v\n", item2)
    // -//- применяется 2 опции
    item3 := NewItem(Option1("unusual"), Option2(99))
    fmt.Printf("%+v\n", item3)
    // -//- применяется 2 опции в разном порядке
    item4 := NewItem(Option2(88), Option1("rare"))
    fmt.Printf("%+v", item4)
}
// &{NoOption:usual Parameter1:default Parameter2:42}
// &{NoOption:usual Parameter1:default Parameter2:70}
// &{NoOption:usual Parameter1:unusual Parameter2:99}
// &{NoOption:usual Parameter1:rare Parameter2:88}
```

Логика кода:

Функция `NewItem` (конструктор с опциями) создает и инициализирует новый объект типа `Item` с параметрами по умолчанию. Но она также может принимать опции (параметры), которые изменяют значения полей структуры:

- `opts ...option:` Эта запись означает, что можно передавать произвольное количество параметров типа option. Тип option определяется ниже как функция, которая принимает указатель на `Item` и изменяет его.
- В строках `i := &Item{...}` создается новый объект `Item` с дефолтными значениями.
- Далее, в цикле`for _, opt := range opts`, применяются все переданные опции к новому объекту. Каждая опция — это функция, которая изменяет соответствующие поля структуры.

`type option func(*Item)` — это лямбда-функция, которая принимает указатель на `Item` и изменяет поля структуры `Item`.

`Option1` и `Option2`, создают опции, которые изменяют поля структуры `Item`:

- `Option1` принимает `string` параметр `option1` и возвращает функцию, которая меняет `Parameter1` структуры на переданное значение.
- `Option2` принимает `int` параметр `option2` и возвращает функцию, которая меняет `Parameter2` структуры на переданное значение.

##### Пример с подсчетом площадей фигуры

Нужно передавать тип фигуры и после передачи типа считать прощадь.

````go
package main

import (
 "fmt"
    "math"
)

// объявляем тип
type figures int

// объявляем константы фигур
const (
    square figures = iota // квадрат = 0
    circle                // круг = 1 
    triangle              // равносторонний треугольник = 2
)

// функция принимает фигуру и возвращает функцию, которая возвращает площадь фигуры
func area(nameFigure figures) (func(float64) float64, bool) {
    // если фигура квадрат, возвращаем функцию, которая возвращает площадь квадрата
    if nameFigure == 0 {
        return func(a float64) float64 {
            return math.Pow(a, 2)
        }, true
    // если фигура круг, возвращаем функцию, которая возвращает площадь круга
    } else if nameFigure == 1 {
        return func(a float64) float64 {
            return math.Pi * math.Pow(a, 2)
        }, true
    // если фигура треугольник, возвращаем функцию, которая возвращает площадь треугольника
    } else if nameFigure == 2 {
        return func(r float64) float64 {
            return math.Pow(r, 2) * math.Sqrt(3)
        }, true
    // если фигура неизвестна, возвращаем nil и false
    } else { 
        return nil, false
    }

}

func main() {
    // передаем фигуру
    ar, ok := area(1)
    // если фигура неизвестна, выходим
    if !ok {
        fmt.Println("Ошибка")
        return
    }
    // вычисляем площадь
    myArea := ar(2)
    fmt.Println(myArea)
}
````

Можно использовать конструкцию `switch - case`

````go
func area(f figures) (func(float64) float64, bool) {
    switch f {
    case square:
        return func(x float64) float64 { return x * x }, true
    case circle:
        return func(x float64) float64 { return 3.142 * x * x }, true
    case triangle:
        return func(x float64) float64 { return 0.433 * x * x }, true
    default:
        return nil, false
    }
} 
````

### Специальная функция func `init() { … }`

`init()` — это специальная функция, которая выполняется автоматически при старте программы, до выполнения функции `main()`. Она используется для инициализации пакетов и подготовки переменных, структур данных или другого состояния, которое требуется до начала работы программы.

1. Автоматический вызов `init()`:
    - Функция `init()` вызывается автоматически, и вы не вызываете её вручную.
    - В одном пакете может быть несколько функций `init()`, и они будут вызваны по порядку их объявления (если это несколько разных пакетов, то инициализация будет происходить в порядке зависимостей между ними).

2. Местоположение `init()`:
    - Она может быть размещена в любом месте пакета, но всегда будет выполнена перед `main()` в этом пакете.
    - Функция `init()` выполняется для каждого пакета, который импортируется в программу.

3. `init()` используется для выполнения инициализации, такой как:
    - Подключение к базе данных.
    - Инициализация логирования.
    - Настройка переменных или констант.
    - Обработка флагов командной строки.
    - Подготовка глобальных переменных.

Особенности функции `init()`:

- Не возвращает значения: Функция `init()` не может возвращать значения, она не принимает аргументы.
- Может быть несколько: В одном пакете может быть несколько функций `init()`, и они будут выполняться по очереди, начиная с самого первого.
- Вызов только один раз: Функция `init()` будет вызвана один раз при запуске программы, даже если она определена несколько раз в разных местах одного пакета или в разных пакетах.

Пример кода с подключением к PostgreSQL

````bash
go get github.com/lib/pq
````

````go
package main

import (
 "database/sql"
 "fmt"
 "log"

 _ "github.com/lib/pq" // импортируем драйвер для PostgreSQL
)

var db *sql.DB

// Функция init() выполняет подключение к базе данных PostgreSQL
func init() {
    var err error
    // Строка подключения к базе данных
    connStr := "user=postgres password=mysecretpassword dbname=mydb sslmode=disable"

    // Открываем подключение
    db, err = sql.Open("postgres", connStr)
    if err != nil {
        log.Fatal("Ошибка при подключении к базе данных: ", err)
    }

    // Проверяем подключение
    err = db.Ping()
    if err != nil {
        log.Fatal("Ошибка при проверке подключения: ", err)
    }

    fmt.Println("Подключение к базе данных PostgreSQL успешно установлено!")
}

func main() {
    // Теперь можно использовать переменную db для работы с базой данных
    // Пример простого запроса
    rows, err := db.Query("SELECT id, name FROM users")
    if err != nil {
        log.Fatal("Ошибка при выполнении запроса: ", err)
    }
    defer rows.Close()

    for rows.Next() {
        var id int
        var name string
        err := rows.Scan(&id, &name)
        if err != nil {
            log.Fatal("Ошибка при извлечении данных: ", err)
        }
        fmt.Printf("ID: %d, Name: %s\n", id, name)
    }

    // Проверка на ошибки после завершения обхода
    err = rows.Err()
    if err != nil {
        log.Fatal("Ошибка при обходе строк: ", err)
    }

    // Закрытие подключения (можно не закрывать в main, если программа заканчивает работу)
    defer db.Close()
}
````

Разбор кода:

1. Функция `init()`:
    - Создаем строку подключения connStr, которая включает информацию о пользователе (`user`), пароле (`password`), базе данных (`dbname`) и режиме SSL (`sslmode=disable`).
    - Затем с помощью `sql.Open` открываем соединение с PostgreSQL.
    - Важно отметить, что `sql.Open` не устанавливает соединение с базой данных, а только подготавливает структуру для подключения. Используем `db.Ping()` для проверки того, что соединение действительно установлено и работает.
    - Если в процессе инициализации подключения произойдет ошибка, она будет зафиксирована с помощью `log.Fatal`, и программа завершится.

2. Основная функция `main()`:
    - После того как подключение в `init()` было установлено, можно использовать объект db для выполнения SQL-запросов.
    - В примере выполняется запрос `SELECT id, name FROM users`, чтобы получить данные из таблицы `users`. Затем данные обрабатываются в цикле с использованием метода `Scan`, который извлекает данные из строки результата запроса.
    - Важно правильно обрабатывать ошибки, например, если нет данных в таблице или ошибка при извлечении значений.

3. Примечание:
    - Для обеспечения безопасности подключения, в реальной практике не следует хранить строку подключения в исходном коде. Лучше использовать переменные окружения или конфигурационные файлы для этих целей.

Пример переменной окружения для строки подключения:

1. Установите переменную окружения в вашей системе (например, в Unix/Linux/macOS):

    ````bash
    export DB_CONN_STR="user=postgres password=mysecretpassword dbname=mydb sslmode=disable"
    ````

2. В коде используйте эту переменную:

    ````go
    package main

    import (
        "database/sql"
        "fmt"
        "log"
        "os"

        _ "github.com/lib/pq"
    )

    var db *sql.DB

    func init() {
        var err error
        // Получаем строку подключения из переменной окружения
        connStr := os.Getenv("DB_CONN_STR")

        // Открываем подключение
        db, err = sql.Open("postgres", connStr)
        if err != nil {
            log.Fatal("Ошибка при подключении к базе данных: ", err)
        }

        // Проверяем подключение
        err = db.Ping()
        if err != nil {
            log.Fatal("Ошибка при проверке подключения: ", err)
        }

        fmt.Println("Подключение к базе данных PostgreSQL успешно установлено!")
    }

    func main() {
        // Пример запроса и обработки данных, как в предыдущем примере
    }
    ````

### Оператор отложенного вызова `defer`

В `python` это конеткстный менеджер `with`

Основные характеристики `defer`:

 1. Выполняется в конце функции:  
• Все вызовы, помеченные `defer`, откладываются и выполняются перед выходом из текущей функции, даже если выход происходит из-за `return` или `panic`.
 2. Порядок выполнения (LIFO):  
• Если в функции указано несколько `defer`, они выполняются в обратном порядке их объявления (по принципу “последний пришёл — первый ушёл”).
 3. Полезен для освобождения ресурсов:  
• Часто используется для закрытия файлов, освобождения блокировок, закрытия соединений и других действий, которые должны быть выполнены при завершении функции.

Пример исползования с файлом:

```go
// открываем файл
file, err := os.OpenFile("file.txt", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
if err != nil {
    log.Fatal(err)
}
// не забываем закрыть файл
defer file.Close()
// работаем с файлом
_, err = file.WriteString("")
if err != nil {
    log.Fatal(err)
}
```

### Функция `recover()`

`recover()` — это встроенная функция в Go, которая используется для обработки **паники** (`panic`). Паника — это механизм аварийного завершения программы, который возникает при критической ошибке (например, деление на ноль, выход за границы массива).

Когда паника происходит, программа начинает завершаться, вызывая функции `defer` в обратном порядке. Если в одной из отложенных функций используется `recover()`, паника будет "поймана", и программа сможет продолжить выполнение.

#### Как работает `recover()`?

1. Вызывается `panic()` — программа переходит в режим паники.
2. Все отложенные функции (`defer`) начинают выполняться.
3. Если внутри одной из отложенных функций вызывается `recover()`, паника "перехватывается".
4. Программа не завершает выполнение, а продолжает работать.

**Простой пример с объяснением логики:**

```go
func main() {
    // Вызов функции, где может произойти паника
    safeDivision(10, 0)

    fmt.Println("Программа продолжает выполнение после обработки паники.")
}

// Функция для безопасного деления
func safeDivision(a, b int) {
    // Отложенная функция для обработки паники
    defer func() {
        if r := recover(); r != nil {
        // Если была паника, r содержит сообщение об ошибке
        fmt.Println("Паника перехвачена:", r)
        }
    }()

    // Возможная ошибка: деление на ноль
    result := a / b
    fmt.Println("Результат деления:", result)
}
```

**Объяснение:**

1. **Основная программа (`main`) вызывает `safeDivision` с делением на 0.**
   - Это вызывает панику.

2. **Отложенная функция (`defer`) в `safeDivision`:**
   - Когда паника происходит, эта функция выполняется.
   - `recover()` перехватывает панику и возвращает её сообщение (`runtime error: integer divide by zero`).

3. **Программа продолжает выполнение после обработки паники.**

**Вывод:**

- Паника перехвачена: runtime error: `integer divide by zero`  
- Программа продолжает выполнение после обработки паники.

---

### `recover()` из практики: Обработка паники в HTTP-сервере

**Задача:**

Создать HTTP-сервер, который перехватывает панику в обработчиках запросов, чтобы сервер не "падал" при критических ошибках.

```go
package main

import (
    "fmt"
    "net/http"
)

// Middleware для обработки паники
func recoveryMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // Отложенная функция для обработки паники
        defer func() {
            if r := recover(); r != nil {
                // Логируем панику
                fmt.Println("Перехвачена паника:", r)

            // Отправляем клиенту ошибку 500
            http.Error(w, "Internal Server Error", http.StatusInternalServerError)
            }
        }()

        // Вызываем следующий обработчик
        next.ServeHTTP(w, r)
  })
}

// Пример обработчика, где может произойти паника
func riskyHandler(w http.ResponseWriter, r *http.Request) {
    panic("Что-то пошло не так!") // Искусственно вызываем панику
}

// Главная функция
func main() {
    // Создаём маршрутизатор
    mux := http.NewServeMux()

    // Регистрируем обработчик с паникой
    mux.HandleFunc("/", riskyHandler)

    // Заворачиваем маршрутизатор в middleware для обработки паники
    recoveryServer := recoveryMiddleware(mux)

    // Запускаем сервер
    fmt.Println("Сервер запущен на порту :8080")
    http.ListenAndServe(":8080", recoveryServer)
}
```

**Объяснение логики:**

1. **Обработчик запросов (`riskyHandler`):**
   - Искусственно вызывает панику с помощью `panic("Что-то пошло не так!")`.

2. **Middleware (`recoveryMiddleware`):**
   - Заворачивает все обработчики запросов.
   - Если внутри обработчика произошла паника, `recover()` перехватывает её.

3. **После перехвата паники:**
   - Паника логируется: выводится сообщение о проблеме.
   - Клиенту возвращается ответ с кодом `500 Internal Server Error`.

4. **Программа продолжает работать:**
   - Другие запросы обрабатываются, несмотря на ошибки в одном из обработчиков.

**Тестирование:**

1. Запустите сервер: `go run main.go`.
2. Перейдите в браузере на `http://localhost:8080/`.

**Вывод в консоли:**

```bash
Сервер запущен на порту :8080
Перехвачена паника: Что-то пошло не так!
```

**Ответ клиенту:**

```bash
Internal Server Error
```

**Итоги:**

1. **`recover()`** позволяет перехватывать и обрабатывать панику, предотвращая аварийное завершение программы.
2. **Применение в реальной жизни:**
   - Обработка ошибок в критических местах (деление на ноль, индексация вне границ).
   - Перехват паники в HTTP-серверах, чтобы сохранить работу приложения.

---

## Как функция обрабатывает разные типы данных

> [*---> вернуться списку тем*](#навигация-по-темам)

В Go **все аргументы передаются по значению**, то есть функция получает копию переданного значения. Однако то, что именно копируется, зависит от типа переданного значения.

Как работают копии в зависимости от типа:

### 1. **Простые типы (int, float, string, bool, etc.):**

- **Копируется значение.**
- **Адрес ячейки памяти не передаётся.**
- Изменения внутри функции не затрагивают оригинальную переменную, так как функция работает с копией.

**Пример:**

```go
func modifyValue(val int) {
    val = 42 // Изменение копии
}

func main() {
    num := 10
    modifyValue(num)
    fmt.Println(num) // Вывод: 10
}
```

---

### 2. **Массивы ([N]T):**

- **Копируется весь массив (данные, не адрес).**
- **Адрес ячейки памяти не передаётся.**
- Изменения внутри функции влияют только на копию массива, а не на оригинал.

**Пример:**

```go
func modifyArray(arr [3]int) {
    arr[0] = 42 // Изменение копии массива
}

func main() {
    arr := [3]int{1, 2, 3}
    modifyArray(arr)
    fmt.Println(arr) // Вывод: [1, 2, 3]
}
```

---

### 3. **Срезы (slices):**

- **Копируется структура среза.**
- Структура включает указатель на базовый массив, длину и ёмкость.
- **Адрес базового массива передаётся через указатель.**
- Изменения элементов среза внутри функции затрагивают базовый массив.
- Если срез расширяется (`append`) и превышает ёмкость, создаётся новый массив, и указатель в копии среза перенаправляется на этот новый массив.

**Пример:**

```go
func modifySlice(slice []int) {
    slice[0] = 42       // Изменяет базовый массив
    slice = append(slice, 99) // Создаёт новый массив, если ёмкость превышена
}

func main() {
    arr := []int{1, 2, 3}
    modifySlice(arr)
    fmt.Println(arr) // Вывод: [42, 2, 3]
}
```

---

### 4. **Мапы (map):**

- **Копируется указатель на карту.**
- **Адрес ячейки памяти передаётся.**
- Изменения внутри функции затрагивают оригинальную карту, так как карта работает по ссылке.

**Пример:**

```go
func modifyMap(m map[string]int) {
    m["key"] = 42 // Изменяет оригинальную карту
}

func main() {
    myMap := map[string]int{"key": 1}
    modifyMap(myMap)
    fmt.Println(myMap) // Вывод: map[key:42]
}
```

---

### 5. **Указатели (*T):**

- **Копируется указатель (ссылка).**
- **Адрес ячейки памяти передаётся.**
- Изменения по указателю внутри функции затрагивают оригинальную переменную.

**Пример:**

```go
func modifyPointer(ptr *int) {
    *ptr = 42 // Изменяет оригинальное значение
}

func main() {
    num := 10
    modifyPointer(&num)
    fmt.Println(num) // Вывод: 42
}
```

---

### 6. **Структуры (struct):**

- **Копируется вся структура (данные, не адрес).**
- **Адрес ячейки памяти не передаётся.**
- Изменения внутри функции затрагивают только копию структуры.

Однако, если структура содержит поля типа **срезов, карт или указателей**, изменения этих полей затронут оригинальные данные, так как они работают по ссылке.

**Пример:**

```go
type Person struct {
    Name string
    Age  int
}

func modifyStruct(p Person) {
    p.Name = "John" // Изменяет копию структуры
}

func main() {
    person := Person{Name: "Alice", Age: 30}
    modifyStruct(person)
    fmt.Println(person.Name) // Вывод: Alice (оригинал не изменён)
}
```

---

| Тип          | Копируется            | Адрес памяти передаётся | Поведение при изменении                                |
|--------------|-----------------------|--------------------------|-------------------------------------------------------|
| Простые типы | Значение              | Нет                      | Изменения видны только в копии.                      |
| Массивы      | Весь массив           | Нет                      | Изменения видны только в копии.                      |
| Срезы        | Указатель, длина, ёмкость | Да                      | Изменение элементов влияет на базовый массив.        |
| Мапы        | Указатель на карту    | Да                      | Изменения влияют на оригинальную карту.              |
| Указатели    | Указатель             | Да                      | Изменения влияют на оригинальное значение.           |
| Структуры    | Вся структура         | Нет                      | Изменения видны только в копии, за исключением ссылочных полей. |

---

## Ссылки и указатели

> [*---> вернуться списку тем*](#навигация-по-темам)

### Указатель - `&`, Ссылка на память - `*`  

`&` (амперсанд) и `*` (звездочка) — это операторы, используемые для работы с указателями в Go. Они позволяют работать с адресами и содержимым ячеек памяти.

**ВАЖНО!** У `const` забрать адрес не получится

### Оператор `&`

Оператор `&` — взять адрес переменной (указатель).

`&` (указатель) используется для получения адреса памяти, в которой хранится значение переменной.

Логика:

- При использвании `&x`, Go возвращает **указатель** (адрес в памяти), где хранится значение переменной `x`.
- Указатель — это “ссылка” на ячейку памяти, а не само значение.

**Пример:**

```go
package main

import "fmt"

func main() {
    x := 42               // Создаем переменную x, значение = 42
    ptr := &x             // Берем адрес переменной x
    fmt.Println(ptr)      // Вывод адреса (например, 0xc000014080)
}
```

- Здесь `ptr` содержит адрес переменной `x` в памяти (например, `0xc000014080`).
- Важно: `ptr` указывает, где находится `x`, но не хранит значение 42.

### Оператор `*`

Оператор `*` — разыменование (получение значения из адреса)

- используется для доступа к значению, которое хранится по адресу, на который указывает указатель.

Логика:

- При использвании `*ptr`, Go “идет” **по адресу**, указанному в `ptr`, и возвращает значение, хранящееся там.

**Пример:**

```go
package main

import "fmt"

func main() {
    x := 42               // Создаем переменную x, значение = 42
    ptr := &x             // Берем адрес переменной x
    fmt.Println(*ptr)     // Разыменуем указатель, получаем значение: 42
}
```

- Здесь `*ptr` возвращает значение 42, которое хранится по адресу, на который указывает `ptr`.

### Связь `&` и `*`

- `&` создаёт указатель (получает адрес переменной).
- `*` работает с этим адресом, чтобы получить или изменить значение.

**Пример:**

```go
package main

import "fmt"

func main() {
    x := 10               // Создаем переменную x
    ptr := &x             // Получаем указатель на x
    fmt.Println(*ptr)     // Разыменуем ptr: 10

    *ptr = 20             // Изменяем значение по адресу ptr
    fmt.Println(x)        // Теперь x = 20
}
```

**Объяснение:**

 1. `ptr := &x` — `ptr` теперь содержит адрес `x`.
 2. `*ptr = 20` — Go идёт по адресу `ptr` и записывает в ячейку памяти значение 20.
 3. `x` обновляется автоматически, так как `ptr` указывает на его ячейку памяти.

#### **Пример из реальной практики в `func()`:**

При передачи переменной в `func` создается копия передаваемой **переменной**(используется новая ячейка памяти) и операции в функции производятся именно с копией.

Для работы с исходной **переменной** необходимо передавать ее с помощью ссылки(`&`), а в функции прописываем, что принимаем ссылку на ячейку памяти данной переменной (`*`) для последующей работы с ней.

Указатели полезны для изменения значений внутри функций (передача по ссылке):

```go
package main

import "fmt"

func updateValue(ptr *int) {
    *ptr = 100 // Изменяем значение по указателю
}

func main() {
    x := 42
    fmt.Println("До:", x) // 42

    updateValue(&x)       // Передаем адрес x
    fmt.Println("После:", x) // 100
}
```

**Объяснение:**

 1. `&x` передаёт адрес переменной `x` в функцию.
 2. Внутри функции `updateValue` используется `*ptr`, чтобы изменить значение `x`.
 3. Это позволяет изменять переменную прямо в её памяти.

#### **ВАЖНО О `slice`**

При работе с `slice` нет небходимости передавать ссылку, так как при перелачи `slice` в `func` передается ссылка на массив из которого образован `slice` и все операции в теле `func` происходят с массивом, на который ссылается `slice`.

```go
func main () {
    message := "Text"

    changeMessage(&message) // referencing - передаем ССЫЛКУ на адрес в памяти переменной message

    fmt.Println(message)
}

func changeMessage(message *string) {
    *message += " is new" // dereferencing - обращаемся к области памяти переменной message
    fmt.Println(message)
}

// changeMessage(message) - выведет "Text is new"
// fmt.Println(message) - выведет "Text is new" 
// функция поменяла переменную message
```

#### Пример работы с указателями в структурах данных

Есть структура описывающаю польлзователя:

````go
type Person struct {
  Name string
  Age int
  lastVisited time.Time
}  
````

В поле `lastVisited` нужно сохранять дату последнего посещения.

Без указателей функция выглядела бы примерно так:

````go
func GetPersonWithLastVisited(p Person) Person {
  p.lastVisited = time.Now() // time.Now() возвращает текущее время
    return p
}

// использование в другом пакете
p := Person{
  Name: "Alex",
  Age: 25,
}
p = GetPersonWithLastVisited(p)
````

C указателями всё становится проще:

````go
func UpdatePersonWithLastVisited (p *Person )  {
  p.lastVisited = time.Now() 
} 

// использование в другом пакете
p := Person{
  Name: "Alex",
  Age: 25,
}
UpdatePersonWithLastVisited(&p)
````

Здесь в функцию был передан указатель на переменную, что позволило изменить её поле без дополнительного копирования. С другой стороны, если функция не изменяет передаваемые ей параметры, то лучше не использовать указатели, а передавать переменные по значению.

---

## Массив

> [*---> вернуться списку тем*](#навигация-по-темам)

Массив — это последовательность фиксированной длины, состоящая из элементов одного типа.  

```go
var lastWeekTemp [7]int{1, 2, 3, 4, 5, 6, 7} // [1 2 3 4 5 6 7]
// {1 2 3 4 5 6 7} - элементы массива 
// [7] - длина массива (len)
```

**Основная проблема при присваивании `:=` массивов - массив полностью копируется.**

Изменить элемент массива можно по индуксу `numbers[0] = 9`

### Одномерный массив

Пример объявления/инициализации массива:

````go
var lastWeekTemp [7]int // [0 0 0 0 0 0 0]

someText := [4]string{"blue coral", "staghorn coral", "pillar coral", "elkhorn coral"} // [blue coral staghorn coral pillar coral elkhorn coral]

thisWeekTemp := [7]int {-3,5,7} // [-3 5 7 0 0 0 0]

rgbColor := [3]uint8 {255, 255, 128} // [255 255 128]

rgbColor := [...]uint8{255, 255, 128} // [255 255 128] len = 3
````

Так же существуют **Многомерные массивы** `var thisMonthTemp [4][7]int`

#### Обход значений массива

Оператор `range` на каждой итерации возвращает индекс и значение следующего элемента в массиве.

Конструкция `for range`, которая позволяет обойти элементы массива последовательно, не используя дополнительные переменные:

````go
var weekTemp = [7]int{5, 4, 6, 8, 11, 9, 5} 

sumTemp := 0

for _, temp := range weekTemp {
    sumTemp += temp
}

average := sumTemp / len(weekTemp)
````

**ВАЖНО!** Для изменения порядка подхода необходимо применять цикл `for`

---

## Слайс

> [*---> вернуться списку тем*](#навигация-по-темам)

Слайс (Slice)

[Адрес `Slice` в памяти при работе с `func`](#важно-о-slice)

Слайс — это динамический массив, который может изменять свой размер во время выполнения программы. Он представляет собой более гибкую структуру данных по сравнению с обычными массивами, так как не имеет фиксированного размера.

### Создание slice

- Слайс можно инициализировать несколькими способами:

````go
// 1. Создание слайса через литерал
var s1 = []int{1, 2, 3, 4} // не указывается размер массива

// 2. Создание пустого слайса заданной длины
var s2 = make([]int, 5) // слайс длиной 5, все элементы инициализированы нулями

// 3. Создание слайса с заданной длиной и емкостью
var s3 = make([]int, 5, 10) // длина 5, емкость 10
````

- Получение слайса из массива с помощью [:]:

````go
arr := [5]int{1, 2, 3, 4, 5}
s := arr[1:4]  // Слайс с элементами 2, 3, 4 - последний элемент 5 не добавляется
o := arr[:]    // Слайс с элементами 1, 2, 3, 4, 5
````

[Разница между `[:]` и `copy()` (таблица)](#как-случайно-не-изменить-исходный-слайс)

---

### Структура slice

```go
arr := [5]int{1, 2, 3, 4, 5}
// values - {1, 2, 3, 4, 5}
// len - [5]
// cap(capacity) - 5
```

**Слайс имеет структуру:**

- `ptr` (**указатель** на первый элемент  **"базового" массива**) — это **ссылка** на первый элемент **"базового" массива**.
  - непосредственно в слайсе **НЕ хранятся** элементы последовательности , они находятся в **"базовом" массиве**;
  - первый элемент слайса **может НЕ совпадать** с первым элементом **"базового" массива**
- `len` (длина слайса) - это **количество элементов** в слайсе.  
  - с помощъю `len` определяется последний используемый элемент **"базового" массива** в слайсе.
- `cap` (ёмкость слайса) — это количество элементов, **которое влезает в базовый массив**.
  - в пределах данной емкости выделение новой памяти не требуется. Если привысить ёмкость, то выделяется новая память на хранниние **обновленного "базового" массива**.

---

### **ВАЖНЫЕ нюансы при работе с `slice`:**

- при создании слайса из уже имеющегося, последний элемент не будет включен в слайс, за ислючением полоного копирования в слайс:

    ```go
    m := [5]int{1, 2, 3, 4, 5}
    s := m[0:2]
    s1 := m[:] 

    fmt.Println(m) // [1 2 3 4 5] - базовый массив
    fmt.Println(s) // [1 2] - последний не входит
    fmt.Println(s1) // [1 2 3 4 5] - все элементы
    fmt.Println(reflect.TypeOf(m)) // [5]int
    fmt.Println(reflect.TypeOf(s)) // []int
    fmt.Println(reflect.TypeOf(s1)) // []int
    ```

- при изменении элементов в слайсе по индексу, будет изменен базовый массив, что повлечет изменения в каждом слайте, который связан с ним:

  ```go
    m := [5]int{1, 2, 3, 4, 5}
    s := m[0:2]
    s[0] = 4 // меняет первый элемент не только в слайсе, но и базовый массив
    s1 := m[:] // копирование только ссылки (ссылается на тот же базовый массив)

    fmt.Println(m) // [4 2 3 4 5] 
    fmt.Println(s) // [4 2] 
    fmt.Println(s1) // [4 2 3 4 5] 

- при применении `append()` новый элемент не только добавится в слайс, но и перезапишет элемент в базовом массиве:

   ```go  
    m := [5]int{1, 2, 3, 4, 5}

    s := m[0:2]
    s = append(s, 100)
    s1 := m[:]

    fmt.Println(m) // [4 2 100 4 5] 
    fmt.Println(s) // [4 2 100] 
    fmt.Println(s1) // [4 2 100 4 5] 
    ```

- при применеии `append()` к слайсу для добавления элемента за пределы `cap` (емкости), будет полностью скопирован базовый массив. Если стрый массив ни где не используется его соберет Garbage Collector(сборщик мусора).

[Видео - **"Как устроен Slice в GO"**](https://www.youtube.com/watch?v=10LW7NROfOQ)

---

### Best practices

#### Проверка слайса на пустоту

Проверка пустой слайс или нет с сравнением с `nil` а с `len` длиной слайса:

```go
var list []int
fmt.Println(len(list) == 0) // true
fmt.Println(list== nil)     // true - неправильное сравнение

list = []int
fmt.Println(len(list) == 0) // true
fmt.Println(list == nil)    // false - неправильное сравнение
```

#### Аллокация памяти для слайса

Если известен размер итогового слайса тогда неодбходимо аллоцировать под него память.

```go
oldSlice := []int{1, 2, 3, 4}
newSlice := make([]int, len(oldSlice))       // аллокация
newestSlice := make([]int, 0, len(oldSlice)) // аллокация
```

#### Как случайно не изменить исходный слайс

Если нужно изменить переданный слайс, необходимо создать его **копию**.

Копирование с помощью `[:]` и функции `copy()` различаются по своей сути и поведению.

Ключевые различия:  

|Способ | Копирует данные? | Независимость от оригинала | Применение |  
|-----------|-------------|-----------|----------|  
| `[:]` | Нет (только ссылку) | Нет | Для создания нового представления на тот же массив. |  
| `copy()` | Да | Да | Для создания независимой копии среза. |

#### Как правильно пользоваться `append()`

Результат работы `append()` необходимо присваивать **той же переменной**.

```go
list := make([]int, 4, 4)
list = append(list, 1)   // верное использование
list2 = append(list, 1)  // НЕ верное использование
```

---

### Многомерный slice

````go
seaNames := [][]string{{"shark", "octopus", "squid", "mantis shrimp"}, {"Sammy", "Jesse", "Drew", "Jamie"}}

fmt.Println(seaNames[1][0]) // Sammy
````

#### Создание матрицы

```go
matrix = make([][]int, 10) // len 10

for x :=0; x<10; x++ {
    matrix[x] = make([]int, 10)
    for y :=0; y<10; y++{
        matrix[y][x] = x 
    }
    fmt.Println(matrix[x]) // матрица 10x10
}
```

### Добавление элементов в slice

Можно использовать встроенную функцию `append()`, чтобы добавить элементы в слайс.

````go
s := []int{1, 2}
s = append(s, 3, 4)
fmt.Println(s)  // [1, 2, 3, 4]
````

Если при добавлении нового элемента в slice увеличивает cap, то происходит **переалокация** (создается новый исходный массив в памяти с новым обновленным количеством элементов, а старый массив улетает в сборщик мусора)

### Создание нового слайса из существующего slice  

`[i:j]`, где `i` — индекс первого элемента нового слайса, а `j` — индекс следующего элемента, НЕ входящего в новый слайс.  

**ВАЖНО!** ссылка все еще ведет на основной слайс `weekTempArr`  

````go
weekTempArr := [7]int{1, 2, 3, 4, 5, 6, 7}
workDaysSlice := weekTempArr[:5]
weekendSlice := weekTempArr[5:]
weekTempSlice := weekTempArr[:]

fmt.Println(workDaysSlice, len(workDaysSlice), cap(workDaysSlice)) 
// [1 2 3 4 5] 5 7
fmt.Println(weekendSlice, len(weekendSlice), cap(weekendSlice)) 
// [6 7] 2 2 
fmt.Println(weekTempSlice, len(weekTempSlice), cap(weekTempSlice)) 
// [1 2 3 4 5 6 7] 7 7
````

### Объединение двух slice

Используется синтаксис расширения `...`

````go
someNum := []int{1}
newSomeNum := []int{100, 200}
newSomeNum = append(newSomeNum, someNum...)

fmt.Println(newSomeNum, len(newSomeNum), cap(newSomeNum)) // [100 200 1 2] [100 200 1] 3 4
````

````go
s = append(s[0:2], s[4:]...) 
````

### Копирование slice

1) Использование `copy()`:  
    Функция `copy(destination, source)` копирует элементы из слайса `source` в слайс `destination`.

    ````go
    a := []int{1, 2, 3, 4}

    b := make([]int, len(a)) // Создаём новый слайс той же длины, что и a
    с := make([]int, 2)      // Создаём новый слайс с длиной 2
    copy(b, a)               // Копируем элементы из a в b
    copy(c, a)               // Копируем элементы из a в c
    fmt.Println(a) // [1 2 3 4]
    fmt.Println(b) // [1 2 3 4]
    fmt.Println(c) // [1 2]
    ````

2) Использование `append()` для создания копии:

    ````go
    a := []int{1, 2, 3, 4}
    b := append([]int(nil), a...) // Копируем слайс a в новый слайс b

    fmt.Println(a) // [1 2 3 4]
    fmt.Println(b) // [1 2 3 4]
    ````

### Удаление последнего элемента slice

````go
s := []int{1, 2, 3}
if len(s) != 0 { // защищаемся от паники
    s = s[:len(s)-1]
}
fmt.Println(s) // [1 2]
````

### Удаление первого элемента slice

````go
s := []int{1,2,3}
if len(s) != 0 { // защищаемся от паники
    s = s[1:]
} 
fmt.Println(s) // [2 3]
````

### Удаление элемента slice с индексом `i`

````go
s := []int{1,2,3,4,5}
i := 2

if len(s) != 0 && i < len(s) { // защищаемся от паники
    s = append(s[:i], s[i+1:]...)
} 
fmt.Println(s) // [1 2 4 5]
````

### Сравнение двух slice

````go
s1 := []int{1,2,3}
s2 := []int{1,2,4}
s3 := []string{"1","2","3"}
s4 := []int{1,2,3}

fmt.Println(reflect.DeepEqual(s1,s2)) // false
fmt.Println(reflect.DeepEqual(s1,s3)) // false
fmt.Println(reflect.DeepEqual(s1,s4)) // true
````

### Добавление элементов в slice `for`

````go
var newSlice = []int{}

for i := 1; i < 101; i++ {
    newSlice = append(newSlice, i)
 } 
 // наполнит слайс newSlice от 1 до 100
````

### Альтернатива `range` добавления элементов в slice

```go
someSlice := make([]int, 100) // len = 100

var newSlice []int 
for i := range someSlice {
  newSlice = append(newSlice, i)
} 
// наполнит слайс newSlice от 1 до 100
```

### Сортировка slice в обратном порядке `for / range`

#### Вариант 1

````go
arr := []int{1, 2, 3, 4, 5}

for i, j := 0, len(arr)-1; i < j; i, j = i+1, j-1 {
    arr[i], arr[j] = arr[j], arr[i]
}
````

**Разбор логики обратной сортировки:**

1) Инициализация:

    - `i, j := 0, len(arr)-1`:
    - `i` инициализируется с `0` — это индекс первого элемента слайса.
    - `j` инициализируется с `len(arr)-1` — это индекс последнего элемента слайса.
    - Таким образом, `i` указывает на первый элемент слайса, а `j` — на последний.

2) Условие продолжения:

    - `i < j` — цикл будет выполняться, пока индекс `i` меньше индекса `j`.
    - Это важно, потому что начинаем с первого и последнего элемента и постепенно двигаемся к центру. Как только `i` становится больше или равным `j`, цикл остановится. Таким образом, элементы на “противоположных” концах слайса будут меняться местами, а когда они пересекутся, процесс завершится.

3) Шаги итерации:

    - `i, j = i+1, j-1` — на каждом шаге:
    - Увеличиваем `i` на `1`, т.е. двигаемся вправо.
    - Уменьшаем `j` на `1`, т.е. двигаемся влево.
    - Это позволяет сдвигать индексы навигации к центру слайса, чтобы обменять элементы, начиная с внешних и заканчивая центральными.

4) Меняем местами элементы:

    - `arr[i]`, `arr[j] = arr[j]`,`arr[i]`:
    - Меняются местами элементы с индексами `i` и `j`.
    - Таким образом, элементы с противоположных концов слайса обмениваются местами.

#### Вариант 2

````go
arr := []int{1, 2, 3, 4, 5}
dim = len(arr)

for i := range arr[:dim/2] {
    arr[i], arr[dim-i-1] = arr[dim-i-1], arr[i]
}
````

1) Начало цикла for: `for i := range arr[:dim/2] {`  
    - `arr[:dim/2]` — это срез слайса, который включает только первую половину элементов. Для слайса с 5 элементами это будет срез, включающий первые 2 элемента:
    - `arr[:dim/2]` эквивалентно `arr[:2]`, то есть срез `[]int{1, 2}`.
    - `dim/2` равно `5/2 = 2`, то есть срез будет включать индексы от `0` до `1`.
    - `for i := range arr[:dim/2]` — этот цикл будет перебирать индексы первых двух элементов слайса (то есть `i` будет принимать значения `0` и `1`):
    - На первой итерации `i = 0`.
    - На второй итерации `i = 1`.

2) Обмен элементов `arr[i], arr[dim-i-1] = arr[dim-i-1], arr[i]`  
    - `arr[i]` — это элемент с индексом i из первой половины слайса.
    - `arr[dim-i-1]` — это элемент с индексом, который находится на симметричной позиции в правой половине слайса. Например:
    - Если `i = 0`, то `arr[dim-i-1]` будет равно `arr[5-0-1] = arr[4]`.
    - Если `i = 1`, то `arr[dim-i-1]` будет равно `arr[5-1-1] = arr[3]`.
    Таким образом, элементы на позициях `i` и `dim-i-1` меняются местами.

Разбор по шагам:

На первой итерации `(i = 0)`:

- `arr[0]` (значение `1`) меняется местами с `arr[4]` (значение `5`).
- Результат: `arr = [5, 2, 3, 4, 1]`.

На второй итерации `(i = 1)`:

- `arr[1]` (значение `2`) меняется местами с `arr[3]` (значение `4`).
- Результат: `arr = [5, 4, 3, 2, 1]`.

ВАЖНО! Разернуть строку таким образом не получится, так как строка — неизменяемый тип данных. Нужно создать слайс рун из строки и развернуть его.

---

### Cheat-sheet github (SLICE)

[Go Slice Tricks Cheat Sheet](https://ueokande.github.io/go-slice-tricks/)

---

## Мапа - ассоциативный Массив

> [*---> вернуться списку тем*](#навигация-по-темам)

Мапа (Map)

Мапа (или словарь, [хеш-таблица](hash_cs_go.md)) — это структура данных, которая хранит пары “ключ-значение” `Map[key] = value` в **неупорядоченном** виде. Каждый ключ в мапе уникален, и с помощью ключа можно быстро получить соответствующее значение.

Мара имеет 3 простых действия:

- insert -> `insert(map, key, value)`- вставка.
- remote -> `delete(map, key)`- удаление.
- lookup -> `value = map[key]`- поиск элемента по ключу.  

**ВСЕ эти** операции всегда производится в среднем за константное время.

[Видео - **"Как устроен Map в GO"**](https://www.youtube.com/watch?v=P_SXTUiA-9Y)

**Создание мапы:**

- Инициализация мапы: Мапы можно создать с помощью функции `make()` или с помощью литерала.
- `map` — ссылочный тип (reference type), поэтому помимо объявления мапы необходима явная инициализация `:=`

Важные факты о **map**:

1. **ВАЖНО!**  
    Если известен размер итоговой мапы тогда неодбходимо аллоцировать под нее память сразу `make(map[type]type, size_map)`, иначе это замедлит работу кода.

    ```go
    var m1 = make(map[string]int, 1000) 
    ```

2. **ВАЖНО!**  
    В GO **невозможно** взять указатель на элемент **map**(`el := &map[key]`), это связано с механикой "эвакуации данных" из бакета. Так как после "эвакуации данных" мапы ссылка на старый бакет будет не актульна и данные уже будут в другой ячейки памяти([подробнее тут - конспект](mt_cs_GO.md)).  
3. **ВАЖНО!**  
    Внутри **map** данныые хранятся в НЕ упорядоченном виде, а `fmt.Println()` сама автоматически сортирует **map** у себя под капотом.

**Две переменные ссылочного типа могут указывать на один и тот же объект.**

Для простых типов это выглядит так:

```go
x := 5
y := x
x++
// x станет равен 6
// y останется равен 5
```

А для ссылочных типов — так:

```go
MyMap2 := MyMap1
MyMap1["foo"] = "bar"
// в MyMap2 тоже появится пара с ключом foo и значением bar

// если поменяем значение в MyMap2,
MyMap2["foo"] = "bazz"
// то изменится значение и в MyMap1
```

Пример с объявлением нового типа мапы:

```go
type MyMap map[string] string // новый тип MyMap, с key типа string и value типа string

var m1 MyMap            // объявление переменной m1 типа MyMap
m1 = make(MyMap, 5)     // инициализация с помощъю make() с cap=5 (не обязательно указывать емкость)

m1["foo"] = "bar"       // заполнение мапы 
```

Примеры с инициализаций без объявления нового типа:

```go
// 1. Создание пустой мапы с заданным типом ключа и значения
var m1 = make(map[string]int)

m1["Alice"] = 25  // заполнение мапы 
m1["Bob"]= 30     // заполнение мапы 

// 2. Инициализация мапы с элементами
m2 := map[string]int{"Alice": 25, "Bob": 30}

// 3. Создание пустой мапы
var m3 = map[string]int{}
```

`nil` — единственное значение, с которым можно сравнивать `map`. Сравнивать `map` друг с другом нельзя!

### Проверка, что map инициализирована

```go
var m map[string]string  // мапа объявлена, но не инициализирована  
if m != nil {            // если не проверить это условие,
    m["foo"] = "bar"     // то здесь можно получить panic
}
```

### Добавление и изменение элементов в map

Для добавления или изменения значений в мапе используется синтаксис с квадратными скобками:

```go
m := make(map[string]int)
m["age"] = 25  // Добавление элемента
m["age"] = 30  // Изменение значения
```

### Удаление элементов из map

Для удаления элемента из мапы используется встроенная функция delete():

```go
delete(m, "age")  // Удаление элемента с ключом "age"
```

### Проверка существования ключа в map

Чтобы проверить, существует ли ключ в мапе, можно использовать второй возвращаемый параметр:

```go
value, exists := m["age"] // часто пишут v, ok := m["age"]
if exists {               // bool значение 
    fmt.Println("Значение:", value)
} else {
    fmt.Println("Ключ не найден")
}
```

### Использование map в циклах `range`

```go
m := make(map[string]string)
m["foo"] = "bar"
m["bazz"] = "yup"
for k, v := range m {
    // k будет перебирать ключи,
    // v — соответствующие этим ключам значения
    fmt.Printf("Ключ %v, имеет значение %v \n", k, v)
}
```

---

## Объявление пользовательских типов

> [*---> вернуться списку тем*](#навигация-по-темам)

**Объявление пользовательскокго типа и как привести один тип к другому:**

```go
type Name string // объявление пользовательскокго типа
type Fruit string

var fruit Fruit
var name Name

fruit = "Apple"
name = Name(fruit) // так, после приведения типов, работает
```

Для пользовательских типов можно определять методы (как для классов в ООП).

```go
// декларация пользовательского типа
type MyType string
// декларация метода для пользовательского типа
func (mt MyType) MethodForMyType() {
    //логика метода
}
```

---

## Структуры

> [*---> вернуться списку тем*](#навигация-по-темам)

**Структуры (structs)** — это пользовательские типы данных, определяемые разработчиком, которые **объединяют связанные данные (поля или свойства) в единый объект** ( т.е. позволяет хранить вместе несколько переменных (данных), которые логически связаны друг с другом). Структуры могут иметь методы, позволяющие задавать их поведение.

**Структура бъединяет связанные данные (поля или свойства) в единый объект** - допустим нужно описать человека, то структура объединяет его свойства (например, имя, возраст и адрес) в одну сущность. Вместо того чтобы держать эти данные отдельно, содержится всё в одном "объекте".

Структуры создаются с помощью ключевых слов `type` и `struct`.

**Инициализация с объявлением пользовательского типа:**

```go
type Person struct { // cтруктура Person (описание объекта)
    Name string      // свойство Name
    Age  int    
    Email string 
}

// инициализация экземпляра/объета man с явно прописанным названием полей 
man := Person{
    Name: "Alex", 
    Age: 30,
    Email: "name_email@xyz.com", 
}

fmt.Printf("%+v\n", man) // для вывода вместе и именем поля структуры
```

- Экземпляры типа `Person` (например, `man`) можно создавать и использовать в разных частях программы.

**Инициализация анонимной структуры (редко используется):**

```go
man := struct {
    Name string      
    Age  int    
    Email string 
} {"Alex", 30, "name_email@xyz.com"}
```

- Поля структуры определяются только на месте её создания.
- Экземпляр `man` привязан к этой анонимной структуре, её нельзя использовать повторно в других частях программы.

**Доступ к полям структуры:**

```go
p := NewPerson("Иван", "ivan@yandex.ru", 2000, 12, 1)
fmt.Println(p.Name, p.Email)

p.Name = "Пётр"
fmt.Println(p.Name)

// Иван ivan@yandex.ru
// Пётр 
```

### Подходы к созданию экземпляров объектов `struct`

1. **Подход - Пустой объект**

    Все поля структуры при таком подходе принимают значения по умолчанию.

    ```go
    p := Person{}
    // или
    var p Person
    ```

    Подход применяют:

    - когда экземпляр не требует специальной инициализации и может быть использован дальше по коду;
    - когда для инициализации полей нужны дополнительные условия и данные, то есть выставление значений конкретных полей будет следовать ниже по коду.

2. **Подход - Неявное указание значений полей**

    При таком подходе перечисляют значения для всех полей структуры, используя литералы либо значения внешних переменных.

    ```go
    date := time.Date(2000, 12, 1, 0, 0, 0, 0, time.UTC)
    p := Person{"Иван", "ivan@yandex.ru", date}
    ```

    Требования:

    - Нужно перечислить все поля объекта.
    - Порядок следования аргументов инициализатора должен совпадать с порядком описания полей структуры. Если поставить поле `Email` на первое место в описании `type Person struct`, инициализация экземпляра выше будет некорректна (с точки зрения логики, но не компилятора).  

    Подход применяют:

    - когда нужно явно указать значения всех полей объекта;
    - когда вы уверены, что спецификация типа не будет меняться часто, иначе придётся вносить правки для каждого инициализатора объекта в коде.

3. **Подход - Явное указание значений полей**

    ```go
    p := Person{
        Name: "Иван", 
        Email: "ivan@yandex.ru"
    }
    ```

    Особенности:

    - этот подход отличается от первого опциональным указанием полей;
    - порядок указания полей не важен;
    - значения полей, которые не были использованы в инициализаторе (`dateOfBirth` в примере), примут значения по умолчанию.  

    Подход применяют:

    - почти всегда, так как он лишён ограничений, описанных выше.

4. **Подход - Конструктор**

    В Go нет синтаксиса конструкторов и деструкторов, но часто можно встретить аналог:

    ````go
    func NewPerson(name, email string, dobYear, dobMonth, dobDay int) (Person, error) {
        return Person{
            Name:        name,
            Email:       email,
            dateOfBirth: time.Date(dobYear, time.Month(dobMonth), dobDay, 0, 0, 0, 0, time.UTC),
        }
    }
    ````

    Некоторые правила, одобренные Go-сообществом:

    - имя функции конструктора пишут с префиксом `New`;
    - если конструктор производит валидацию аргументов, функция должна возвращать ошибку последним аргументом.

    Подход применяют:

    - когда нужно производить валидацию аргументов, чтобы построить логически правильный объект;
    - когда построение экземпляра объекта требует дополнительных действий, например, подключения к базе данных.

## summary - ООП в Go

1. [**Объекты и классы:**](#ооп---объекты---структуры)
   - Структуры в Go выполняют роль классов, объединяя данные и методы.
2. [**Инкапсуляция:**](#ооп---инкапсуляция)
   - Достигается через экспортируемые и неэкспортируемые поля/методы.
3. **Наследование:**
   - Заменяется встраиванием (композицией).
4. [**Полиморфизм:**](#ооп---полиморфизм---интерфейсы)
   - Реализуется через интерфейсы.
5. **Лёгкость и минимализм:**
   - Go использует принципы ООП, но без перегрузки синтаксиса (нет явного наследования или ключевых слов вроде `class`).

## ООП - объекты - структуры

> [*---> вернуться списку тем*](#навигация-по-темам)

Структуры - `struct`

**Структуры в контексте ООП:**

**В контексте ООП**, структуры выполняют роль классов (аналогично тому, как это реализовано в Python), объединяя данные и методы, связанные с ними. Однако, в отличие от традиционных классов в ООП, структуры в Go используют **композицию вместо наследования**, а поведение добавляется через методы, связанные со структурой.

**Композиция** означает, что вместо создания нового типа (класса или структуры), который "наследует" поведение от другого типа, **встраиваем (компонуем) один тип внутри другого**.

### Ключевые аспекты структур в контексте ООП

1. **Структуры = Классы без наследования:**
   - Структуры объединяют данные (поля) и поведение (методы).
   - Вместо прямого наследования Go использует **встраивание (embedding)** для повторного использования кода.

2. **Методы для структур:**
   - Методы позволяют привязать функции к структуре, реализуя поведение (аналог методов класса).

3. **Отсутствие наследования:**
   - Go не поддерживает прямое наследование, но предлагает встраивание для создания "композиции объектов".

4. **Интерфейсы:**
   - Поведение структур описывается через интерфейсы, которые позволяют структурам "обещать", что они реализуют определённые методы.

5. **Инкапсуляция:**
   - Инкапсуляция достигается через использование **заглавных (экспортируемых)** и **строчных (неэкспортируемых)** имён полей и методов.

### Методы струкруры

**Метод структуры** имеет формат:

```go
func (receiver Type) name_method(params) (types_return) {
    body_method
}
```

- **`(receiver Type)`** — указание **приёмника** (receiver):
  - `receiver` — это переменная, через которую метод получает доступ к экземпляру структуры.
  - `Type` — тип структуры, к которой привязан метод.
  - Если нужен указатель, используется `*Type`.
    - `reciever Type` - приемник по значинию (передаваемый объект копируется) - вносит изменения только в копии внутри метода.
    - `reciecer *Type` - приемник по ссылке (передается ссылка в памяти на объект) - вносит изменения в оригинал объекта.
- **`name_method`** — имя метода.
- **`params`** — параметры метода (необязательно).
- **`types_return`** — возвращаемый тип (или типы) (необязательно).

**Пример метода структуры:**

```go
type Person struct { // Определение структуры
    Name string
    Age  int
}

// Метод структуры Person
func (p Person) Greet() string { // p Person — приёмник типа Person
    return fmt.Sprintf("Hello, my name is %s, and I am %d years old.", p.Name, p.Age)
}
```

**Пример метода с указателем:**

```go
type Person struct { // Определение структуры
    Name string
    Age  int
}

// Метод для изменения возраста
func (p *Person) SetAge(newAge int) { // p *Person — указатель на Person
    p.Age = newAge
}
```

**Пример с Конструктором:**

```go
// Определение структуры Person (аналог класса)
type Person struct { // cтруктура Person (описание объекта)
    Name string      // свойство Name
    Age  int    
    Email string 
}

// объявдяем метод Конструктор
func NewPerson (name string, age int, email string) Person { 
    return Person{
        Name = name,
        Age = age,
        Email = email,
    }
}

func main () {
    man := NewPerson("Alex", 30, "name_email@xyz.com")
}
    

fmt.Printf("%+v\n", man) // для вывода вместе и именем поля структуры
```

**Пример с методом изменения объекта:**

```go
package main

import "fmt"

// Определение структуры Person (аналог класса)
type Person struct {
    Name string
    Age  int
}

// Метод структуры Person
func (p Person) Greet() string {
    return fmt.Sprintf("Hello, my name is %s, and I am %d years old.", p.Name, p.Age)
}

// Метод для изменения возраста
func (p *Person) SetAge(newAge int) {  // используется ссылка памяти на передаваемый объект
    p.Age = newAge
}

func main() {
    john := Person{Name: "John", Age: 30}

    // Вызов метода Greet
    fmt.Println(john.Greet())

    // Изменение возраста через метод SetAge
    john.SetAge(35)
    fmt.Println(john.Greet())
}
```

Объяснение:

1. Поля структуры:
   - `Name` и `Age` — это свойства объекта (экспортируемые, так как начинаются с заглавной буквы).

2. Методы:
   - Метод `Greet()` возвращает строку с приветствием.
   - Метод `SetAge()` изменяет возраст. Он использует **указатель (pointer receiver)**, чтобы изменять значение оригинальной структуры.

---

### Композиция и встраивание

Вместо наследования Go использует **встраивание (embedding)**, позволяя одной структуре включать другую.

#### Пример

```go
package main

import "fmt"

// Основная структура
type Person struct {
    Name string
}

// Структура Student, встраивающая Person
type Student struct {
    Person
    Grade string
}

func main() {
    student := Student{
        Person: Person{Name: "Alice"},
        Grade:  "A",
    }

    // Прямой доступ к полю Name из встроенной структуры
    fmt.Println("Name:", student.Name)

    // Прямой доступ к методу Greet(), если он реализован у Person
    fmt.Println("Grade:", student.Grade)
}
```

**Вывод:**

```bash
Name: Alice
Grade: A
```

---

## ООП - полиморфизм - интерфейсы

> [*---> вернуться списку тем*](#навигация-по-темам)

Интерфейсы - `interface`

В Go полиморфизм достигается через **интерфейсы**.

[Стятья на Хабр](https://habr.com/ru/articles/856272/)

>*"Если это выгдят как утка, плавает как утка и крякает как утка, то это, вероятно,  и есть утка." - Утиная типизация*

Интерфейс — это набор методов, которые могут быть реализованы типом. Иными словами, интерфейс — описание того, что может сделать тип.

Интерфейсы — это способ описания поведения объектов. Интерфейс говорит: "Я принимаю любой объект, который умеет выполнять определённые действия (реализует набор методов)". Это позволяет писать гибкий и модульный код.

Если тип имеет методы, описанные в интерфейсе, то этот тип удовлетворяет интерфейсу.
Любой тип, соответвует **пустому** интерфейсу.

**Интерфейс** имеет формат:

```go
type MyInterface interface {
    Method1(int) int
    Method2(a string) string
    //.... может быть ещё много методов
}
```

Объяснение:

1. `type MyInterface interface { ... }` — определение интерфейса:
   - **`MyInterface`** — имя интерфейса, определяемого пользователем.
   - **`interface`** — ключевое слово, обозначающее интерфейс.

2. Методы в интерфейсе:
   - Интерфейс задаёт набор методов, которые должны быть реализованы любым типом, чтобы считаться "совместимым" с этим интерфейсом.
   - **Интерфейсы не содержат реализации методов**, они только описывают их сигнатуры.

3. `Method1(int) int`:
   - **`Method1`** — имя метода.
   - **`(int)`** — параметры метода. В данном случае метод принимает один аргумент типа `int`.
   - **`int`** — возвращаемый тип метода.

4. `Method2(a string) string`:
   - **`Method2`** — имя метода.
   - **`a string`** — параметр метода с именем `a`, тип — `string`.
   - **`string`** — возвращаемый тип метода.

Сравнение с методом структуры:

- Методы в интерфейсе задают **только сигнатуры** (имя, параметры, возвращаемый тип)(это список "что нужно сделать").
- Реализация методов происходит в типе, который "реализует" интерфейс.

### Примеры интерфейсов

1. Пример простого интерфейса:

    ```go
    type MyInterface interface {
        Method1(int) int
        Method2(a string) string
    }

    // Структура, которая будет реализовывать интерфейс
    type MyStruct struct{}

    // Реализация метода Method1
    func (m MyStruct) Method1(x int) int {
        return x * x
    }

    // Реализация метода Method2
    func (m MyStruct) Method2(a string) string {
        return "Hello, " + a
    }

    func main() {
        var obj MyInterface = MyStruct{} // MyStruct реализует MyInterface

        fmt.Println(obj.Method1(5))     // Вывод: 25
        fmt.Println(obj.Method2("Go"))  // Вывод: Hello, Go
    }
    ```

2. Пример интерфейса с описанием:

    ```go
    package main

    import "fmt"

    // Определяем интерфейс Storage
    type Storage interface {
        Save(data string) // Метод для сохранения данных
    }

    // Реализация интерфейса для файловой системы
    type FileStorage struct{}

    func (f FileStorage) Save(data string) {
        fmt.Println("Сохраняю в файл:", data)
    }

    // Реализация интерфейса для базы данных
    type DatabaseStorage struct{}

    func (db DatabaseStorage) Save(data string) {
        fmt.Println("Сохраняю в базу данных:", data)
    }

    // Функция, работающая с интерфейсом Storage
    func StoreData(s Storage, data string) {
        s.Save(data)
    }

    func main() {
        fileStorage := FileStorage{}
        dbStorage := DatabaseStorage{}

        StoreData(fileStorage, "Пример данных для файла")
        StoreData(dbStorage, "Пример данных для базы данных")
    }
    ```

    Как работает интерфейс?

    - Интерфейс `Storage` позволяет работать с любым хранилищем данных, которое реализует метод `Save(data string)`.
    - Реализованы два типа: `FileStorage` и `DatabaseStorage`.
    - Функция `StoreData` работает с интерфейсом `Storage`, не завися от конкретной реализации.

3. Пример интерфейся с вычислением площади:

```go
type Shape interface {
    Area () float32     // метод Area() есть у обоих струтур
}

type Square struct {
    sileLenght float32
}

func (s Square) Area() float32 {    // метод Square
    return s.siteLenght * s.siteLenght
}

type Circle struct {
    radius float32
}

func (c Circle) Area() float32 {    // метод Circle
    return c.radius * c.radius * math.Pi
}

func main() {
    square := Square{5}
    circle := Circle{8}

    printShapeArea(square)
    printShapeArea(circle)
}

func printShapeArea(shape Shape) { // передается интерфейс типа Shape
    fmt.Println(shape.Area())      // вызов метода Area()
}
```

### type assertion (утверждение типа) интерфейс

`type assertion` — это конструкция, которая проверяет, является ли значение в интерфейсе `i` типом `string`

1. **Пример `type assertion` ознакомительный:**

    ```go
    func printInterface(i interface{}) {
        str, ok := i.(string)
        if ok! {    // Проверяем, успешно ли выполнено приведение
            fmt.Println("interface not sring")
            return
        }
        fmt.Println(len(str))
    }

    func main() {
        printInterface(22)      // interface not sring
        printInterface("hello") // 5
    }
    ```

2. **Пример `type assertion` из практики:**

    ```go
    func processValue(v interface{}) {
        if str, ok := v.(string); ok {
            fmt.Println("String value:", str)
        } else if num, ok := v.(int); ok {
            fmt.Println("Integer value:", num)
        } else {
            fmt.Println("Unknown type")
        }
    }

    func main() {
        processValue("hello") // String value: hello
        processValue(42)      // Integer value: 42
        processValue(3.14)    // Unknown type
    }
    ```

### type swich интерфейс

`type switch` — это конструкция, которая позволяет определить **конкретный тип** значения, хранящегося в интерфейсе. В Go интерфейсы могут содержать значения разных типов, и `type switch` помогает узнать, к какому именно типу относится это значение.

1. **Пример `type switch`:**

    ```go
    package main

    import "fmt"

    func PrintType(value interface{}) {
        // Используем type switch для определения типа value
        switch v := value.(type) {
        case string:
            fmt.Printf("string: %s\n", v)
        case int:
            fmt.Printf("int: %d\n", v)
        case bool:
            fmt.Printf("bool: %t\n", v)
        default:
            fmt.Printf("unknown type: %T\n", v)
        }
    }

    func main() {
        PrintType("Hello")   // string: Hello
        PrintType(42)        // int: 42
        PrintType(true)      // bool: true
        PrintType(3.14)      // unknown type: float64
    }
    ```

    Объяснение:

    - `value interface{}`:
        - Параметр `value` имеет тип `interface{}`, что означает, что он может содержать значение любого типа.

    - `switch v := value.(type)`:
        - `value.(type)` используется для определения конкретного типа значения, содержащегося в интерфейсе.
        - Результат типа записывается в переменную `v`, которая используется внутри каждого блока `case`.

    - `case string`, `case int`, `case bool`:
        - В каждом `case` мы проверяем, является ли тип значения `string`, `int` или `bool`.
        - Внутри блока `case` переменная `v` автоматически получает значение с соответствующим типом.

    - `default`:
        - Если тип значения не соответствует ни одному из перечисленных `case`, выполняется блок `default`, где выводится тип значения (`%T`).

2. **Пример из практики: обработка различных типов данных**

    ```go
    package main

    import (
        "fmt"
    )

    func HandleData(data interface{}) {
        switch v := data.(type) {
        case string:
            fmt.Println("Обрабатываю строку:", v)
        case int:
            fmt.Println("Обрабатываю число:", v*2)
        case []int:
            fmt.Println("Обрабатываю срез чисел, сумма:", sum(v))
        default:
            fmt.Println("Неизвестный тип данных")
        }
    }

    func sum(nums []int) int {
        total := 0
        for _, n := range nums {
            total += n
        }
        return total
    }

    func main() {
        HandleData("Привет")          // Обрабатываю строку: Привет
        HandleData(10)                // Обрабатываю число: 20
        HandleData([]int{1, 2, 3, 4}) // Обрабатываю срез чисел, сумма: 10
        HandleData(3.14)              // Неизвестный тип данных
    }
    ```

### Агрегация интерфейсов

```go
// интерфейс, который агригирует другие интерфейсы
type Shape interface {  // имплиметирует интерфейсы ShapeWithAria и ShapeWithPerimetr
    ShapeWithAria
    ShapeWithPerimetr
}

type ShapeWithPerimetr interface {  // имплиметирует метод Perimetr()
    Perimetr() float32
}

type ShapeWithArea interface {  // имплиметирует метод Area()
    Area() float32     
}

type Square struct {
    sileLenght float32
}

func (s Square) Perimetr() float32 {
    return s.sideLenght * 4
}

func (s Square) Area() float32 {    // метод Square
    return s.sideLenght * s.siteLenght
}

type Circle struct {
    radius float32
}

func (c Circle) Perimetr() float32 {
    return c.radius 
}

func (c Circle) Area() float32 {    // метод Circle
    return c.radius * c.radius * math.Pi
}

func main() {
    square := Square{5}
    circle := Circle{8}

    printShapeArea(square)
    printShapeArea(circle)
}

func printShapeArea(shape Shape) { // передается интерфейс типа Shape
    fmt.Println(shape.Area())      // вызов метода Area()
    fmt.Println(shape.Perimetr())  // вызов метода Perimetr()
}
```

---

## ООП - инкапсуляция

> [*---> вернуться списку тем*](#навигация-по-темам)

Метод - `get/set`

**Инкапсуляция** в Go достигается с помощью видимости полей и методов:

- Поля и методы, начинающиеся с **заглавной буквы**, экспортируются (доступны вне пакета).
- Поля и методы, начинающиеся с **маленькой буквы**, неэкспортируемые (доступны только внутри пакета).

Таким образом, можно "скрыть" детали реализации и предоставить доступ только через специально определённые методы (**геттеры и сеттеры**).

**Сеттер** и **геттер** — это специальные методы, которые позволяют **управлять доступом** к полям объекта. Они используются для обеспечения безопасности, чистоты и контроля над данными объекта.

- **Геттеры** — для **получения** значений поля объекта.
- **Сеттеры** — для **изменения** значений поля объекта.

**Пример инкапсуляции:**

```go
package main

import "fmt"

// Person — структура с инкапсулированными полями
type Person struct {
    name string // Неэкспортируемое поле
    age  int    // Неэкспортируемое поле
}

// NewPerson — конструктор для создания экземпляра Person
func NewPerson(name string, age int) *Person {
    return &Person{name: name, age: age}
}

// GetName — геттер для поля name
func (p *Person) GetName() string {
    return p.name
}

// GetAge — геттер для поля age
func (p *Person) GetAge() int {
    return p.age
}

// SetName — сеттер для поля name
func (p *Person) SetName(newName string) {
    p.name = newName
}

// SetAge — сеттер для поля age
func (p *Person) SetAge(newAge int) {
    if newAge > 0 { // Простая валидация
        p.age = newAge
    } else {
        fmt.Println("Возраст должен быть положительным числом!")
    }
}

func main() {
    // Создаём объект Person через конструктор
    person := NewPerson("Alice", 25)

    // Используем геттеры для получения значений
    fmt.Println("Name:", person.GetName()) // Name: Alice
    fmt.Println("Age:", person.GetAge())   // Age: 25

    // Используем сеттеры для изменения значений
    person.SetName("Bob")
    person.SetAge(30)

    // Выводим обновлённые значения
    fmt.Println("Updated Name:", person.GetName()) // Updated Name: Bob
    fmt.Println("Updated Age:", person.GetAge())   // Updated Age: 30

    // Пробуем установить некорректный возраст
    person.SetAge(-5) // Возраст должен быть положительным числом!
}
```

Объяснение:

1. **Неэкспортируемые поля:**
   - Поля `name` и `age` начинаются с маленькой буквы, поэтому они доступны только внутри пакета `main`.
   - Это скрывает детали реализации от внешнего кода.

2. **Геттеры и сеттеры:**
   - Геттеры (`GetName`, `GetAge`) предоставляют доступ для чтения полей.
   - Сеттеры (`SetName`, `SetAge`) позволяют управлять изменением полей. При этом можно добавить проверку или другую логику, например, проверку корректности возраста.

3. **Контроль доступа:**
   - Поля нельзя изменять напрямую, что обеспечивает инкапсуляцию данных. Все изменения проходят через методы, где можно добавлять логику (например, валидацию).

---

## Пакеты и модули

> [*---> вернуться списку тем*](#навигация-по-темам)

### Пакеты

**Пакет** — это единица компиляции, пространства имён и импорта. Весь код на языке Go находится в каком-либо пакете.

**Пакет** — это набор файлов с исходным кодом, который находится в одной папке проекта. Пакеты позволяют логически разделить ваш проект на компоненты. Все элементы кода (типы, константы, переменные, функции) доступны внутри пакета, как если бы они были объявлены в одном файле. В каждом файле исходный код на языке Go должен начинаться с объявления пакета: ключевого слова `package` и имени пакета.

#### Как лучше называть пакет и его элементы

Вместо создания одного большого универсального пакета старайтесь разбивать код на мелкие пакеты и присваивать каждому из них понятное имя.  

1. Записывайте имя пакета строчными буквами. Хорошо, если оно будет коротким.
2. Подбирайте пакету уникальное имя в рамках репозитория.
3. Не пишите в имени пакета общие слова: `util`, `base`, `tools`, `lib`, `common`. Помните, что имя пакета будет использоваться в коде.
4. Не используйте множественное число. Но есть исключения: пакеты `strings`, `bytes`, `errors` в стандартной библиотеке Go названы так, чтобы избежать конфликта с типами. Иногда использовать множественное число допустимо — например, если нужно показать, что пакет `handlers` содержит несколько обработчиков.

#### Пути пакета

Кроме имени пакета, важно правильно выбрать директорию, где он будет храниться. Компилятор пойдёт по этому пути, чтобы произвести импорт.  
Модуль — это законченная библиотека или приложение, которое может содержать внутренние пакеты и импортировать внешние.

#### Экспорт

Любой элемент (тип, константа, переменная, функция) **является экспортируемым**, то есть доступным внешним пакетам для импорта, если его **имя начинается с большой буквы**.

````go
var ParsedString string

func Print (s string) {}

const Red = 3

type MyStruct struct {
    a int
}
````

Экспортируемые элементы представляют собой **внешний интерфейс** вашего пакета.

Также с особой осторожностью следует относиться к экспорту переменных: возможно, будет лучше сделать функции, меняющие ваши переменные, чтобы код не становился негибким и опасным. Вам будет труднее делать изменения в коде пакета, если внешний код использует переменные из вашего пакета.

#### Импорт

Чтобы один пакет мог использовать другой, его надо импортировать. Импорт пакета чем-то похож на аналогичный процесс в Python. Он выполняется с помощью ключевого слова `import`

При обращении к импортируемым объектам нужно указывать через точку имя пакета и имя элемента: `fmt.Println(...)`, `yaml.Marshal(...)`

##### Переименование импорта

Использования алиаса

````go
import (
    hl "github.com/yuin/goldmark-highlighting"
)
````

##### Порядок импорта

При компиляции программы компилятор начинает с пакета **main**. Если в **main** есть импорты каких-либо пакетов, то он переходит к ним и компилирует их, до тех пор пока не скомпилируются все необходимые пакеты для сборки программы.  
Затем компилятор компилирует пакет **main** и собирает основное приложение, а далее в процессе выполнения программы произойдёт следующее:

1. В том порядке, в котором пакеты были проимпортированы, будут инициализироваться переменные пакета.
2. После будут выполнены функции `init()` внутри каждого пакета. Функций `init()` может быть несколько, и они выполнятся в том порядке, в котором были объявлены.
3. И после их выполнения наступит очередь функции **main**

#### Организация кода

Существует подход, который называется `Standard Go Project Layout`. В нём код проекта организуется в виде следующих директорий:  

- `cmd`  

    Если в проекте будет несколько бинарных файлов, создайте для них поддиректории в `cmd`. Имена поддиректорий должны соответствовать именам исполняемых файлов.

    ````go
    - cmd
        - client
            main.go
        - server
            main.go
    ````

- `internal`

    Директория `internal` содержит внутренние пакеты Go-проекта. На уровне компилятора запрещён импорт таких пакетов извне родительской директории internal. Например, пакет `.../root/client/internal/a/b` можно импортировать только в файле дерева директорий, которые начинаются с `.../root/client`, и нельзя в `.../root/server` или другом репозитории.  

    Рекомендуется размещать в директории `internal` весь основной исходный код программы, разбитый на поддиректории с соответствующими пакетами. В зависимости от сложности проекта пакеты могут иметь разный уровень вложенности.

- `pkg`

    Директорию `pkg` определите для пакетов, которые можно использовать в других проектах. Предпочтительнее для публичных проектов заводить отдельные репозитории.

- `vendor`

    Директория `vendor` содержит внешние пакеты. C появлением в Go модулей все зависимости хранятся в кеше модуля. Поэтому директорию `vendor` можно использовать на старых версиях Go или в том случае, если вы хотите быть уверены, что все зависимости находятся внутри директории проекта.

- `test`

    Как правило, в каждом пакете есть один или несколько тестовых файлов `name_test.go`. Директорию `test` можно использовать для комплексного тестирования с привлечением дополнительных инструментов.

- `docs`

    Директория `docs` предназначена для ведения документации по проекту. Это может быть документация для пользователей или дополнение к документации, которую автоматически генерирует `godoc`.

##### Прочие директории

Вот ещё варианты директорий, которые встречаются в Go-проектах:

- `api` — дополнительные файлы для сервисов с API.
- `assets` — дополнительные файлы-ресурсы. Например, картинки.
- `build` — файлы для упаковки и непрерывной интеграции.
- `configs` — файлы конфигураций.
- `deployments/deploy` — файлы конфигураций и шаблоны для сервисов, операционных систем и контейнеров.
- `examples` — примеры использования приложений и библиотек.
- `sсripts` — скрипты для установки, настройки и других действий с проектом.
- `tools` — инструменты для поддержки проекта. Могут быть написаны на Go c использованием пакетов проекта.
- `website` — директория с файлами для веб-сайта проекта.
Это неполный список. Можно создавать директории с другими именами. Старайтесь давать такие имена, которые раскрывали бы назначение директории.

#### Связь пакетов и файловой системы

Если не пользоваться модулями, то путь для импорта пакета — это путь к директории пакета относительно `${GOPATH}/src`.

При установке компилятора он создаёт переменную окружения `GOPATH`, которая указывает путь к папке установки.

Переменные окружения — это переменные, которые хранятся в вашей операционной системе и доступны программам. Посмотреть список переменных окружения можно командой `go env`, какую-то конкретную — например, `go env GOPATH`, а изменить переменную окружения — через команду `go env -w <Имя переменной>=<новое значение>`.

Допустим, нужно создать пакет для какого-нибудь финансового проекта. Назовём его `finance`.
По мере написания кода этого пакета выясняется, что в разных местах требуются одни и те же математические функции. Тогда выносим их в отдельный подпакет `finmath`, после чего дерево пакетов в файловой системе будет выглядеть примерно так (названия файлов могут быть другие):

````bash
finance
├── money_calculation.go
└── finmath
    └── arithmetics.go
````

Если считать от GOPATH, то вот так:

````bash
GOPATH
└── src
    └── finance
        ├── money_calculation.go
        └── finmath
            └── arithmetics.go
````

Теперь можно импортировать пакеты `finance` и `finmath` по путям `"finance"` и `"finance/finmath"` соответственно:

````go
package main

import (
    "fmt"

    "finance"
    "finance/finmath"
)

func main() {
    fmt.Println(finance.GetMostRecentBill())
    fmt.Println(finmath.Add(1, 2))
}
````

Путь к пакетам, которые хостятся в системах контроля версий, обычно имеет вид `${GOPATH}/src/<VCS_URL>/<USER_NAME>/<REPO_NAME>`, а что касается, например, библиотеки тестирования `testify`, то `${GOPATH}/src/github.com/stretchr/testify`.

---

### Модули

По официальной документации, **модуль** — это коллекция пакетов с общими версионированием и релизным циклом. Модули могут загружаться либо напрямую из систем контроля версий, либо с модульных прокси-серверов.  
Проще говоря, это группа пакетов, которые хранятся и обновляются вместе. Даже ваше приложение будет являться модулем.

Метаинформация о модуле содержится в файле **go.mod** в корневой директории модуля. Полный список всех директив этого файла можно также найти в документации.

Метаинформация о модуле содержится в файле **go.mod** в корневой директории модуля. Полный список всех директив этого файла можно также найти в документации.

#### Создание модуля

Создадим новую директорию `ypmodule`:

```bash
mkdir ypmodule
cd ypmodule
```

Инициализируем модуль внутри директории стандартной утилитой `go mod`:

```bash
go mod init ypmodule
```

В директории создался файл **go.mod**, содержащий:

```bash
module ypmodule

go 1.17
```

Строка `module ypmodule` содержит путь импорта модуля — это префикс, относительно которого будут импортироваться все пакеты этого модуля. Например, чтобы импортировать пакет `somepackage` из модуля `ypmodule`, надо добавить в код строку:

```go
import "ypmodule/somepackage"
```

Следует отметить, что в большинстве случаев файл **go.mod** не редактируется вручную, а изменяется с помощью `go mod`.

Строка `go 1.17` указывает на версию Go, использованную при создании этого модуля.

Создадим в модуле пакет `calc` для работы с числами и поместим в него файл **math.go** с функцией сложения целых чисел.

```go
package calc

func AddInts(a, b int) int {
    return a + b
}
```

В примере для модуля `calc` создана отдельная директория. Но если не предполагается добавлять в модуль больше одного пакета, можно писать код прямо в директории с файлом **go.mod**.

Чтобы протестировать функциональность модуля, создадим рядом с `ypmodule` ещё один модуль — `main`. Файловая структура будет выглядеть так:

```bash
.
├── main
└── ypmodule
    ├── calc
    │   └── math.go
    └── go.mod
```

Для создания нового модуля выполним в `main` команду:

````bash
go mod init main
````

Создадим в новом модуле файл **main.go**, содержащий:

```go
package main

import (
    "fmt"

    "ypmodule/calc"
)

func main() {
    fmt.Println(calc.AddInts(1, 2))
}
```

Попробуем запустить функцию `main`. И получим ошибку:

```bash
main.go:6:2: package ypmodule/calc is not in GOROOT (/usr/local/go/src/ypmodule/calc)
```

Дело в том, что в файле **main/go.mod** не описано, где искать модуль `ypmodule`. Сначала Go пошёл в `GOROOT` и не обнаружил его. Затем Go увидел, что `ypmodule` не похож на URL, поэтому искать этот пакет в сети нет смысла.

Поскольку сейчас работаем с локальным модулем (то есть его код лежит только на нашей файловой системе), для определения его положения на локальном диске нужно воспользоваться директивой `replace`. После её добавления **файл main/go.mod** будет выглядеть так:

````bash
module main

go 1.17

// директивой replace указываем положение корня 
// модуля ypmodule относительно main/go.mod
replace ypmodule => ../ypmodule 
````

Так как `ypmodule` содержит внутри себя другие пакеты и зависимости, их тоже нужно указать.

Выполним команду `go get ypmodule`:

```bash
go get ypmodule

go get: added ypmodule v0.0.0-00010101000000-000000000000
```

В **go.mod** появилась строка:

```bash
require ypmodule v0.0.0-00010101000000-000000000000 // indirect
```

Она указывает, какую конкретно версию модуля `ypmodule` будет использовать `main` при сборке. Комментарий `// indirect` подсказывает, что сам пакет `ypmodule` в коде не импортируется, только `calc`.  

Запустим `main` ещё раз. Ура, всё заработало! Первые локальные модули успешно нашли друг друга.

### Внешние зависимости

Внешними зависимостями называются пакеты, не входящие в состав стандартной библиотеки.

В Go есть два способа загрузить пакеты:

- вручную установить утилитой `go get`;
- использовать список зависимостей в **go.mod**.

#### Установка пакетов вручную утилитой `go get`

В случае использования `go get` установка стороннего пакета выглядит так:

```bash
go get github.com/username/packagename
```

Утилита go get сходит на `<https://github.com/username/packagename>` и скачает требуемый пакет, если он был найден по переданному URL. Если система контроля версий поддерживает несколько протоколов, Go по очереди попробует все. Например, в случае гита он попробует `https://` и `git+ssh://`.  

После этого скачанные данные будут помещены в `GOPATH/src/username/packagename`.

#### Установка зависимостей из **go.mod**

Cистема модулей позволяет явно прописать список зависимостей проекта. Для этого используется директива `require`. После запуска кода Go автоматически скачает пакеты, перечисленные в блоке `require`, и закеширует их в директории `$GOPATH/pkg/mod`.

Например, если в модуле есть единственная зависимость от библиотеки `github.com/stretchr/testify`, то go.mod будет иметь вид:

```bash
module somemodule

go 1.16

require github.com/stretchr/testify v1.7.0
```

Также будет создан специальный файл **go.sum**, обеспечивающий стопроцентную воспроизводимость запусков. Он содержит хеш-суммы всех модулей и тем самым гарантирует воспроизводимую установку модулей на разных окружениях.

Зачастую не нужно вручную прописывать зависимости в **go.mod**. Go может автоматически обновить список зависимостей в **go.mod** при запуске программы (имеется в виду вызов `go run`, `go build`, `go test`), если путь импорта библиотеки — это URL до репозитория с кодом и не требуется версия библиотеки, отличная от актуальной.

#### Подмена зависимостей

Иногда нужно подменить библиотеку в коде её форком (копией), но при этом не менять все пути импорта. Например, в ситуации, когда в библиотеке обнаружен критичный баг, PR отправлен, но нет времени ждать, когда его зальют.  

На помощь приходит директива `replace`. В прошлом уроке её использовали, чтобы определить положение локального модуля в файловой системе. Но эта директива также позволяет заменить один внешний модуль (или определённую его версию) на другой.  

Это можно сделать так:

```bash
replace (
    golang.org/x/net v1.2.3 => example.com/fork/net v1.4.5
    golang.org/x/net => example.com/fork/net v1.4.5
)
```

---

## Горутины

> [*---> вернуться списку тем*](#навигация-по-темам)

**Горутина** — это лёгкий поток выполнения, который запускается и управляется самой программой (а не операционной системой). Она позволяет выполнять функции одновременно с другими, что упрощает реализацию параллелизма и конкурентности в Go.

### Ключевые особенности

1. **Лёгкость**: Горутины занимают гораздо меньше памяти, чем системные потоки, и запускаются быстрее.
2. **Управление**: В отличие от потоков([Threads](about_threads_cs_go.md)), которыми управляет ОС, горутины управляются рантаймом Go.
3. **Параллелизм и конкурентность**: Горутины позволяют одновременно обрабатывать задачи (конкурентность) и эффективно использовать многопроцессорные системы (параллелизм).

### Синтаксис горутины

Для запуска горутины используется ключевое слово **`go`** перед вызовом функции:

```go
go nameFunc(args)
```

```go
go fmt.Println("Привет, горутина!")
```

---

### Пример: Запуск простой горутины

```go
func printMessage() {
    fmt.Println("Привет, из горутины!")
}

func main() {
    go printMessage() // Запускаем функцию как горутину

    // Ждём, чтобы горутина успела выполнить свою работу
    time.Sleep(1 * time.Second)
    fmt.Println("Программа завершена.")
}
```

**Объяснение**:

1. `go printMessage()` запускает функцию `printMessage` как горутину.
2. Главная горутина (функция `main`) продолжает выполняться, не ожидая завершения `printMessage`.
3. `time.Sleep(1 * time.Second)` даёт достаточно времени, чтобы `printMessage` завершилась.

---

### Пример: Горутина с аргументами

```go
func greet(name string) {
    fmt.Printf("Привет, %s!\n", name)
}

func main() {
    go greet("Мир") // Запускаем горутину с аргументом
    go greet("Go")  // Запускаем ещё одну горутину

    // Ожидаем завершения горутин
    time.Sleep(1 * time.Second)
    fmt.Println("Все горутины завершены.")
}
```

**Объяснение**:

1. `go greet("Мир")` запускает функцию `greet` с аргументом `"Мир"`.
2. `time.Sleep` даёт время горутинам выполнить свои задачи до завершения программы.

---

### Применение горутин

Горутины применяются, когда нужно выполнять задачи одновременно, эффективно распределяя ресурсы.

---

#### Пример 1: Параллельная обработка данных

```go
package main

import (
    "fmt"
    "time"
)

func processData(id int, data int) {
    fmt.Printf("Worker %d: Обрабатывает данные %d\n", id, data)
    time.Sleep(time.Second) // Имитация сложной обработки
    fmt.Printf("Worker %d: Завершил обработку\n", id)
}

func main() {
    data := []int{10, 20, 30, 40}
    for i, d := range data {
        go processData(i+1, d) // Запускаем горутину для каждого элемента данных
 }

    // Ждём завершения всех горутин
    time.Sleep(3 * time.Second)
    fmt.Println("Все данные обработаны.")
}
```

**Объяснение**:

1. Для каждого элемента данных создаётся горутина.
2. Каждая горутина работает независимо, обрабатывая свой кусок данных.
3. `time.Sleep` в конце главной функции ждёт завершения всех горутин.

---

#### Пример 2: Таймер с горутинами

```go
package main

import (
    "fmt"
    "time"
)

func timer(duration int, done chan bool) {
    time.Sleep(time.Duration(duration) * time.Second)
    fmt.Printf("Таймер %d секунд завершён.\n", duration)
    done <- true
}

func main() {
    done := make(chan bool, 2) // Канал для синхронизации

    go timer(3, done)
    go timer(5, done)

    // Ожидание завершения обоих таймеров
    <-done
    <-done
    fmt.Println("Все таймеры завершены.")
}
```

**Объяснение**:

1. Запускаются два таймера с разным временем ожидания.
2. Горутины сигнализируют через канал, когда они завершаются.
3. Главная горутина ожидает завершения всех таймеров.

---

#### Пример 3: Веб-сервер с горутинами

```go
package main

import (
    "fmt"
    "net/http"
)

func handler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, "Привет, запрос обработан в горутине!\n")
}

func main() {
    http.HandleFunc("/", handler)
    fmt.Println("Сервер запущен на порту 8080")
    http.ListenAndServe(":8080", nil) // Каждое подключение обрабатывается в отдельной горутине
}
```

**Объяснение**:

1. Go автоматически создаёт новую горутину для каждого входящего HTTP-запроса.
2. Сервер остаётся отзывчивым, даже если один из запросов занимает много времени.

---

### Best Practices - `go`

1. **Не забывайте синхронизацию**:
   - Используйте каналы или `sync.WaitGroup`, чтобы убедиться, что все горутины завершились.

2. **Избегайте утечек горутин**:
   - Если горутина заблокирована навсегда (например, ожидает на канале), это может привести к утечке ресурсов.

3. **Будьте осторожны с разделяемыми данными**:
   - Используйте мьютексы (`sync.Mutex`) для защиты данных от одновременного изменения.

4. **Используйте буферизированные каналы**:
   - Это помогает избежать блокировки, если отправка или получение данных задерживаются.

5. **Отслеживайте количество горутин**:
   - Большое количество горутин может перегрузить программу, даже если они "лёгкие".

6. **Используйте `context` для управления временем жизни**:
   - Это помогает завершать горутины, когда они больше не нужны.

---

| Потоки ОС                             | Горутины в GO                                     |
|---------------------------------------|---------------------------------------------------|
| Потоки ОС управляются ядром ОС        | Горутины управляются "рантаймом" Go               |
| Потоки ОС в основном имеют фиксированный размер в 1-2MB | Горутины обычно имеют размер стека 2KB          |
| Размер стека определяется во время компиляции и не может увеличиваться | Размер стека определяется во время рантайма и может расти вплоть до 1GB, что возможно благодаря аллокации и освобождению места из хипа |
| У потоков нет простого способа коммуникации между собой. Такая коммуникация имеет большую задержку | Горутины используют "каналы" для быстрого общения между собой с маленькой задержкой |

---

## Каналы

> [*---> вернуться списку тем*](#навигация-по-темам)

**Каналы (channels)** — это механизм синхронизации и передачи данных между горутинами в языке Go. Они позволяют одной горутине отправить данные, а другой — получить их, обеспечивая синхронизацию и безопасность.

Каналы позволяют:

1. **Отправлять данные** из одной горутины.
2. **Принимать данные** в другой горутине.
3. Обеспечивать синхронизацию между горутинами.

### Ключевые особенности каналов

1. **Типобезопасность**: Каналы работают с определённым типом данных. Например, `chan int` — канал, который передаёт только целые числа.
2. **Синхронизация**: Отправка и получение данных через канал блокируют выполнение, пока другая сторона (отправитель или получатель) не завершит операцию.
3. **Направления**: Каналы могут быть:
   - **Двусторонними**: данные можно отправлять и получать.
   - **Односторонними**: только отправка (`chan<-`) или только получение (`<-chan`).
4. Каналы могут быть **буферизированными**, чтобы временно хранить данные, или **небуферизированными**, что требует немедленной передачи данных.

### Синтаксис каналов

1. **Создание канала**:

   ```go
   c := make(chan int) // Небуферизированный канал для передачи целых чисел
   cBuf := make(chan int, 3) // Буферизированный канал с ёмкостью 3
   ```

2. **Отправка данных в канал**:

   ```go
   c <- 42 // Отправляем число 42 в канал
   ```

3. **Получение данных из канала**:

   ```go
   value := <-c // Получаем значение из канала
   ```

4. **Закрытие канала**:

   ```go
   close(c) // Закрывает канал, чтобы другие горутины знали, что отправка данных завершена
   ```

---

### Буферизация каналов

**Буферизированные каналы** позволяют отправлять данные без немедленного получения, если буфер не заполнен. Это полезно, когда одна горутина производит данные быстрее, чем другая их обрабатывает.
Если буфер заполнен, отправка данных блокирует выполнение до тех пор, пока место в буфере не освободится.
Буферизированные каналы позволяют хранить ограниченное количество сообщений до того, как одна из горутин (отправляющая или получающая) будет заблокирована.

- Небуферизированный канал блокирует до передачи.
- Буферизированный канал может временно хранить сообщения в памяти.

```go
c := make(chan int, 2) // Буферизированный канал с ёмкостью 2
c <- 1                 // Помещаем 1 в канал
c <- 2                 // Помещаем 2 в канал
// Пока буфер не заполнен, выполнение не блокируется
```

- В `c`, можно отправить `2` значения в буфер, прежде чем канал заблокирует.
- В **небуферизированный** канале блокировка наступает сразу после получения первого сообщения.

#### Пример 1: Небуферизированный канал

```go
package main

import (
    "fmt"
)

func main() {
    c := make(chan string) // Создаём канал для строк

 // Горутина, отправляющая сообщение
 go func() {
        c <- "Привет, горутина!" // Отправляем сообщение в канал
    }()

    // Главная горутина получает сообщение
    message := <-c // Получаем сообщение из канала
    fmt.Println(message) // Вывод: Привет, мир!
}
```

**Объяснение**:

1. Горутина отправляет строку "Привет, горутина!" в канал.
2. Главная горутина блокируется при ожидании данных, пока не получит сообщение.

#### Пример 2: Буферизированный канал

```go
package main

import (
    "fmt"
)

func main() {
    c := make(chan int, 2) // Создаём буферизированный канал с размером 2       

    c <- 1 // Отправляем данные в буфер
    c <- 2 // Ещё одно значение в буфер

    fmt.Println(<-c) // Считываем 1 из канала
    fmt.Println(<-c) // Считываем 2 из канала
}

```

**Объяснение**:

1. Буфер канала позволяет отправить 2 значения без немедленного чтения.
2. Значения остаются в буфере до чтения.

---

#### Пример: Синхронизация с каналами

```go
package main

import (
    "fmt"
    "time"
)

func worker(done chan bool) {
    fmt.Println("Работа началась...")
    time.Sleep(2 * time.Second) // Имитация работы
    fmt.Println("Работа завершена.")
done <- true // Сообщаем через канал, что работа завершена
}

func main() {
    done := make(chan bool)

    // Запускаем горутину
    go worker(done)

    // Ожидаем завершения работы через канал
    <-done
    fmt.Println("Главная горутина: Завершение программы.")
}
```

**Объяснение**:

1. Создаётся канал `done` для передачи сигнала о завершении работы.
2. Горутина выполняет некоторую "работу" и сигнализирует через канал, когда завершит её.
3. Главная горутина ожидает этот сигнал перед завершением программы.

---

### Примитивы синхронизации горутин

Примитивы синхронизации горутин в Go — это инструменты, которые позволяют управлять взаимодействием горутин, обеспечивая их безопасную и скоординированную работу с общими данными или ресурсами. Простыми словами, это способы “договориться” между горутинами, чтобы они не мешали друг другу

Если горутины работают с общими данными одновременно, без синхронизации могут возникнуть ошибки:

- Перезапись данных.
- Потеря данных.
- “Гонки” горутин (race conditions), когда результат зависит от порядка их выполнения.

Race Detector — это встроенный инструмент в Go, который используется для обнаружения состояний гонки (race conditions) в коде, работающем с горутинами. Состояние гонки возникает, когда две или более горутины одновременно обращаются к одной и той же переменной, и хотя бы одна из них выполняет запись, что может привести к некорректным результатам.

**Как работает Race Detector:**

 1. **Отслеживание доступа к памяти**  
Race Detector отслеживает все операции чтения и записи в переменные, выполняемые разными горутинами, и проверяет, есть ли конфликт между ними.
 2. **Выявление небезопасных операций**  
Если две горутины одновременно обращаются к одному и тому же объекту в памяти без синхронизации (например, через sync.Mutex), это считается состоянием гонки.
 3. **Генерация отчёта**  
При обнаружении состояния гонки Race Detector выводит подробную информацию:

    - Какие горутины участвовали в конфликте.
    - Где в коде произошло обращение к ресурсу.
    - Какой ресурс вызвал конфликт.

#### Основные примитивы синхронизации

 1. Мьютекс (`sync.Mutex`)  
    Это замок, который позволяет одной горутине получить доступ к общему ресурсу, пока другие горутины ждут своей очереди.

    **Пример:** Горутина блокирует мьютекс перед записью в общую переменную и разблокирует после завершения работы. Пока мьютекс заблокирован, другие горутины не могут получить доступ к этому ресурсу.

 2. Чтение-запись мьютекс (`sync.RWMutex`)  
    Это расширение мьютекса, которое позволяет нескольким горутинам одновременно читать данные, но блокирует доступ для записи, пока кто-то уже записывает.  
    **Пример:** Если много горутин читают данные, они могут делать это параллельно. Но если одна горутина записывает данные, чтение блокируется.

 3. Условные переменные (`sync.Cond`)  
    Это инструмент для организации ожидания: одна горутина “ждет” сигнала, а другая горутина “посылает” сигнал, чтобы ожидание завершилось.  
    **Пример:** Горутина ждет, пока список задач не станет непустым, и другая горутина добавляет в него задачу.

 4. Каналы (`chan`)  
    Это встроенный механизм обмена данными между горутинами. Горутины могут отправлять данные в канал и получать их, синхронизируя выполнение.  
    **Пример:** Одна горутина отправляет данные в канал, а другая ждет их, блокируясь, пока данные не появятся.

 5. Семафоры (на базе каналов)  
    Это способ ограничить количество горутин, выполняющих одну и ту же работу одновременно. Используются для управления доступом к ресурсам с ограниченной емкостью.

 6. Группа ожидания (`sync.WaitGroup`)  
    Это инструмент, позволяющий дождаться завершения нескольких горутин.  
    **Пример:** Запускаем 10 горутин для выполнения задач и ждем, пока они все завершат работу.

 7. Пул объектов (`sync.Pool`)  
    Это способ повторно использовать объекты, чтобы не выделять память заново. Помогает ускорить программы с частым созданием и удалением объектов.

### Применение каналов в реальной практике

#### 1. **Передача данных между горутинами**

Каналы используются, чтобы горутины могли безопасно обмениваться данными. Например, сбор результатов из нескольких горутин.

```go
package main

import (
    "fmt"
)

func calculateSquare(num int, results chan int) {
    results <- num * num // Отправляем квадрат числа в канал
}

func main() {
    numbers := []int{2, 4, 6, 8}
    results := make(chan int, len(numbers)) // Буферизированный канал

    // Запускаем горутины для вычислений
    for _, num := range numbers {
        go calculateSquare(num, results)
    }

    // Считываем результаты
    for i := 0; i < len(numbers); i++ {
        fmt.Println("Квадрат:", <-results)
    }
}
```

---

#### 2. **Синхронизация нескольких горутин**

Используется для координации завершения работы горутин.

```go
package main

import (
    "fmt"
    "time"
)

func worker(id int, done chan bool) {
    fmt.Printf("Worker %d: Начал работу\n", id)
    time.Sleep(time.Second)
    fmt.Printf("Worker %d: Закончил работу\n", id)
    done <- true
}

func main() {
    const numWorkers = 3
    done := make(chan bool, numWorkers) // Буферизированный канал

    for i := 1; i <= numWorkers; i++ {
        go worker(i, done)
    }

    // Ожидаем завершения всех горутин
    for i := 0; i < numWorkers; i++ {
        <-done
    }
    fmt.Println("Все работы завершены!")
}
```

---

#### 3. **Таймауты и селекторы**

Каналы используются с `select`, чтобы обрабатывать таймауты и множественные операции.

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    c := make(chan string)

    // Запускаем горутину
    go func() {
        time.Sleep(2 * time.Second) // Имитация работы
        c <- "Результат работы"
    }()

    select {
    case res := <-c:
        fmt.Println("Получено:", res)
    case <-time.After(1 * time.Second):
        fmt.Println("Таймаут!")
    }
}
```

**Объяснение**:

1. Если горутина не успевает отправить данные за 1 секунду, срабатывает таймаут через `time.After`.

---

#### 4. **Обработка задач в нескольких горутинах**

```go
package main

import (
    "fmt"
    "time"
)

func worker(id int, tasks <-chan int, results chan<- int) {
    for task := range tasks {
        fmt.Printf("Worker %d: Обрабатываю задачу %d\n", id, task)
        time.Sleep(time.Second) // Имитация работы
        results <- task * 2 // Отправляем результат
    }
}

func main() {
    tasks := make(chan int, 5)
    results := make(chan int, 5)

    // Запуск 3 рабочих горутин
    for i := 1; i <= 3; i++ {
        go worker(i, tasks, results)
    }

    // Отправляем задачи
    for i := 1; i <= 5; i++ {
        tasks <- i
    }
    close(tasks) // Закрываем канал задач

    // Получаем результаты
    for i := 1; i <= 5; i++ {
        fmt.Printf("Результат: %d\n", <-results)
    }
}
```

**Объяснение**:

- Канал `tasks` передаёт задачи рабочим горутинам.
- Канал `results` собирает результаты.
- 3 рабочих горутины обрабатывают задачи одновременно.

---

#### 5. **Таймаут при ожидании данных**

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    c := make(chan string)

    go func() {
        time.Sleep(2 * time.Second) // Имитация долгой операции
        c <- "Данные готовы!"
    }()

    select {
    case message := <-c:
        fmt.Println(message)
    case <-time.After(1 * time.Second):
        fmt.Println("Таймаут!")
    }
}
```

**Объяснение**:

- Используется `select`, чтобы завершить ожидание, если данные не поступили за 1 секунду.

---

#### 6. **Синхронизация завершения горутин**

```go
package main

import (
    "fmt"
    "sync"
)

func worker(id int, wg *sync.WaitGroup) {
    defer wg.Done() // Уменьшаем счётчик, когда работа завершена
    fmt.Printf("Worker %d: Начал работу\n", id)
    fmt.Printf("Worker %d: Завершил работу\n", id)
}

func main() {
    var wg sync.WaitGroup

    // Запускаем 3 горутины
    for i := 1; i <= 3; i++ {
        wg.Add(1)
        go worker(i, &wg)
    }

    wg.Wait() // Ожидаем завершения всех горутин
    fmt.Println("Все работы завершены.")
}
```

**Объяснение**:

- Каналы в этом примере не используются, но `WaitGroup` синхронизирует завершение работы всех горутин.

**Как работает `WaitGroup` в этом коде:**

`WaitGroup` управляет счётчиком, который увеличивается при добавлении горутины и уменьшается, когда горутина завершает свою работу. Главная горутина (или другая часть программы) может дождаться, пока все горутины завершатся, с помощью метода `Wait`.

1. **Создание `WaitGroup`:**
   - `var wg sync.WaitGroup` создаёт объект для отслеживания горутин.

2. **Добавление задач:**
   - В цикле `wg.Add(1)` увеличивает счётчик на 1 для каждой новой горутины.
   - После цикла счётчик равен 3 (так как добавлены 3 горутины).

3. **Работа горутин:**
   - Каждая горутина выполняет функцию `worker`.
   - Когда горутина завершает свою работу, вызывается `wg.Done()`, уменьшая счётчик на 1.

4. **Ожидание завершения:**
   - `wg.Wait()` блокирует выполнение главной горутины, пока счётчик не станет равен 0.
   - Как только все горутины вызовут `Done()`, программа продолжает выполнение.

---

#### Что такое `WaitGroup`?

`sync.WaitGroup` — это структура из стандартной библиотеки Go, которая используется для **синхронизации горутин**.  

Она позволяет:

1. **Ожидать завершения группы горутин**.
2. Следить за тем, сколько горутин ещё выполняются.

#### Как работает `WaitGroup`?

1. **Создание `WaitGroup`**:
   - Сначала создаётся экземпляр `sync.WaitGroup`, который будет отслеживать горутины.

   ```go
   var wg sync.WaitGroup
   ```

2. **Увеличение счётчика**:
   - Для каждой новой горутины вызывается метод `Add(n)`, где `n` — это количество горутин, которые добавляются в список отслеживаемых.

   ```go
   wg.Add(1) // Увеличиваем счётчик на 1
   ```

3. **Уменьшение счётчика**:
   - Когда горутина завершает свою работу, она вызывает метод `Done()`, чтобы уменьшить счётчик на 1.

   ```go
   defer wg.Done() // Уменьшает счётчик на 1, когда горутина завершится
   ```

4. **Ожидание завершения**:
   - Главная горутина (или любая другая) может заблокироваться, ожидая, пока счётчик не станет равным 0. Это делается с помощью метода `Wait()`.

   ```go
   wg.Wait() // Блокирует выполнение до тех пор, пока счётчик не станет равен 0
   ```

#### Синтаксис `sync.WaitGroup`

Вот основные методы и их функции:

1. **`Add(n int)`**:
   - Увеличивает счётчик на `n` (количество горутин, которые нужно отслеживать).

   ```go
   wg.Add(1) // Увеличиваем счётчик на 1
   ```

2. **`Done()`**:
   - Уменьшает счётчик на 1, сигнализируя, что одна горутина завершилась.

   ```go
   defer wg.Done() // Вызывается в горутине, чтобы уменьшить счётчик
   ```

3. **`Wait()`**:
   - Блокирует выполнение программы до тех пор, пока счётчик не станет равным 0 (то есть пока все горутины не завершатся).

   ```go
   wg.Wait() // Ждём завершения всех горутин
   ```

***Простое объяснение "в жизни"***

*Представьте, что вы отправляете 3 сотрудника выполнять задачи:*

1. *Вы добавляете всех 3 сотрудников в список ожидания.*
2. *Каждый сотрудник завершает свою задачу и сообщает вам, что он закончил*
3. *Вы ждёте, пока все сотрудники не сообщат о завершении работы, и только тогда закрываете офис.*

*`WaitGroup` — это ваш список сотрудников, а методы `Add()`, `Done()` и `Wait()` управляют процессом ожидания.*

---

### Что такое `deadlock`?

`Deadlock` — это ситуация, когда горутины блокируются и больше не могут продолжать выполнение, потому что ждут друг друга или недоступных ресурсов. В контексте работы с каналами в Go, `deadlock` возникает, когда

 1. Одна горутина ждёт данные из канала, но никто их туда не отправляет.
 2. Горутина пытается отправить данные в канал, но никто их не читает.
 3. Все горутины завершились, а канал остался в состоянии ожидания.

#### Как избежать `deadlock`’ов?

 1. **Убедитесь, что есть читатель для каждого писателя и наоборот.**
    - Если одна горутина пишет данные в канал, другая должна быть готова их читать.
 2. **Используйте буферизированные каналы, если одновременный доступ невозможен.**
    - Буфер позволяет временно сохранять данные, если читатель пока не доступен.
 3. **Контролируйте завершение горутин.**
    - Используйте каналы или sync.WaitGroup для синхронизации завершения горутин.
 4. **Закрывайте каналы корректно.**
    - Закрывайте канал только тогда, когда вы уверены, что больше не будете в него писать.

---

### Конструкция `select` в Go

`select` — это специальная конструкция в Go, которая позволяет обрабатывать операции с несколькими каналами одновременно. Она работает аналогично оператору switch, но предназначена для операций чтения из и записи в каналы.

#### Для чего используется `select`

 1. **Обработка данных из нескольких каналов одновременно**
    - Выборка канала, который готов к операции (чтение или запись).
 2. **Избежание блокировок**
    - Если канал временно недоступен, `select` позволяет продолжать выполнение, не блокируя всю программу.
 3. **Установка тайм-аутов для операций**
    - `select` можно использовать вместе с каналами таймеров, чтобы задать максимальное время ожидания.
 4. **Обработка случаев отсутствия данных в каналах**
    - Конструкция `select` поддерживает блок `default`, который выполняется, если ни одна операция с каналами не готова.

#### Как работает `select`

- `select` ожидает, пока хотя бы одна операция (чтение или запись) с каналами станет доступной.
- Если несколько каналов готовы одновременно, выбирается один из них случайным образом.
- Если ни один канал не готов и нет блока `default`, выполнение блокируется.

#### Примеры использования

1. **Обработка данных из нескольких каналов**

    ```go
    package main

    import "fmt"

    func main() {
        ch1 := make(chan string)
        ch2 := make(chan string)

        // Горутина для записи в ch1
        go func() {
            ch1 <- "Data from channel 1"
        }()

        // Горутина для записи в ch2
        go func() {
            ch2 <- "Data from channel 2"
        }()

        select {
        case msg := <-ch1:
            fmt.Println("Received:", msg)
        case msg := <-ch2:
            fmt.Println("Received:", msg)
        }
    }
    ```

    **Объяснение:**

    - `select` выберет канал, который первый предоставит данные.
    - Если оба готовы одновременно, выбор будет случайным.

2. **Установка тайм-аута**

    ```go
    package main

    import (
        "fmt"
        "time"
    )

    func main() {
        ch := make(chan string)

        go func() {
            time.Sleep(2 * time.Second)
            ch <- "Data from channel"
        }()

        select {
        case msg := <-ch:
            fmt.Println("Received:", msg)
        case <-time.After(1 * time.Second):
            fmt.Println("Timeout! No data received.")
        }
    }
    ```

    **Объяснение:**

    - Если данные не поступят в течение 1 секунды, выполнится тайм-аут через канал time.After.

3. Обработка блока default

    ```go
    package main

    import "fmt"

    func main() {
        ch := make(chan string)

        select {
        case msg := <-ch:
            fmt.Println("Received:", msg)
        default:
            fmt.Println("No data available, continuing execution.")
        }
    }
    ```

    **Объяснение:**

    - Если канал ch пуст, выполнится блок default, и программа продолжит работу без блокировки.

#### Преимущества использования `select`

 1. **Гибкость** — позволяет динамически работать с несколькими каналами.
 2. **Управление конкурентностью** — облегчает обработку данных между горутинами.
 3. **Избежание блокировок** — позволяет обрабатывать недоступность каналов через `default` или тайм-ауты.

---

### **Аксиомы каналов:**

- запись в неинициализированный канал блокирует поток навсегда
- чтение из неинициализированного канала блокирует поток навсегда
- запись в закрытый канал вызывает панику
- чтение из закрытого канала далет нулевое значение мнгновенно

---

### Best Practices - `chan`

1. **Закрывайте каналы, если больше не собираетесь отправлять данные**:
   - Закрывайте канал с помощью `close(channel)` только с отправляющей стороны, чтобы избежать утечек памяти.
   - Получатели могут использовать цикл `for v := range c` для чтения данных до закрытия канала.
   - Никогда не отправляйте данные в закрытый канал.

2. **Ограничивайте буфер**:
   - Избегайте слишком большого буфера, чтобы не создавать проблемы с памятью.

3. **Используйте буферизированные каналы при необходимости**:
   - Буфер помогает избежать блокировки, если отправитель или получатель временно недоступны.

4. **Избегайте конкуренции**:
   - Не позволяйте нескольким горутинам одновременно записывать или читать из одного канала без координации.

5. **Используйте односторонние каналы**:
   - Объявляйте каналы с направлением (`chan<-` для отправки, `<-chan` для получения) для большей безопасности кода.

6. **Используйте `select` для обработки нескольких каналов**:
   - Это гибкий инструмент для обработки случаев, когда нужно слушать несколько каналов.

7. **Контролируйте утечки горутин**:
   - Не оставляйте горутины заблокированными на операции с каналом. Используйте `select` с таймаутами или закрытием каналов.

8. **Документируйте тип канала и его назначение**:
   - Чётко указывайте, для чего используется канал (например, передача задач или сигналов завершения).
   - Делайте каналы односторонними (`chan<-` для отправки, `<-chan` для получения), если возможно, чтобы сделать код понятнее и безопаснее.

---

[Видео - "Горутины, каналы, пакет "sync". Конкурентность в Go."](<https://www.youtube.com/watch?v=wHQBMDInWEg&list=PLbTTxxr-hMmxZMXsvaE-PozXxktdJ5zLR&index=8>)

[Видео - "Внутреннее устройство каналов в Go"](https://www.youtube.com/watch?v=8NhcDt1BCmc)

[Видео - "Как на самом деле устроены каналы в Golang?"](https://www.youtube.com/watch?v=ZTJcaP4G4JM)

[Область памяти Heap(куча) - конспект](heap_cs_Go.md)

---

## Операции над каналами

| Operation      | Channel State           | Result                                                                 |
|----------------|-------------------------|------------------------------------------------------------------------|
|    **Read**    | nil                     | Block                                                                  |
|                | Open and Not Empty      | Value                                                                  |
|                | Open and Empty          | Block                                                                  |
|                | Closed                  | `<default value>` - false                                              |
|                | Write Only              | Compilation Error                                                      |
|                |                         |                                                                        |
|  **Write**     | nil                     | Block                                                                  |
|                | Open and Full           | Block                                                                  |
|                | Open and Not Full       | Write Value                                                            |
|                | Closed                  | ***panic***                                                            |
|                | Receive Only            | Compilation Error                                                      |
|                |                         |                                                                        |
| **Close**      | nil                     | ***panic***                                                            |
|                | Open and Not Empty      | Closes Channel; reads succeed until channel is drained, then reads produce default value |
|                | Open and Empty          | Closes Channel; reads produce default value                            |
|                | Closed                  | ***panic***                                                            |
|                | Receive Only            | Compilation Error                                                      |

---

[**О конуркнтности и паралелизме** - конспект](paral_concur_cs_GO.md)

[Видео - "Как на самом деле устроены каналы в Golang?"](https://www.youtube.com/watch?v=ZTJcaP4G4JM)

---

## Стек и Куча в Go

> [*---> вернуться списку тем*](#навигация-по-темам)

Go управляет памятью через два основных типа области памяти: стек (**stack**) и куча (**heap**).

### Стек (Stack)

Стек — это структура памяти с ограниченным размером, работающая по принципу LIFO (последним пришёл — первым ушёл).

Особенности:

- Локальные переменные функций (переменные с ограниченной областью видимости) хранятся в стеке.
- Очень быстрый доступ к данным благодаря последовательной структуре.
- Память автоматически освобождается, когда функция завершает выполнение (переменные на стеке больше не нужны).
- Размер стека ограничен, поэтому он используется только для небольших данных (например, чисел, указателей, структур малых размеров).

**Пример:**

```go
package main

import "fmt"

func stackExample() {
    x := 42 // Локальная переменная, хранится в стеке
    fmt.Println(x)
}

func main() {
    stackExample() // После выхода из функции x автоматически удаляется
}
```

Когда функция `stackExample` завершает выполнение, переменная `x` **удаляется** из стека.

### Куча (Heap)

Куча — это область памяти для хранения данных, которые должны жить дольше, чем время выполнения одной функции.

Особенности:

- Используется для хранения данных с динамическим временем жизни (например, переменных, переданных через указатели или возвращаемых из функций).
- Объём кучи значительно больше, чем стека, но доступ к данным на куче медленнее из-за необходимости управления памятью.
- Память освобождается сборщиком мусора (Garbage Collector), когда на объект больше нет ссылок.
- Применяется для больших структур и массивов.

**Пример:**

```go
package main

import "fmt"

func heapExample() *int {
    x := 42        // Переменная создаётся на стеке
    return &x      // Указатель на x "эвакуирует" её в кучу
}

func main() {
    ptr := heapExample() // x "перемещена" в кучу
    fmt.Println(*ptr)    // Доступ к x через указатель
}
```

**Почему x перемещается в кучу?**

- Переменная `x` должна быть доступна после завершения функции, поэтому Go автоматически перемещает её в кучу.

### Отличие стека и кучи

| Характеристика | Стек | Куча |  
|----------------|-------------------------|----------------------------|  
| Область использования | Локальные переменные функций | Глобальные данные, структуры, динамические данные |  
| Скорость | Быстрое выделение и освобождение | Медленнее из-за работы сборщика мусора |  
| Жизненный цикл данных | Ограничен временем выполнения функции | Динамический, управляется GC |  
| Размер | Ограничен и небольшой | Гораздо больше |
| Контроль | Автоматический | Сборщик мусора (Garbage Collector) |

### Эвакуация (Escape Analysis)

Go использует анализ эвакуации (escape analysis) для определения, где разместить переменную (в стеке или куче).

Принципы эвакуации:

- Если переменная используется только внутри функции, она остаётся в стеке.
- Если переменная должна жить дольше функции (например, возвращается из неё или передаётся через указатель), она “эвакуируется” в кучу.

**Пример:**

```go
package main

func example() *int {
    x := 10 // Переменная x может "эвакуироваться"
    return &x
}
```

**Объяснение:**  

- Переменная x перемещается в кучу, так как указатель на неё возвращается из функции.

### Практика: стек и куча

**Маленькие структуры:**

```go
package main

import "fmt"

func main() {
    x := 10
    fmt.Println(x) // Локальная переменная x хранится в стеке
}
```

**Большие данные:**

```go
package main

import "fmt"

func main() {
    largeArray := make([]int, 1_000_000) // Массив выделяется в куче
    fmt.Println(len(largeArray))
}
```

### Резюме

- Стек: Используется для **локальных переменных и краткоживущих данных**. Работает быстро, память освобождается автоматически.
- Куча: Применяется **для данных, которые должны жить дольше, чем время выполнения функции**. Память освобождается сборщиком мусора.
- Go управляет памятью автоматически, используя эвакуацию и сборщик мусора.

---
