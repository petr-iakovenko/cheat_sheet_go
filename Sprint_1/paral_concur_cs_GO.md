# Конкурентность и паралелизм в программировании

[Видео - **О конуркнтности и паралелизме**](paral_concur_cs_GO.md)

---

## Конкурентность и параллелизм в программировании

### Конкурентность (Concurrency)

Конкурентность — это способность программы выполнять **несколько задач одновременно**, **но не обязательно в один и тот же момент времени**. Главная идея в том, что задачи "сосуществуют" и могут переключаться между собой для максимального использования ресурсов.

Конкурентность полезна, когда нужно управлять несколькими потоками выполнения, например, обработкой множества запросов на сервере, где задачи могут приостанавливаться и возобновляться. (работает на логическом уровне)

---

### Параллелизм (Parallelism)

Параллелизм — это выполнение **нескольких задач одновременно**, **именно в один и тот же момент времени**. Это возможно только на многопроцессорных или многоядерных системах, где несколько ядер работают независимо, исполняя разные задачи. (работает на физическом уровне)

---

### Различия между конкурентностью и параллелизмом

| **Конкурентность**                          | **Параллелизм**                          |
|---------------------------------------------|------------------------------------------|
| Управляет многими задачами одновременно.    | Выполняет несколько задач одновременно.  |
| Зависит от логики переключения задач.       | Требует многопроцессорной архитектуры.   |
| Может работать на одном ядре процессора.    | Требует нескольких ядер или процессоров. |
| Пример: обработка запросов на сервере.      | Пример: рендеринг 3D-сцены.              |

**Таблица различий между параллелизмом и конкурентностью в Go:**

| **Конкурентность**                          | **Параллелизм**                             |
|---------------------------------------------|---------------------------------------------|
| Горутины используются для управления несколькими задачами, которые могут **переключаться** между собой. | Горутины выполняются одновременно на разных ядрах процессора. |
| Требует логики синхронизации, например, через **каналы (channels)** или **мьютексы**. | Зависит от наличия нескольких ядер процессора для выполнения нескольких задач одновременно. |
| Планировщик Go распределяет горутины между потоками ОС, **оптимизируя использование одного ядра**. | Несколько потоков ОС выполняют горутины **на разных ядрах процессора**. |
| Может работать на одном ядре процессора с помощью кооперативного планирования. | Требует наличия нескольких ядер для выполнения задач без переключений. |
| Пример: Обработка входящих HTTP-запросов с использованием нескольких горутин. | Пример: Распараллеливание вычислений при обработке больших массивов данных. |

Эта таблица показывает, как Go использует горутины и встроенный планировщик для управления конкурентностью и параллелизмом.

### Примеры работы с разными видами процессоров

#### 1. **Одноядерный процессор**

На одноядерном процессоре **конкурентность** возможна, но **параллелизм невозможен**, так как только одна задача может выполняться в данный момент времени. Пример:

- Сервер обрабатывает запросы, переключаясь между задачами, чтобы избежать блокировок.

#### 2. **Многоядерный процессор**

На многоядерных процессорах возможно как конкурентное выполнение (с разделением задач на ядра), так и параллельное выполнение. Пример:

- 4 ядра:
  - 2 ядра обрабатывают входящие сетевые запросы (конкурентно).
  - 2 ядра выполняют сложные вычисления (параллельно).

#### 3. **Многопроцессорная система**

Многопроцессорная система позволяет параллельное выполнение на уровне процессов. Пример:

- Каждый процесс запускает отдельный набор горутин для выполнения своих задач, эффективно используя ресурсы всех процессоров.

---

### Пример сервера

Представим сервер, который принимает запросы и обрабатывает их одновременно, используя конкурентность:

**Логика**:

1. Сервер запускает горутину для обработки каждого запроса.
2. Если процессор многопоточный, эти запросы могут выполняться параллельно.

**Реальный пример**:

- Сервер Go обрабатывает запросы пользователей API.
- Каждый запрос обрабатывается в отдельной горутине.
- Параллелизм достигается, если процессор поддерживает многопоточность, например, 8 ядер могут обрабатывать 8 запросов одновременно.

---

### Пример конкурентности и параллелизма в Go

Код-пример:  

```go
package main

import (
  "fmt"
  "sync"
  "time"
)

// worker — функция, имитирующая выполнение задачи, которая занимает 2 секунды.
func worker(id int) {
  fmt.Printf("Worker %d: Начал работу\n", id)
  time.Sleep(2 * time.Second) // Имитация длительной работы
  fmt.Printf("Worker %d: Закончил работу\n", id)
}

func main() {
  var wg sync.WaitGroup // WaitGroup используется для ожидания завершения всех горутин.
  wg.Add(3)             // Устанавливаем счетчик на 3, так как запускаем 3 горутины.

  for i := 1; i <= 3; i++ {
    // Запускаем горутину для каждого worker
    go func(id int) {
      defer wg.Done() // Уменьшаем счётчик WaitGroup после завершения горутины.
      worker(id)      // Вызываем функцию worker для выполнения задачи.
    }(i)              // Передаём переменную i в качестве аргумента.
 }

  wg.Wait() // Ожидаем завершения всех горутин.
  fmt.Println("Все работы завершены")
}
```

### Объяснение конкурентности и параллелизма из примера

#### 1. Конкурентность

- Конкурентность в этом примере реализована через **горутины**. Горутины запускают выполнение функции `worker` независимо от главного потока выполнения.
- Хотя все 3 горутины работают одновременно, они **не обязательно выполняются параллельно**, если процессор только одноядерный. Вместо этого задачи будут чередоваться (переключение между горутинами).

```go
go func(id int) {
  defer wg.Done() // Горутина сигнализирует, что завершила свою работу.
  worker(id)      // Выполнение работы (конкурентность: все горутины работают одновременно).
}(i)
```

- Здесь каждая горутина конкурирует за процессорное время, что демонстрирует **конкурентность**.

#### 2. Параллелизм

- Если процессор многоядерный, задачи `worker` могут быть выполнены **параллельно**, где каждая горутина исполняется на отдельном ядре.
- Например, на 2-ядерном процессоре:
  - Первая и вторая горутины могут работать параллельно, а третья начнёт, как только освободится одно из ядер.
- На 4-ядерном процессоре все 3 горутины могут выполняться одновременно (идеальный параллелизм).

```go
time.Sleep(2 * time.Second) // Имитация выполнения задачи (возможен параллелизм, если есть свободные ядра).
```

- Если ядра свободны, задачи исполняются **реально одновременно**.

#### 3. Главная горутина

- Главная горутина в функции `main` использует `WaitGroup`, чтобы ожидать завершения всех горутин. Это позволяет программе завершить выполнение только после того, как все горутины закончат свои задачи.

```go
wg.Wait() // Главная горутина блокируется, пока все горутины не завершатся (синхронизация конкурентных задач).
```

- Здесь `wg.Wait()` синхронизирует выполнение, чтобы завершение программы было корректным.

---

#### Итог логики кода

- **Конкурентность**: Каждая горутина запускает задачу одновременно, не ожидая завершения других.
- **Параллелизм**: Если процессор имеет несколько ядер, горутины могут выполняться одновременно на разных ядрах.
- Этот код подходит для задач, где несколько независимых операций могут быть выполнены одновременно, например, обработка запросов, вычисления или ввод/вывод.

---

### Общий итог

1. **Конкурентность**: управление задачами, выполняемыми одновременно.
2. **Параллелизм**: реальное выполнение задач одновременно на нескольких ядрах.
3. **Работа с разными процессорами**:
   - Одноядерные системы позволяют только конкурентность.
   - Многоядерные системы позволяют и конкурентность, и параллелизм.

---

## Кооперативная и вытесняющая многозадачность в Go

Многозадачность — это способность системы выполнять несколько задач одновременно. В контексте Go, планировщик управляет выполнением горутин, используя подходы, связанные с кооперативной и вытесняющей многозадачностью.

### Кооперативная многозадачность

В кооперативной многозадачности исполняемая задача должна добровольно передать управление планировщику, чтобы дать другим задачам возможность выполняться.

**Особенности:**

- Горутине необходимо выполнить определённые операции, которые сигнализируют планировщику о готовности уступить управление.
- Если горутина выполняет длинный цикл без вызова функций, связанных с кооперацией, другие горутины могут ждать.

**Примеры кооперации:**

- Системные вызовы: Например, `time.Sleep()`, `channel send/receive`, или ожидание блокировки.
- Функции из стандартной библиотеки, которые вызывают планировщик, как, например, `runtime.Gosched()`.

### Вытесняющая многозадачность

В вытесняющей многозадачности планировщик сам решает, когда приостановить текущую задачу и переключить выполнение на другую.

**Особенности:**

- Планировщик периодически проверяет горутины, чтобы определить, нужно ли переключить их выполнение.
- Даже если горутина работает в бесконечном цикле, планировщик может принудительно её остановить и передать управление другим.

Go начиная с версии 1.14 поддерживает вытесняющую многозадачность. Это сделано для того, чтобы избежать ситуаций, когда одна “плохо себя ведущая” горутина блокирует выполнение остальных.

**Механизм:**

- Компилятор вставляет проверки на принудительное вытеснение в ключевые точки программы (например, в циклы).
- Если горутина выполняется слишком долго без кооперации, планировщик может её вытеснить.

### Как работает планировщик Go

Планировщик Go управляет выполнением горутин с использованием концепции **M:N** многозадачности:

- M (Machine threads) — потоки операционной системы.
- P (Processors) — логические процессоры, которые распределяют задачи между потоками.
- G (Goroutines) — горутины, которые выполняются внутри потоков.

**Основные этапы работы:**

 1. **Создание горутины:**
    - Когда вы вызываете `go func()`, создаётся новая горутина `G`, которая ставится в очередь выполнения.
 2. **Исполнение:**
    - Логический процессор `P` берёт горутину `G` из очереди и привязывает её к доступному потоку `M`.
 3. **Уступка времени:** Горутине нужно “уступить управление” в следующих случаях:
    - Выполнение системных вызовов (например, работа с каналами или ожидание блокировки).
    - Истечение времени выполнения горутины, определённого планировщиком.
 4. **Сборка мусора:**
    - Планировщик приостанавливает выполнение горутин для выполнения сборки мусора (GC).
 5. **Балансировка:**
    - Если один поток занят слишком большим числом горутин, планировщик перераспределяет их между другими потоками.

### Пример работы планировщика

**Кооперативное переключение:**

```go
package main

import (
 "fmt"
 "time"
)

func worker(id int) {
 for i := 0; i < 5; i++ {
  fmt.Printf("Worker %d: %d\n", id, i)
  time.Sleep(100 * time.Millisecond) // Уступает управление планировщику
 }
}

func main() {
 go worker(1)
 go worker(2)

 time.Sleep(1 * time.Second) // Даёт время горутинам завершить работу
}
```

**Объяснение:**

- Вызов `time.Sleep` внутри цикла сигнализирует планировщику, что горутина готова уступить управление другим.

**Пример вытесняющего переключения:**

```go
package main

import (
 "fmt"
 "runtime"
)

func worker(id int) {
 for i := 0; i < 1e9; i++ { // Длинный цикл
  if i%1e8 == 0 {
   fmt.Printf("Worker %d reached %d\n", id, i)
  }
 }
}

func main() {
 runtime.GOMAXPROCS(1) // Ограничиваем до одного логического процессора
 go worker(1)
 go worker(2)

 // Даем время планировщику обработать обе горутины
 runtime.Gosched()
}
```

**Объяснение:**

- Несмотря на отсутствие явного time.Sleep, планировщик Go вставляет проверки вытеснения в длинные циклы. Это позволяет второй горутине также получать процессорное время.

**Заключение кооперативная и вытесняющая многозадачности:**

 1. Кооперативная многозадачность: Горутине нужно вызвать функции, которые позволяют планировщику переключиться.
 2. Вытесняющая многозадачность: Планировщик Go вставляет проверки в длинные циклы, чтобы избежать блокировки программы.

Планировщик Go — мощный инструмент, который позволяет горутинам эффективно разделять процессорное время, используя минимальные ресурсы.

---

## Синхронизация потоков в Go

Синхронизация потоков (или горутин) в Go необходима, чтобы избежать конфликтов при совместном доступе к общим ресурсам и гарантировать правильный порядок выполнения задач. Вот основные причины:

### Избежание состояния гонки (race condition)

Когда несколько горутин одновременно обращаются к одной и той же переменной или структуре данных без синхронизации, это может привести к некорректным результатам, потому что чтение и запись данных происходят хаотично.

**Пример ситуации:**
Две горутины одновременно увеличивают значение переменной. Если не синхронизировать их доступ, итоговое значение может оказаться неправильным.

### Гарантия последовательности выполнения

В некоторых случаях важно, чтобы одни задачи выполнялись строго до или после других. Синхронизация позволяет установить порядок выполнения.

**Пример ситуации:**
Одна горутина записывает данные в файл, другая читает из него. Без синхронизации чтение может начаться до завершения записи, что приведёт к ошибке.

### Обеспечение корректной работы общих ресурсов

Общие ресурсы (например, соединения с базой данных, файлы, очереди) могут быть испорчены, если к ним обращаются одновременно несколько горутин без синхронизации.

**Пример ситуации:**
Две горутины записывают данные в один и тот же файл одновременно, что может привести к повреждению данных.

### Безопасное завершение программы

Синхронизация нужна, чтобы убедиться, что все горутины завершили выполнение до выхода из программы. Без этого некоторые задачи могут остаться незавершёнными.

### **Синхронизация потоков в Go позволяет:**

- Избежать ошибок из-за одновременного доступа к общим данным.
- Убедиться, что задачи выполняются в нужном порядке.
- Гарантировать целостность данных и стабильную работу программы.

---
