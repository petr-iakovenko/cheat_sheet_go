# Что такое Thread?

**Thread (поток)** — это минимальная единица выполнения программы внутри процесса. Потоки позволяют выполнять несколько задач одновременно, разделяя ресурсы программы (например, память). Они являются основой для реализации **многопоточности** — механизма параллельного выполнения разных частей программы.

---

## Конкурентность и параллелизм

1. **Конкурентность (Concurrency)**:
   - Это способность программы обрабатывать несколько задач одновременно, даже если они по факту не выполняются одновременно.
   - Например: вы пишете сообщение, а ваш телефон параллельно загружает приложение. Он быстро переключается между задачами, создавая иллюзию одновременности.

2. **Параллелизм (Parallelism)**:
   - Это одновременное выполнение нескольких задач на разных ядрах процессора.
   - Например: вы моете посуду, а кто-то другой готовит ужин — это реальная параллельная работа.

---

## Как потоки связаны с многозадачностью?

1. Каждый поток может выполнять отдельную задачу параллельно.
2. Потоки используют общее пространство памяти, что облегчает обмен данными, но может привести к конфликтам (например, когда два потока пытаются одновременно изменить одни и те же данные).

---

### Как это связано с Go?

В Go используются **горутины** вместо традиционных потоков.  
**Горутина** — это облегчённая версия потока, специально разработанная для упрощения работы с многозадачностью.  

### **Отличия горутин от потоков:**

1. **Лёгкость**:
   - Потоки ОС требуют много памяти (1-2 МБ), а горутины — всего 2 КБ.
   - Вы можете запустить тысячи горутин без значительного использования ресурсов.

2. **Управление**:
   - Потоки создаются и управляются операционной системой, что медленно.
   - Горутины управляются рантаймом Go, что быстрее и эффективнее.

3. **Конкурентность и параллелизм в Go**:
   - Go изначально спроектирован для конкурентного программирования.
   - Горутины могут выполняться конкурентно (на одном ядре) или параллельно (на нескольких ядрах), в зависимости от количества доступных ядер процессора и настройки Go (`GOMAXPROCS`).

---

### **Пример связи конкуренции и параллелизма в Go:**

- **Конкурентность**: Go запускает несколько горутин, переключаясь между ними, даже если доступно только одно ядро процессора.
- **Параллелизм**: Если процессор имеет несколько ядер, Go распределяет горутины по разным потокам ОС, чтобы они выполнялись одновременно.

---

## **Разница между горутинами и потоками:**  

### 1. **Потоки (Threads)**  

- **Поток** — это базовый объект операционной системы, который выполняет задачу.  
- Создание, переключение и управление потоками — **тяжеловесные операции**, потому что они требуют взаимодействия с ядром операционной системы.  
- Потоки потребляют больше памяти (обычно **1–2 МБ стека на поток**) и ресурсов.  
- Количество потоков ограничено ресурсами системы (оперативной памятью и производительностью).  
- Планированием потоков занимается операционная система.

---

### 2. **Горутины (Goroutines)**  

- **Горутина** — это легковесная "абстракция потока", предоставляемая рантаймом Go.  
- Они не привязаны к физическим потокам ОС.  
- Горутины используют **минимальный объем памяти на стек** (обычно **4–8 КБ** вместо мегабайтов).  
  - Стек горутины динамически расширяется при необходимости.
- Планированием горутин занимается **Go runtime**, а не операционная система. Это позволяет запускать тысячи (или даже миллионы) горутин одновременно.  
- Горутины используют **модель M:N**:
  - **M** горутин "сопоставляются" с **N** потоками ОС, чтобы максимально эффективно использовать ресурсы.

---

### 3. **Ключевые различия**  

| **Характеристика**     | **Горутины**                                                                 | **Потоки**                                                                 |
|-------------------------|------------------------------------------------------------------------------|-----------------------------------------------------------------------------|
| Управление              | Управляются рантаймом Go (user-space).                                       | Управляются операционной системой (kernel-space).                          |
| Память на стек          | 4–8 КБ (динамическое расширение).                                           | 1–2 МБ (фиксированный размер).                                             |
| Производительность      | Очень легковесные, переключение задач быстрее.                              | Тяжеловесные, переключение требует участия ОС.                             |
| Создание                | Быстрое, требует минимальных ресурсов.                                      | Медленное, так как требует системных вызовов.                              |
| Количество              | Десятки или сотни тысяч горутин.                                            | Обычно ограничено сотнями или тысячами потоков.                            |
| Планирование            | Проводится Go runtime (асинхронное, кооперативное).                         | Проводится ОС (прерывания, приоритеты).                                    |

---

### 4. **Почему горутины лучше для конкурентности?**  

- **Производительность**: Они масштабируются лучше, чем потоки, благодаря низкой нагрузке на систему.  
- **Параллелизм**: Если вы используете многоядерный процессор, Go runtime автоматически распределяет горутины по потокам для эффективного использования всех ядер.  
- **Синхронизация**: Go предоставляет встроенные инструменты, такие как каналы (channels), для упрощения взаимодействия между горутинами.  

---

### Общие черты между потоками и горутинами "под капотом"

1. **Использование стека**  
   - **Threads**: Каждый поток имеет свой **фиксированный стек** (обычно 1–2 МБ), который содержит локальные переменные, адреса возврата и т.д.  
   - **Goroutines**: Каждая горутина также имеет стек, но он **динамически изменяется**. Изначально размер стека горутины составляет всего 2–8 КБ, что позволяет эффективно использовать память.

2. **Исполнение на процессоре**  
   - Оба являются единицами исполнения, которые в конечном счете выполняются процессором.  
   - Процессор обрабатывает выполнение задач через ядра, а потоки и горутины обеспечивают способы разделения задач между этими ядрами.

3. **Контекст выполнения**  
   - Потоки и горутины имеют контекст выполнения, включая регистры, указатель стека, и другие данные, необходимые для возобновления выполнения после переключения.  
   - Переключение контекста происходит как у потоков, так и у горутин, но в горутинах это делается **пользовательским планировщиком (user-space scheduler)**, а у потоков — **ядром операционной системы (kernel-space scheduler)**.

4. **Планировщик**  
   - Оба используют планировщики для распределения задач между ядрами:  
     - Потоки планируются **операционной системой** (обычно с приоритетами и прерываниями).  
     - Горутины планируются **рантаймом Go**, который использует модель **M:N** (несколько горутин сопоставляются с потоками ОС).

5. **Взаимодействие с ядрами процессора**  
   - Потоки напрямую ассоциируются с ядрами через ОС.  
   - Горутины косвенно используют ядра через потоки ОС, которые управляются планировщиком Go runtime.  

---

### Ключевые особенности реализации горутин

1. **Модель M:N**  
   - В Go runtime несколько горутин сопоставляются с меньшим числом потоков ОС. Например, 1000 горутин могут выполняться через 4 потока ОС.  
   - Потоки ОС используются только для исполнения, а логика переключения горутин происходит на уровне Go runtime.

2. **Планировщик Go (Go Scheduler)**  
   - Планировщик Go использует **кооперативное планирование**:  
     - Горутины переключаются только в определенных точках выполнения (например, при вызове функций ввода/вывода или `runtime.Gosched()`).
   - Планировщик оптимизирует использование ядер процессора для максимальной производительности.  

3. **Работа со стеком**  
   - Стек горутины начинается с небольшого размера и динамически расширяется. Это позволяет эффективно управлять памятью.  
   - Потоки ОС используют фиксированный размер стека, что может привести к неэффективному использованию памяти.

4. **Переключение контекста**  
   - Горутины переключаются гораздо быстрее, так как это делается внутри user-space, без обращения к ядру ОС.  
   - Потоки требуют участия ядра, что добавляет задержки.

---

### Почему Go выбрал горутины вместо потоков?

- Эффективность: тысячи горутин могут быть запущены с минимальным использованием ресурсов.  
- Простота: планировщик Go скрывает сложность многопоточности от разработчика.  
- Интеграция: каналы и другие механизмы упрощают конкурентное программирование.

